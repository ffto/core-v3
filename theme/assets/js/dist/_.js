var FFTO = {
	VERSION : '2.5.1',
	BREAK   : '__BREAK__',
	CONTINUE: '__CONTINUE__',
	CLEAR   : '__CLEAR__',
	DEBUG   : '__DEBUG__',
	START   : '__START__',
	STOP    : '__STOP__',
	TRACE   : '__TRACE__',
	KEY     : '⚀ ⚁ ⚂ ⚃ ⚄ ⚅',
	EXPANDO : window.EXPANDO || '$CACHE',
};

window.START 	= FFTO.START;
window.STOP 	= FFTO.STOP;
window.TRACE 	= FFTO.TRACE;
window.BREAK    = FFTO.BREAK;
window.CONTINUE = FFTO.CONTINUE;

/** 
 * Utils singleton. All the main utility helpers are here.
 * @namespace utils
 */
FFTO.Utils = window.utils = (new function ($win, $doc){
	var _ 		 = this;
	var utils    = this;
	var settings = window.theme_settings || {};

	// contants --------------------------------------------------------------------------------------------------------
	var CONSTS = FFTO.CONSTS = {
		INITIALIZING: true,
		SUPPORT     : {},
		QUEUE       : {},
		HTTP 		: {},	// cached https
		TIMERS 		: {
			'*'  : Date.now(),
			'php': (settings.time_php) || Date.now(),
		},
		LOGS        : {
			ONCE : [],
			LAST : null,
			DEBUG: {},
		},
	};

	var RE = CONSTS.RE = {
		VARS       			: /\{{1,2}(.+?)\}{1,2}/g,
		COLOR_HEX       	: /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,
		COLOR_RGB       	: /^rgb/,
		COLOR_RGBA 			: /rgba\(([^\)]+)\)/g,
		COLOR_HSL       	: /^hsl/,
		SLUG_CASE       	: /((?:\_|\s|\-|\/|(?:[A-Z]+)))[a-z0-9]*/g,
		HTML_ATTR       	: /([a-z][a-z_0-9-]*\=((\"[^"]*\")|(\\\'[^\']*\\\')))/g,
		CSS_COMMENTS 		: /\/\*(.|\n|\r)+?\*\//gm,
		CSS_BLOCKS 			: /(.+?)\{((?:.|\r|\t|\n)+?)\}/gm,
		CSS_SELECTOR		: /^([a-z]+[a-z0-9_\-]*)([\.\[\{\:\=].+)?$/,
		CSS_SELECTOR_ITEMS 	: /(\#[a-z][\w-]*)|(\.[\-a-z&][\w-]*)|(\[.+?\])|(?:\{.+?\})|(\:[a-z][\w_-]*(\(.+?\))?)|(\=.+)|([a-z][\w-]*)/gi,
		EMAIL           	: /^([a-zA-Z0-9_\-\.\+]+)\@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/,
		PERCENT         	: /^-?[0-9]+(?:\.[0-9]+)?%$/,
		NUMBER_WITH_UNIT	: /(\-?\d+\.?\d*)([a-z\%]+)/g,
		NOT_NUMBER      	: /[^0-9\+\-\*\/\.\(\)]/g,
		SRC_URL 			: /url\(([^\)]+)\)/,
		IMAGE_EXT       	: /\.(jpg|jpeg|gif|png|svg|webp)(?:\?|\#|$)/ig,
		VIDEO_EXT       	: /\.(mp4|webm|ogg)(?:\?|\#|$)/ig,
		AUDIO_EXT       	: /\.(ogg|mp3|wav)(?:\?|\#|$)/ig,
		MEDIA_EXT			: /\.(jpg|jpeg|gif|png|svg|webp|mp4|webm|ogg|mp3|wav)(?:\?|\#|$)/ig,
		SUPER_FUNCTION 		: /xyz/.test(function(){xyz;}) ? /\.\$super\(/ : /.*/,
		FUNCTION_PARAMS 	: /([^\(]+)(?:\(([^\)]*)\))?/,
		STR_VALUES   		: /((?:[a-z0-9-+_%\/\\]+(?:\(.+\))?)|(?:\d[^\s,]*)|(?:"[^"]+")|(?:'[^']+')|(?:\[.+\])|(?:\(.+\))|(?:\{[^}]+\})|(?:\{\{[^}]+\}\}))(?:$|(?:\,\s*)|(?:\;\s*)|\s)/g,
		CSS_NUMBER 	    	: /((?:^|\s|\()\-?[0-9]+(?:\.[0-9]+(?:e-[0-9]+)?)?(?=\)|\s|$))/g,
		CSS_URL 			: /(?:^|\s)(?!url\(\"?)([^\s]+(?:(?:\/[^)]+)|(?:\.[a-z]+)))(?:\s|$)/g,
		STYLE_KEY_VAL   	: /([a-z-]+)\:([^\:\;\}]+)/gm,
	};

	var COLOR = CONSTS.COLOR = {
		NAMES : {
			"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff",
			"beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2",
			"brown":"#a52a2a","burlywood":"#deb887","cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50",
			"cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff","darkblue":"#00008b","darkcyan":"#008b8b",
			"darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b",
			"darkolivegreen":"#556b2f","darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a",
			"darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1","darkviolet":"#9400d3",
			"deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff","firebrick":"#b22222",
			"floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff","gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700",
			"goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f","honeydew":"#f0fff0","hotpink":"#ff69b4",
			"indianred ":"#cd5c5c","indigo":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c","lavender":"#e6e6fa","lavenderblush":"#fff0f5",
			"lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff",
			"lightgoldenrodyellow":"#fafad2","lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a",
			"lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de","lightyellow":"#ffffe0",
			"lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6","magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa",
			"mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee",
			"mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa",
			"mistyrose":"#ffe4e1","moccasin":"#ffe4b5","navajowhite":"#ffdead","navy":"#000080","oldlace":"#fdf5e6","olive":"#808000",
			"olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6","palegoldenrod":"#eee8aa","palegreen":"#98fb98",
			"paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb",
			"plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080","red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1",
			"saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d",
			"silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f",
			"steelblue":"#4682b4","tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0","violet":"#ee82ee",
			"wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5","yellow":"#ffff00","yellowgreen":"#9acd32"
		}
	};
	
	var STATUS = CONSTS.STATUS = {
		LOADING: 'loading',
		READY  : 'ready',
		ERROR  : 'error',
	};

	CONSTS.MEDIA    = {};	// images/videos/audios
	CONSTS.REQUIRES = {};	// script and css

    // type validation -------------------------------------------------------------------------------------------------
	/**
	 * Validations helpers
	 * @namespace utils.is
	 */

	/**
	 * Check if value is truthy (a none-empty string, 0, an object, ...)
	 * @memberof utils.is
	 * @function is
	 * 
	 * @param {*} v 
	 * 
	 * @returns {boolean}
	 */
	this.is = function (v){
        return !!(v || v === 0 || v === '0');
    };
	/**
	 * Check if value is falsy (an empty string, null, undefinded)
	 * @memberof utils.is
	 * @function not
	 * 
	 * @param {*} v Value
	 */
	this.is.not = function (v){
        return v === null || v === undefined || v === '' || v === false;
    };
	/**
	 * Check if value is valid (eg. defined number, valid date, a string)
	 * @memberof utils.is
	 * @function valid
	 * 
	 * @param {*} v Value
	 */
    this.is.valid = function (v){
        return !(v === null || v === undefined || (typeof v === 'number' && (isNaN(v) || !isFinite(v))) || (v instanceof Date && isNaN(v)));
    };
	/**
	 * Shortcut to call the {@link utils.is.valid} and see if it's false
	 * @memberof utils.is
	 * @function invalid
	 * 
	 * @param {*} v Value
	 */
	this.is.invalid = function (v){
        return !_.is.valid(v);
    };
	/**
	 * Check if value is defined
	 * @memberof utils.is
	 * @function def
	 * 
	 * @param {*} v Value
	 */
	this.is.def = function (v){
        return v !== undefined;
    };
	/**
	 * Check if value is null
	 * @memberof utils.is
	 * @function null
	 * 
	 * @param {*} v Value
	 */
    this.is.null = function (v){
        return v === null;
    };
	/**
	 * Check if value is a string. If "match" is used, either check if the string match a RegExp, or if "match" is in the string.
	 * @memberof utils.is
	 * @function str
	 * 
	 * @example
	 * utils.is.str('John', /^J/);
	 * // true
	 * 
	 * utils.is.str('This is a string', '{{');
	 * // false
	 * 
	 * utils.is.str('This is a string with {{ var }}', '{{');
	 * // true
	 * 
	 * @param {*} 				v 		Value
	 * @param {RegExp|string} 	[match]	RegExp or String
	 */
	this.is.str = function (v, match){
        return typeof(v) === 'string' && (!match || (match instanceof RegExp && !!v.match(match)) || (typeof(match) === 'string' && !!~v.indexOf(match)));
    };
	/**
	 * Check if value is a number
	 * @memberof utils.is
	 * @function nbr
	 * 
	 * @param {*} 		v 			Value
	 * @param {boolean} [isString]	Valid if the number is a string version
	 */
    this.is.nbr = function (v, isString){
		if (isString && typeof(v) === 'string'){
			v = parseFloat(v);
		}
        return typeof(v) === 'number' && isFinite(v) && !isNaN(v);
    };
	/**
	 * Check if value is boolean
	 * @memberof utils.is
	 * @function bool
	 * 
	 * @param {*} v Value
	 */
	this.is.bool = function (v){
        return typeof(v) === 'boolean';
    };
	/**
	 * Check if value is objec. Can also check if it's a plain object (created with curly brackets).
	 * @memberof utils.is
	 * @function obj
	 * 
	 * @param {*} 		v 			Value
	 * @param {boolean} [isPlain] 	Plain object are simple ones, not created by a Class or Function
	 */
	this.is.obj = function (v, isPlain){
        return isPlain ? 
            v !== null && typeof(v) === 'object' && Object.getPrototypeOf(v) == Object.prototype :
            v !== null && typeof(v) === 'object';
    };
	/**
	 * Check if value is an array. Can also check if it's a plain array (not an object that extends an array).
	 * @memberof utils.is
	 * @function arr
	 * 
	 * @param {*} 		v 			Value
	 * @param {boolean} [isStrict] 	Has to be an array, not an object that extends an array
	 */
    this.is.arr = function (v, isStrict){
        return v && (isStrict && typeof(v) === 'object' ? Object.getPrototypeOf(v) == Array.prototype : v instanceof Array);
    };
	/**
	 * Check if value is a list. Needs to have a "length" and "forEach" property
	 * @memberof utils.is
	 * @function list
	 * 
	 * @param {*} v Value	
	 */
	this.is.list = function (v){
		// @info HTMLElement like <form> does have a ".length" propperty, but shouldn't be considered a list
		return !(v instanceof HTMLElement) && !!(
			v instanceof Array ||
			v instanceof HTMLCollection ||
			(v && typeof v === 'object' && v.length !== undefined && v !== $win)
		);
    };
	/**
	 * Check if value is a function
	 * @memberof utils.is
	 * @function fn
	 * 
	 * @param {*} v Value	
	 */
    this.is.fn = function (v){
        return typeof(v) === 'function';
    };
	/**
	 * Check if value is an instance of a class
	 * @memberof utils.is
	 * @function class
	 * 
	 * @param {*} 		v 		Value
	 * @param {boolean} name 	Name of the class contructor
	 */
    this.is.class = function (v, name){
		return v && typeof(v) === 'object' && (v.constructor.name === name || (typeof(name) === 'object' && v instanceof name));
	};
	/**
	 * Check if value is a DOM node. 
	 * @memberof utils.is
	 * @function node
	 * 
	 * @param {*} 		v 		Value
	 * @param {string}  [type] 	Speficy type of node [text, comment, element, Int]
	 */
	this.is.node = function (v, type){
        var is = typeof Node === "object" ? 
            v instanceof Node : 
            v && typeof v === "object" && typeof v.nodeType === "number" && typeof v.nodeName==="string";

        if (is && type){
			if (type === ':visible')			is = (v.nodeType === Node.TEXT_NODE) || (v.nodeType === Node.ELEMENT_NODE);
			else if (type === 'text') 			is = v.nodeType === Node.TEXT_NODE;
            else if (type === 'comment') 		is = v.nodeType === Node.COMMENT_NODE;
            else if (type === 'element') 		is = v.nodeType === Node.ELEMENT_NODE;
			else if (type === 'svg') 			is = v instanceof SVGElement;
            else if (typeof(type) === 'number')	is = v.nodeType === type;
		// could be a query too, or array of nodes
        }else if (type === true){
			is = _.is.els(v, true);
		}

        return is;
    };
	/**
	 * Check if value is a HTMLElement. 
	 * @memberof utils.is
	 * @function el
	 * 
	 * @param {*} 		v 		Value
	 * @param {string}  [tags] 	Specify the tagName(s) or True to include document and window objects
	 */
	this.is.el = function (v, tags){
        var is = typeof HTMLElement === "object" || typeof SVGElement === 'object' ?
            v instanceof HTMLElement || v instanceof SVGElement :
            v && typeof v === "object" && v !== null && v.nodeType === 1 && typeof v.nodeName==="string";

		var root = v === $win || v === $doc || v === $doc.documentElement; // || v === $doc.body;

		if (!is && tags === true){
			is = root;
		}else if (tags === ':query'){
			return is || _.is.els(v);
		}else if (tags === ':root'){
			return root;
		}else if (tags === ':text'){	
			return v.nodeType === v.nodeType === Node.TEXT_NODE;
		}else if (tags === ':input' || tags === ':text-input'){
			var tag      = (v.tagName || '').toLowerCase();
			var editable = v.isContentEditable;
			var type     = v.type;
			var isText 	 = !!(
				(tag === 'input' && !~['checkbox','radio','file','button','color','image','range','submit'].indexOf(type))
				|| tag === 'textarea' 
				|| editable
			);

			if (tags === ':text-input'){
				return isText;
			}else{
				return isText || tag === 'input' || tag === 'textarea' || tag === 'select';
			}
        }else if (is && typeof(tags) === 'string'){
            var tags  = _.toArray(tags);
            var tag   = (v.tagName || '').toLowerCase();
            is = !!~tags.indexOf(tag);
        }

        return !!is;
    };
	/**
	 * Check if value is a List of nodes (including jQuery).
	 * @memberof utils.is
	 * @function els
	 * 
	 * @param {*} v Value
	 */
	this.is.els = function (v, includeTextNode){
		return !!(
			v instanceof NodeList || 
			v instanceof HTMLCollection || 
			($win.jQuery && v instanceof jQuery) || 
			(v instanceof Array && (includeTextNode ? _.is.node(v[0]) : _.is.el(v[0])))
        );
	};
	/**
	 * Check if HTMLElement is an input (or content editable).
	 * @memberof utils.is
	 * @function input
	 * 
	 * @param {*} v Value
	 */
	this.is.input = function (v){
		if (!_.is.el(v)) return false;
		var t = v.tagName.toLowerCase();

		// TODO use HTMLElement.isContentEditable instead of [contenteditable]

		return t === 'input' || t === 'textarea' || t === 'select' || v.isContentEditable; // (v.hasAttribute('contenteditable') && v.getAttribute('contenteditable') !== 'false');
	};
	/**
	 * Check if value is empty. Empty string, array, object without properties, undefined or null.
	 * @memberof utils.is
	 * @function empty
	 * 
	 * @param {*} v Value
	 */
    this.is.empty = function (v){
        if (typeof v === 'string' && v.trim() === ''){
            return true;
        }else if (Array.isArray(v) && !v.length){
            return true;
        }else if (typeof v === 'object'){
            for (var i in v) return false;
            return true;
        }else if (v === undefined || v === null){
            return true;
        }
        return false;
    };
	/**
	 * Check if value is in a list of values.
	 * @memberof utils.is
	 * @function in
	 * 
	 * @param {*} 				v 		Value
	 * @param {string|array}	list	List of values (if a string of values, needs to be seperated by ",")
	 */
    this.is.in = function (v, list){
        v 	 = _.toValue(v);
		list = _.toArray(list, {'parse':true});
		return !!~list.indexOf(v);
    };
	/**
	 * Check if value is an email
	 * @memberof utils.is
	 * @function email
	 * 
	 * @param {*} v Value
	 */
    this.is.email = function (v){
		return typeof(v) == 'string' && !!v.match(RE.EMAIL);
	};
	/**
	 * Check if value is an url
	 * @memberof utils.is
	 * @function url
	 * 
	 * @param {*} v Value
	 */
	this.is.url = function (v){
		return typeof(v) === 'string' && v.indexOf('http') === 0;
	};
	/**
	 * Check if value is an percentage
	 * @memberof utils.is
	 * @function percent
	 * 
	 * @param {*} v Value
	 */
	this.is.percent = function (v){
		return typeof(v) === 'string' && v.match(RE.PERCENT);
	};
	/**
	 * Check if value is an image path, with specific extension (jpg|jpeg|gif|png|svg|webp)
	 * @memberof utils.is
	 * @function img
	 * 
	 * @param {*} v Value
	 */
	this.is.img = function (v){
		return typeof(v) === 'string' && !!v.match(RE.IMAGE_EXT);
	};
	/**
	 * Check if value is a Base64 encoded string
	 * @memberof utils.is
	 * @function encoded
	 * 
	 * @param {*} v Value
	 */
	this.is.encoded = function (v){
		if (
			typeof v !== 'string' ||
			v === '' ||
			v.trim() === ''
		) return false;

        try {
            return btoa(atob(v)) == v;
        } catch (err) {
            return false;
        }
	};
	/**
	 * Check if value is a Hex code color
	 * @memberof utils.is
	 * @function hex
	 * 
	 * @param {*} v Value
	 */
    this.is.hex = function (v){
		return typeof(v) === 'string' && RE.COLOR_HEX.test(v);
	};
	/**
	 * Check if value is a RGB code color
	 * @memberof utils.is
	 * @function rgb
	 * 
	 * @param {*} v Value
	 */
	this.is.rgb = function (v){
		return typeof(v) === 'string' && RE.COLOR_RGB.test(v); 
	};
	/**
	 * Check if value is a HSL code color
	 * @memberof utils.is
	 * @function hsl
	 * 
	 * @param {*} v Value
	 */
	this.is.hsl = function (v){
		return typeof(v) === 'string' && RE.COLOR_HSL.test(v); 
	};
	/**
	 * Check if value is a Color (hex, rgb, hsl, or a valid color name)
	 * @memberof utils.is
	 * @function color
	 * 
	 * @param {*} v Value
	 */
	this.is.color = function (v){
		return typeof(v) === 'string' && (
            v.toLowerCase() in COLOR.NAMES || 
            _.is.hex(v) || 
            _.is.rgb(v) || 
            _.is.hsl(v)
        );
    };
	/**
	 * Check if value against a couple of validations
	 * @memberof utils.is
	 * @function either
	 * 
	 * @example
	 * utils.is.either('This is a string', 'nbr,str');
	 * // true
	 * 
	 * utils.is.either('This is a string', 'email,obj');
	 * // false
	 * 
	 * @param {*} 				v 		Value
	 * @param {array|string}	types	Validation function to check
	 */
	this.is.either = function (v, types){
		if (!_.is(v)) return false;
		
		types = _.toArray(types);

		var i=0, l=types.length, t;
		for (;i<l;++i){
			t = types[i];
			if (t in _.is && _.is[t](v)){
				return true;
			}
		}

		return false;
	};
	/**
	 * Check if the current browser is Internet Explorer
	 * @memberof utils.is
	 * @function ie
	 */
	this.is.ie = function (){
		return !!$doc.documentMode; //!!$win.MSInputMethodContext && !!document.documentMode;
	};
	/**
	 * Check if an item match a searched value.
	 * 
	 * @todo add all the other "like" I made in the php version
	 * 
	 * @memberof utils.is
	 * @function like
	 * 
	 * @example
	 * utils.is.like('This is a string', 'a');
	 * // false
	 * 
	 * utils.is.like('This is a string', function (v){ return typeof v === 'string'; });
	 * // true
	 * 
	 * utils.is.like('aAa', 'aaa');
	 * // false
	 * 
	 * utils.is.like('aAa', 'aaa', {'case':false});
	 * // true
	 * 
	 * utils.is.like([1, 2], [1, 2]);
	 * // true
	 * 
	 * utils.is.like([1, 2, 3], [1, 2]);
	 * // true
	 * 
	 * utils.is.like([1, 2], [1, 2, 3]);
	 * // false
	 * 
	 * @param {*} item 				Source item
	 * @param {*} search 			Value to compare the source item too
	 * @param {*} [args] 
	 * @param {*} args.case=true	If it's string, check the case (sensitive or insensisitve)
	 * @param {*} args.loose=true	Loosly compare Object/Array, they don't need to be the same reference
	 * @param {*} args.deep=true	If it's Array/Object, go deeper in them
	 * @param {*} args.params		If search is a function, pass those parameters to it
	 * @param {*} args.props		Compare the search value to specific properties		
	 * @param {*} args.contains		If search is a node, check if it's contained in the main item OR one of it's properties
	 * @param {*} args.ctx			If search is a function, use this context
	 */
	this.is.like = function (item, search, args){
		args          = args || {};
		args.case     = 'case' in args ? args.case : true;
		args.loose    = 'loose' in args ? args.loose : true;
		args.deep     = 'deep' in args ? args.deep : true;           // go deeper and deeper in arrays/objects
		args.params   = 'params' in args ? args.params : {};
		args.props    = 'props' in args ? args.props : false;
		args.closest  = 'closest' in args ? args.closest : false;
		args.alias    = 'alias' in args ? args.alias : false;
		args.ctx      = args.ctx || null;

		var iType 		= typeof(item);
		var sType 		= typeof(search);
		var areStrings  = iType === 'string' && iType === sType;
		var areObjects 	= _.is.obj(item, true) && _.is.obj(search, true);
		var areArrays 	= _.is.arr(item, true) && _.is.arr(search, true);
		var props 		= args.props ? (args.props instanceof Array ? args.props : _.$arr(args.props)) : false;	// check specific properties
		var closest 	= args.closest && _.is.node(search, true) ? _.toAlias(args.closest, args.alias) : false;

		if (closest){
			closest = _.dom.closest(search, closest);
		}
				
		function _match (a, b, depth){
			depth = depth === undefined ? 0 : depth;

			// one children is missing/null
			if (a === null || b === null) return false;

			var i;
			for (i in b){
				if (!b.hasOwnProperty(i)) 	continue;
				if (!_is(a, b, i)) 			return false;
			}

			return true;
		}

		function _is (a, b, i){
			var aValue  = a[i];
			var bValue  = b[i];
			var isObject= _.is.obj(aValue, true) && args.loose;
			var isArray = _.is.arr(aValue, true) && args.loose;

			if (
				((isArray || isObject) && !_match(aValue, bValue)) ||
				(!isObject && !isArray && aValue !== bValue)
			){
				return false;
			}

			return true;
		}
		
		function _matchNode (v){			
			if (!closest || !_.is.node(v, true)) return false;
			var nodes = _.$arr(v);
			return !!~nodes.indexOf(closest);
		}
		
		function _matchProps (v){
			if (!props) return false;
			for (var i in props){
				var p = props[i];
				if (
					v[p] === search ||
					_matchNode(v[p])
				){
					return true;
				}
			}
			return false;
		}

		if (
			item === search ||
			(areStrings && !args.case && item.toLowerCase() === search.toLowerCase()) ||					// match String
			(iType === 'object' && _matchNode(item)) || 													// match the node, if it's an array of nodes, check if it's in
			(iType === 'object' && _matchProps(item)) ||													// match specific propeties
            (iType === 'string' && search instanceof RegExp && item.match(search)) ||						// match RegExp
			(sType === 'function' && search.apply(args.ctx || item, [item, args.params]) === true) ||		// match callback function
			(args.loose && (areObjects || areArrays) && _match(item, search))								// match array/object
		){
			return true
		}

		return false;
	};
	/**
	 * Check if the the object has one or all the keys in it.
	 * @memberof utils.is
	 * @function has
	 * 
	 * @example 
	 * 
	 * utils.has({'name':'John'}, 'name');
	 * // true
	 * 
	 * utils.has({'name':'John'}, 'age');
	 * // false
	 * 
	 * utils.has({'name':'John'}, 'name,age');
	 * // true
	 * 
	 * utils.has({'name':'John'}, 'name,age', true);
	 * // false
	 * 
	 * utils.has({'name':'John', 'age':60, 'sex':'male'}, 'name,age', true);
	 * // true
	 * 
	 * @param {*} 			obj 	Object to use
	 * @param {string[]} 	keys 	Array or keys to check if they exists	
	 * @param {boolean} 	[all]	All keys need to be found or not 
	 * @returns {boolean}
	 */
    this.has = function (obj, keys, all){
		if (!_.is.obj(obj)){
			return;
		}

		keys = _.toArray(keys);
		
		var i=0, l=keys.length, k;
		for (;i<l;++i){
			k = keys[i];

			if (all && !(k in obj)){
				return false;
			}else if (!all && (k in obj)){
				return true;
			}
		}

		return all ? true : false;
	};
	/**
	 * Check if an object equals another one by checking all it's values (going deep)
	 * @memberof utils.is
	 * @function equal
	 * 
	 * @example 
	 * var obj1 = {'name':'Joe', 'age':45};
     * var obj2 = {'name':'Joe', 'age':45};
     * utils.equal(obj1, obj2);
	 * // true
	 * 
	 * var obj1 = {'name':'Joe', 'age':45};
     * var obj2 = {'name':'Joe', 'age':45, 'sex':'male'};
     * utils.equal(obj1, obj2);
	 * // false
	 * 
	 * @param {*} a Object to compare
	 * @param {*} b Object to compare against "a"
	 */
	this.equal = function (a, b){
		if (a === b) 				  return true;
		if (a === null || b === null) return false;

		var aType = Object.prototype.toString.call(a);
		var bType = Object.prototype.toString.call(b);

		if (aType !== bType) return false;

		if (b instanceof Array){
			if (a.length !== b.length){
				return false;
			}
			for (var i=0, l=b.length; i<l; ++i){
				if (!_.equal(a[i], b[i])) return false;
			}
		}else if (typeof b === 'object' && _.is.obj(b, true)){
			// not the same length
			var aCount = 0;
			var bCount = 0;
			var i;
			for (i in a){
				if (!a.hasOwnProperty(i)) continue;
				aCount++;
			}
			for (i in b){
				if (!b.hasOwnProperty(i)) continue;
				if (!_.equal(a[i], b[i])) return false;
				bCount++;
			}
			if (aCount !== bCount){
				return false;
			}
		}else if (a !== b){
			return false;
		}

		return true;
	};

    // getter/setter/calls ---------------------------------------------------------------------------------------------
    function _resolve (obj, path, args){
        // fix the path to a simpler version
        if (_.is.str(path) && ~path.indexOf('[')){
			path = path
				.replace('[]', '@')
				.replace(/\]/g, '')
				.replace(/\[/g, '.')
				.replace('@', '[]');
		}
		
		// fix the "[]" to transform a item into an array

		// TODO Add "path" as a function, to create new object...

        if (!path || !obj){
			return;
		}

        if (_.is.str(path)){
            path = path.split('.');
        }else{
            path = _.is.arr(path) ? path : [path];
        }

		var isSet = _.is.obj(args) && ('value' in args);
				
        args       = args || {};
        args.value = 'value' in args ? args.value : undefined;
        args.ctx   = 'ctx' in args ? args.ctx : null;           // used for functions

        var i=0, l=path.length, item = obj, isLast, p, v, isArr;
		for (;i<l; ++i){
			p      = path[i];
            isLast = i === l-1;
			isArr  = !!p.match(/\[\]$/);
			p	   = p.replace('[]', '');	// remove the '[]' at the end
			v      = _.is.fn(p) ? p(item) : item[p];

			if (_.is.str(p, '(')){
				v = _.toAction(p, true, item);
			}

            if (isLast && isSet && isArr){
				if (!(p in item) && isArr){
					item[p] = [];	
				}

				if (args.value !== undefined){
					item[p].push(args.value);
				}
			}else if (isLast && isSet){
				item[p] = args.value;
            }else if (isLast){
                return v;
            }else if (isSet){
				item[p] = _.is.either(item[p], 'obj,arr') ? item[p] : (isArr || _.is.nbr(path[i + 1], true) ? [] : {});
                item    = item[p];
            }else{
                item = v;

				if (v === undefined){
					break;
				}
            }
		}
		
        if (isSet){
            return obj;
        }else{
            return undefined;
        }
    };

	/**
	 * Go through an object and set a value, event if the path doesn't fully exists
	 * @alias utils.set
	 * 
	 * @example
	 * var obj = {'name':'Joe'};
	 * utils.set(obj, 'info.age', 40);
	 * // {'name':'Joe', {'age':40}};
	 * 
	 * @param {*} 				obj 	Item used to parse through and set a value
	 * @param {string|array} 	path 	Path to go through
	 * @param {*} 				value 	Value that will be set at the end
	 * 
	 * @return {*} The object being updated
	 */
    this.set = function (obj, path, value){
        return _resolve(obj, path, {
            'value' : value,
        });
    };

	/**
	 * Go through an object and tries to get a value deep in. Optionally, the path can have multiple option, until one path is defined.
	 * @alias utils.get
	 * 
	 * @example
	 * var obj = {'name':'Joe'};
	 * utils.get(obj, 'info.age || name');
	 * // "Joe"
	 * 
	 * @param {*} obj 		Object to parse through
	 * @param {*} paths 	List of possible path to parse through
	 * @param {*} fallback 	Value to return if the path doesn't exists
	 * 
	 * @returns {*} The found value or the fallback
	 */
    this.get = function (obj, paths, fallback){
		if (_.is.obj(obj) && paths in obj){
			return obj[paths];
		}

        paths = _.is.arr(paths) ? [paths] : _.toArray(paths, '||');

        var i=0, l=paths.length, v;
        for (;i<l;++i){
			v = _resolve(obj, paths[i]);
            if (_.is.def(v)){
                return v;
            }
        }

        return fallback;
    };

	/**
	 * Get the current date in INT form
	 * @alias utils.now
	 * 
	 * @returns {number}
	 */
    this.now = function (){
		return +new Date();
	};

	/**
	 * Apply functions (if valid) to an object.
	 * @alias utils.apply
	 * 
	 * @example 
	 * var ctx  = {'city':'Montreal', 'season':'winter'};
	 * var item = {'name':'John', 'age':40};
	 * 
	 * utils.apply(function (v){ return v.name; }, [item]);
	 * // 'John'
	 * utils.apply(function (v){ }, [item], 'oups');
	 * // 'oups'
	 * utils.apply(function (){ return this.city; }, null, {'ctx':ctx});
	 * // 'Montreal'
	 * 
	 * @param {function} 	callbacks 		1 or more functions to call
	 * @param {array} 		[params] 		List of parameters passed in the function
	 * @param {object} 		[args] 			Fallback value if there's no response from the callback
	 * @param {*}			args.ctx		Context to use on the callbacks
	 * @param {*}			args.fallback	Fallback value if nothing is returned by the callbacks. Default to the first params.
	 * 
	 * @returns {*} 		Return a value if the callback returns one, or the first parameter
	 */
	this.apply = function (callbacks, params, args, ctx){
        callbacks = _.is.arr(callbacks) ? callbacks : [callbacks];
        params    = _.is.arr(params) ? params : [params];

		if (_.is.valid(args) && !_.is.obj(args)){
			args = {'fallback':args};
		}

        args          = args || {};
        args.ctx      = 'ctx' in args ? args.ctx : ctx;
        args.fallback = 'fallback' in args ? args.fallback : params[0];

        var value = args.fallback;

        var i=0, l=callbacks.length, v, r;
        for (;i<l;++i){
            v = callbacks[i];
			v = _.is.str(v) && args.ctx ? args.ctx[v] : v;
            if (!_.is.fn(v)) continue;

            r = v.apply(args.ctx, params);
            if (_.is.def(r)){
                value = params[0] = r;
            }
        }

        return value;
	};

	this.call = function (callbacks, params){
		return _.apply(callbacks, params, {'fallback':null});
	};

	this.call.ctx = function (ctx, callbacks, params){
		return _.apply(callbacks, params, {'fallback':null}, ctx);
	};

	/**
	 * Shortcut to the {@link utils.apply} function, with the added context at the start.
	 * @alias utils.apply․ctx
	 * 
	 * @example 
	 * var ctx  = {'city':'Montreal', 'season':'winter'};
	 * 
	 * utils.apply.ctx(ctx, function (){ return this.city; });
	 * // 'Montreal'
	 * 
	 * @param {object} 		ctx 
	 * @param {function[]} 	callbacks 	Either 1 or an array of functions
	 * @param {array} 		params		List of parameters to pass to the functions
	 * @param {object}		[args]		See {@link utils.apply} args param
	 */
	this.apply.ctx = function (ctx, callbacks, params, args){
		return _.apply(callbacks, params, args, ctx);
	};

	/**
	 * Cache simple or complex values (with array of value) in an object
	 * @alias utils.cache
	 * 
	 * @example
	 * var obj = {'name':'Joe'};
	 * utils.cache(obj, 'style', 'vertical');
	 * utils.cache(obj, ['up', true], 'yes');
	 * 
	 * @param {*} obj 		Object that will keep the cache
	 * @param {*} key 		Key (or array symbol) that holds the value
	 * @param {*} value 	Value to set in the cache
	 * @param {*} expando 	Sub-object that holds all the cached value. Set to False if you prefer to be on the object.
	 * 
	 * @returns {*} Return the data if setting values, return the value if trying to get one.
	 */
	this.cache = function (obj, key, value, expando){
        if (!_.is.obj(obj)) return null;
		
		expando = expando === undefined ? FFTO.EXPANDO : expando;

		var set  = _.toSet(key, value);
		var data = (expando !== undefined ? obj[expando] || (obj[expando] = {}) : obj) || {};
		
		// symbols complex ID
		if (Array.isArray(key)){
			var symbols = data['__SYMBOLS__'] || (data['__SYMBOLS__'] = []);
			var index   = null;
			var next 	= null;
			var i=0, l=symbols.length, keys, ii, ll;

			loop_items : for (;i<l;++i){
				keys = symbols[i];
				ii   = 0;
				ll   = key.length;

				if (keys === null){
					// re-use an old Symbol entry
					if (next === null) next = i;
					continue;
				}
				
				if (keys.length !== key.length) continue;

				loop_keys: for (;ii<ll;++ii){
					if (keys[ii] !== key[ii]){
						continue loop_items;
					}
				}

				index = i;
				break;
			}

			if (index === null){
				index = next === null ? symbols.length : next;
			}

			if (_.is.def(value)){
				if (value === null){
					symbols[index] = null;
				}else{
					symbols[index] = key;
				}

				set 	 = {};
				key 	 = 'Symbol(' + index + ')';
				set[key] = value;
			}else{
				set = null;
				key = 'Symbol(' + index + ')';
			}
		}
		
		if (set){
			_.extend(data, set);
			return data;
        }else if (key !== undefined){
			return data[key];
        }else{
            return data;
        }
	};
    
	/**
	 * Return a random value: number, boolean, date, color, string
	 * @alias utils.random
	 * 
	 * @example
	 * utils.random('color');
	 * // "#B52E41"
	 * 
	 * utils.random('date');
	 * // Thu Jun 01 2023 14:04:06 GMT-0400 (Eastern Daylight Time)
	 * 
	 * utils.random(100);
	 * // 23.809175342978772
	 * 
	 * utils.random('ratio');
	 * // 0.6736503788913897
	 * 
	 * utils.random('boolean');
	 * // true
	 * 
	 * utils.random([1,2,300,22]);
	 * // 300
	 * 
	 * utils.random('type_');
	 * // "type_e5a6b4"
	 * 
	 * utils.random();
	 * // "6d1000"
	 * 
	 * @param {*} type Type of random values to return. If it's a string and not a type, it will be a prefix
	 * 
	 * @returns {*}
	 */
	this.random = function (type, a, b, c){
		if (type === 'color'){
			var r = Math.floor(Math.random() * 255).toString(16);
			var g = Math.floor(Math.random() * 255).toString(16);
			var b = Math.floor(Math.random() * 255).toString(16);
			r = (r.length == 1 ? '0' : '') + r;
			g = (g.length == 1 ? '0' : '') + g;
			b = (b.length == 1 ? '0' : '') + b;
			return '#'+[r,g,b].join('').toUpperCase();
		}else if (type === 'date' || type instanceof Date){
			var d  = type instanceof Date ? new Date(+type) : new Date();
			var dd = Math.random() * 356 | 0;
			d.setDate(d.getDate() + dd);
			return d;
		}else if (type instanceof Array){
			var i = Math.round(Math.random() * (type.length-1));
			return type[i];
		}else if (type === 'number' || _.is.nbr(type)){
			var min = 0;
			var max = 1000;

			if (_.is.nbr(type)){
				c = b;
				b = a;
				a = type;	
			}

			if (_.is.nbr(b)){
				min = a;
				max = b;
			}else if (_.is.nbr(a)){
				max = a;
			}

			var a = Math.random() * (max - min) + min;
			if (b === true || c === true){
				a = Math.round(a);
			}

			return a;
		}else if (type === 'ratio'){
			return Math.random() * 1;
		}else if (type === 'boolean' || type === 'bool'){
			return [true, false][Math.round((Math.random() * 1))];
		}else{
			var v = Math.floor(Math.random() * 0xFFFFFF).toString(16); 
			return _.is.str(type) ? type + v : v;
		}
	};

	/**
	 * Calculate a string formula. A number of units can be passed there. If the extra units
	 * have a "!" at the end, the number is fully multiplicated with the unit value. If not, it's a fraction of it.
	 * @alias utils.calculate
	 * 
	 * @example
	 * utils.calculate('(5 + 6) * 50%')
	 * // 5.5
	 * 
	 * utils.calculate('(5 + 6) * 50thousand', {'thousand':1000})
	 * // 5500
	 * 
	 * utils.calculate('(5 + 6) * 5x', {'x':100});
	 * // 55
	 * 
	 * utils.calculate('(5 + 6) * 5x', {'x!':100});
	 * // 5500
	 * 
	 * utils.calculate('(5 + 6) * 3x !floor', {'x':10});
	 * // 3
	 * 
	 * utils.calculate('(5 + 6) * 12%', null, {'decimals':2});
	 * // 1.32
	 * 
	 * @param {*} nbr 
	 * @param {*} [units] 			Units that will be parsed (as suffix to numbers). Use a "!" at the end to be a full number instead of a fraction
	 * @param {*} [args]  
	 * @param {*} args.offset 		Add an offset value
	 * @param {*} args.decimals 	Only keep a specific decimal count
	 * 
	 * @returns {number}
	 */
	this.calculate = function (nbr, units, args){
		if (typeof units === 'number'){
			units = {'%':units};
		}
		if (typeof args === 'number'){
			args = {'offset':args};
		}

		units         = units || {};
		args          = args || {};
		args.offset   = 'offset' in args ? args.offset : 0;
		args.decimals = 'decimals' in args ? args.decimals : true;

		if (units['%'] === undefined){
			units['%'] = 1;
		}

		var isFloor = false;
		var isRound = false;
		var isCeil  = false;
		var isHalf 	= false;

		if (typeof nbr === 'string'){
			isFloor = !!~nbr.indexOf('!floor');
			isRound = !!~nbr.indexOf('!round');
			isCeil  = !!~nbr.indexOf('!ceil');			
			isHalf  = !!~nbr.indexOf('!half');	// add half a pixel
		}

		if (nbr === undefined || nbr === null){
			nbr = 0;
		}else if (!isNaN(nbr)){
			nbr = parseFloat(nbr);
		}else if (nbr === '?' || nbr === 'random'){
			nbr = Math.random() * units['%'];
		}else if (_.is.percent(nbr)){
			nbr = parseFloat(nbr) / 100 * units['%'];
		}else if (_.is.str(nbr)){
			// random numbers (the previous ifs are shortcuts when the string is simpler, makes things faster)
			nbr = nbr.replace(/\?/g, function (){ return Math.random() * units['%']; });

			nbr = nbr.replace(RE.NUMBER_WITH_UNIT, function (m, $1, $2){
				var n = parseFloat($1);
				var u1= $2;
				var u2= $2 + '!';

				if (u1 in units){
					n = (n / 100) * units[u1]; 
				}else if (u2 in units){
					n = n * units[u2]; 
				}else{
					n = m;
				}

				return n;
			});
		}

		if (_.is.str(nbr)){
			nbr = nbr.replace(RE.NOT_NUMBER, '');
			try{ nbr = eval(nbr); }catch (e){}
		}
		
		nbr = (nbr || 0);
		nbr += args.offset;

		if (args.decimals == false){
			nbr = Math.floor(nbr);
		}else if (_.is.nbr(args.decimals)){
			nbr = parseFloat(nbr.toFixed(args.decimals));
		}

		if (isFloor) nbr = ~~nbr;
		if (isRound) nbr = Math.round(nbr);
		if (isCeil)  nbr = Math.ceil(nbr);
		if (isHalf)	 nbr = ~~nbr + 0.5; 	// half decimals, good to graphic when we need half a pixel
		
		return nbr;
	};

	this.match = function (str, re, args, callback){
		if (_.is.fn(args)){
			args = {'callback':args};
		}else if (_.is.bool(args)){
			args = {'single':args};
		}

		// [ ] convert a re string to a RegExp object

		args        = args || {};
		args.callback = args.callback || callback;
		// args.single = 

		var max = 1000;
		var i   = 0;
		var l   = 0;
		var v;

		var groups = [];
		var match  = null;

		if (re.global){
			while ((match = re.exec(str)) !== null && max > 0){
				v = match;

				if (args.callback){
					v = args.callback.call(null, (v.groups ? v.groups : v),  match);
				}else if (v.groups){
					v = v.groups;
				}else{
					v = [];
					for (i=1, l=match.length; i<l; ++i){
						v.push(match[i]);
					}
				}
				groups.push(v);
				max--;
			}
		}else if (match = str.match(re)){
			if (match.groups && args.callback){
				groups = args.callback.call(null, match.groups);
			}else if (match.groups){
				groups = match.groups;
			}else{
				for (i=1, l=match.length; i<l; ++i){
					v = match[i];

					if (args.callback){
						v = args.callback.call(null, v, i-1);
					}

					groups.push(v);
				}
			}
		}
	
		return groups;	
	}

	// theme -----------------------------------------------------------------------------------------------------------
	this.theme = function (key, fallback){
		return _.get(window.theme_settings, key, fallback);
	};

	this.isDebug = window.isDebug = function (){
		return _.theme('is_debug');
	};

    // lists -----------------------------------------------------------------------------------------------------------
	/**
	 * Transform a list into an array, calls a callback on each item (if specified) and return the array.
	 * This is a private function used internally. It's faster than {@link utils.each}, but has less options.
	 * @alias utils.$arr
	 * 
	 * @param {*} 		list
	 * @param {*} 		[args]
	 * @param {string}	args.separator=','
	 * @param {boolean}	args.trim			Trim the values if the list is at first a string
	 * @param {boolean}	args.force			Force it to be an array
	 * @param {*}		args.ctx
	 * 
	 * @return {array}
	 */
	this.$arr = this._each = function (list, args, callback, copy){
		if (!list && list !== 0){
            return [];
        }
		if (typeof(args)==='string'){
			args = {'separator':args};
		}else if (typeof(args)==='function'){
			copy     = callback;
			callback = args;
			args     = {};
		}else if (args === true){
			args = {'trim':true};
		}

		args           = args || {};
		args.separator = 'separator' in args ? args.separator : ',';
		args.safe      = args.safe || false;
		args.trim      = args.trim || false;
		args.force 	   = args.force || false;
		args.ctx	   = args.ctx || null;
		
		callback = typeof(callback) === 'function' ? callback : null;
		copy     = copy === undefined ? true : copy;
		
		var i, l, v, arr = [], keys = null;
        if (_.is.arr(list, true)){
			arr = list;
		}else if (_.is.obj(list) && args.force){
			keys = [];
			for (i in list){ 
				if (!list.hasOwnProperty(i)) continue;
				keys.push(i);
				arr.push(list[i]); 
			}
        }else if (_.is.str(list)){
			var texts = [];
			
			// match all the groups of (), [], {}, "" or '' and skip those
			if (args.safe){
				list = list.replace(/(?:\(.+?\))|(?:\[.+?\])|(?:\{.+?\})|(?:\".+?\")|(?:\'.+?\')/g, function (m, n){
					texts.push(m);
					return FFTO.KEY;
				});
			}
            
			arr = list.trim().split(args.separator);
			arr = args.trim ? arr.map(function (v){ return v.trim(); }) : arr;

			if (args.safe){
				for (i=0,l=arr.length;i<l;++i){
					arr[i] = arr[i].replace(FFTO.KEY, function (){
						return texts.shift();
					});
				}
			}
        }else if (_.is.obj(list, true)){
			keys = [];
			for (i in list){ 
				keys.push(i);
				arr.push(list[i]); 
			}
        }else if (_.is.list(list)){
            for (i=0,l=list.length;i<l;++i){ arr.push(list[i]); };
        }else if (list !== undefined){
            arr = [list];
        }

		arr = copy ? arr.slice() : arr;

		if (callback) for (i=0,l=arr.length;i<l;++i){
			v      = callback ? callback.call(args.ctx, arr[i], keys ? keys[i] : i) : arr[i];
			arr[i] = v === undefined ? arr[i] : v;
			if (v === FFTO.BREAK) 			break;
			else if (v === FFTO.CONTINUE)	continue;
		}

		return arr;
	};

    /**
	 * Goes through multiple types of object (string, number, object, array) and either return the parsed object.
	 * @alias utils.each
	 * 
	 * @example
	 * utils.each({'name':'Joe', 'age':45});
	 * // {'name':'Joe', 'age':45}
	 * 
	 * utils.each(5);
	 * // [1, 2, 3, 4, 5]
	 * 
	 * utils.each('bob, 45, true', {'parse':true});
	 * // ['bob', 45, true]
	 * 
	 * utils.each([1,2,3,4], {'reverse':true});
	 * // [4, 3, 2, 1]
	 * 
	 * utils.each([1,2,3,4], function (v, i){ return {'$id' : 'Step' + i, '$value': v + 100}; });
	 * // {Step0: 101, Step1: 102, Step2: 103, Step3: 104}
	 * 
	 * @param {*} 		list 				Object to go through
	 * @param {*} 		[args] 				List of options
	 * @param {*} 		args.ctx 			Specific context to use when the callback is called
	 * @param {string} 	args.type 			Forces type to return [object, array]
	 * @param {boolean} args.filter 		Return defined value only
	 * @param {boolean} args.separator="," 	If the object is a string, use this separator to split it 
	 * @param {boolean} args.trim=true 		Trim all the values when the Object is a string of values
	 * @param {boolean} args.reverse	 	The callback goes through the items in reverse
	 * @param {string} 	args.order 			Goes through the item in a different order [random, ?]
	 * @param {boolean} args.update 		Update the original object passed when the callback returns a value
	 * @param {*} 		[callback] 			Function to call on each item. Can return a value, OR both the index and value (with $id and $value properties)
	 * 
	 * @return {object|array}
	 */
	this.each = function (list, callback, args){
		// switch callback/args
		if (_.is.fn(args)){
            callback = [args, args = callback][0];
		}

		if (_.is.bool(args)){
			args = {'filter':args};
        }else if (_.is.str(args)){
			args = {'separator':args};
		}

        args           = args || {};
        args.ctx       = 'ctx' in args ? args.ctx : list;
        args.type      = args.type || false;
        args.filter    = 'filter' in args ? args.filter : false;
        args.separator = 'separator' in args ? args.separator : ',';
        args.trim      = 'trim' in args ? args.trim : true;
		args.parse 	   = args.parse || false;
		args.reverse   = args.reverse || false;
        args.order     = args.order || null;
        args.update    = args.update || false;
		args.reduce	   = args.reduce || false;
		args.all 	   = args.all || false;

		// TODO add unique

        var keys = [], length = 0, type = null;
        if (list === null){
            list = [];
            type = 'null';
        }else if (_.is.nbr(list)){
            keys   = null;
            length = list;
            type   = 'number';
        }else if (_.is.str(list)){
            keys   = null;
            list   = list.trim().split(args.separator);

			if (args.trim || args.parse){
				list = list.map(function (v){
					v = args.trim ? v.trim(v) : v;
					v = args.parse ? _.toValue(v) : v;
					return v;
				});
			}
            
            type   = 'string';
            length = list.length;
        }else if (_.is.list(list)){
            keys 	= null;
            length 	= list.length;
            type 	= 'array';
        }else{
            var keys = [], i;
            for (i in list){
                if (!args.all && !list.hasOwnProperty(i)) continue;
                keys.push(i);
            }
            length  = keys.length;
            type 	= 'object';
        }

        type = args.type || type;

		if (args.order === 'random' || args.order === '?'){
			if (!keys){
                keys = [];
                for (var i=0, l=length; i<l; ++i){ keys.push(i); }
			}
			keys = _.arr.shuffle(keys);
		}

        function _get (index){
            index = args.reverse ? length - index - 1 : index;

            var key   = keys ? keys[index] : index;
            var value = type === 'number' ? index+1 : list[key];
        
            return {
                'index' : index,
                'value'	: value,
                'key'	: key,
            }
        };


		// String to return
		if (_.is.str(callback)){
			var old = callback;
			if (old === '$id'){
				type = 'array';
			}

			callback = function (v, i){
				if (old === '$id'){
					return i;
				}
			};

			// TODO, rewrite this properly
		}

        var items = type === 'object' ? {} : [];
        var last  = null;
        var i, l, a, item, response, previous, next;
        for (i=0, l=length; i<l; ++i){
            item     = _get(i);
            response = undefined;

            if (_.is.fn(callback)){
                previous = _get(i - 1);
                next     = _get(i + 1);

                a 	 	      = args.args || {};
                a.index       = i;
                a.isFirst 	  = i === 0;
                a.isLast 	  = i === (length-1);
                a.isBetween   = (!a.isFirst && !a.isLast);
                // a.ratio 	  = (i + 1) / length;
                a.ratio 	  = i / (length-1);
                a.key 	      = item.key;
                a.length      = length;
                a.type        = type;
                a.previousKey = previous.key;
                a.nextKey     = next.key;
                a.previous    = previous.value;
                a.next 	      = next.value;
                a.last  	  = last;

                response = callback.apply(args.ctx || item.value, [item.value, item.key, a]);
            }else{
                response = item.value;
            }

            if (response === FFTO.CONTINUE){
				continue;
			}else if (response === FFTO.BREAK){
				break;
			}else if (response !== undefined && args.update){
				list[item.key] = response;
			}

            last = response;

            if (response !== undefined || !args.filter){
                response = response === undefined ? item.value : response;

				var key   = item.key;
				var value = last = response;
				if (_.is.obj(response) && response.$id){
					if (items instanceof Array){
						type  = 'object';
						items = {};
					}

					key   = response['$id'];
					value = last = response['$value'] ? response['$value'] : response;
				}

				if (args.reduce){
					if (!(items instanceof Array)){
						type  = 'array';
						items = [];
					}
					value = _.is.arr(value, true) ? value : [value];
					items = items.concat(value);
				}else if (type === 'object'){
					items[key] = value;
				}else if (_.is(value) || !args.filter){
					items.push(value);
				}

				/*
                if (utils.is.obj(response) && response.$id){
                    // convert to object if it's not already set
                    if (items instanceof Array){
						type  = 'object';
						items = {};
					}

                    var id 	  = response['$id'];
                    var value = last = response['$value'] ? response['$value'] : response;

                    delete(response['$id']);
                    delete(response['$value']);

                    items[id] = value;
                }else if (type === 'object'){
                    items[item.key] = last = response;
                }else if (utils.is(response) || !args.filter){
                    last = response;
                    items.push(response);
                }
				*/
            }
        }

        return items;
    };

	/**
	 * Shortcut to {@link utils.each} by setting the Context first
	 * @alias utils.each․ctx
	 * 
	 * @param {object} 	ctx 		Context to use
	 * @param {array}	[params]	Parameters to pass to utils.each
	 * 
	 * @return {object|array}
	 */
	this.each.ctx = function (ctx, params){
		params = params || [];

		var list     = params[0];
		var args     = params[1];
		var callback = params[2];

		if (_.is.fn(args)){
			callback = args;
			args 	 = {};
		}
		
		args     = args || {};
		args.ctx = args.ctx || ctx;

		return _.each(list, args, callback);
	};

	/**
	 * Shortcut to filter through all the items of a list and remove the undefined value. Always return an array, unless the 
	 * callback return an object with "$id" parameter
	 * @alias utils.each․filter
	 * 
	 * @example
	 * utils.each.filter([1,2,3,4,,,,,8]);
	 * // [1, 2, 3, 4, 8]
	 * 
	 * utils.each.filter({'name':'Joe', 'age':45})
	 * // ['Joe', 45]
	 * 
	 * @param {*} list 
	 * @param {*} [callback] Function to use on every items
	 * 
	 * @returns {array}
	 */
    this.each.arr = this.each.filter = function (list, callback){
		return _.each(list, {'type':'array', 'filter':true}, callback);
	};

	/**
	 * Extend an object/array with all the next arguments passed. If the first argument is TRUE, then the merge of all subsequent object
	 * goes deep.
	 * @alias utils.extend
	 * 
	 * @example
	 * var obj = {'name':'Joe', 'age':45};
	 * utils.extend(obj, {'sex':'male', 'color':'blue'});
	 * // {name: 'Joe', age: 45, sex: 'male', color: 'blue'}
	 * 
	 * var obj1 = {'childs':[1,2,10]};
	 * var obj2 = {'childs':['a','b']};
	 * utils.extend(obj1, obj2); 
	 * // {'childs':['a','b']};
	 * 
	 * utils.extend(true, obj1, obj2); 
	 * {'childs':['a','b',10]};
	 * 
	 * @returns {object}
	 */
	this.extend = function (){
		var copies = [];
		var clones = [];
		var isDebug= arguments[0] === FFTO.DEBUG;

		function _walk (){
			var target = arguments[0];

			if (target === undefined || target === null){
				return target;
			}

			var isDeep   = false;
			var i		 = 1;
			var length   = arguments.length;

			if (typeof target === 'boolean' || target === FFTO.DEBUG){
				isDeep = !!target;
				target = arguments[i] || {};
				i++;
			}

			for (; i<length; ++i){
				var item = arguments[i];

				// add the current target/copie to list of clones and copies (when refering to "same" item)
				if (isDeep){
					clones.push(target);
					copies.push(item);
				}

				for (var name in item){
					if (!target.hasOwnProperty(name)){
						var info = Object.getOwnPropertyDescriptor(target, name);
						// console.log(target, info);
					}

					var src        = target[name];
					var copy       = item[name];
					var copyIndex  = isDeep ? copies.indexOf(copy) : -1;
					var clone;

					// skip infinity loop
					if (target === copy){
						continue;
					}

					if (~copyIndex){
						target[name] = clones[copyIndex];
					}else if (isDeep && copy && (_.is.arr(copy, true) || _.is.obj(copy, true))){
						// make sure to create a new Array/Object when it's an inherited property
						if (!target.hasOwnProperty(name)){
							src = null;
						}

						if (_.is.arr(copy, true)){
							clone = src && _.is.arr(src, true) ? src : [];
						}else{
							clone = src && _.is.obj(src, true) ? src : {};
						}

						copies.push(copy);
						clones.push(clone);

						if (isDebug){
							console.log(name, copy, clone);
						}

						target[name] = _walk(isDeep, clone, copy);
					}else{
						target[name] = copy;
					}
				}
			}

			return target;
		}

		var response = _walk.apply(this, arguments);
		clones = null;
		copies = null;

		return response;
	};

	/**
	 * Copy either an Object or Array and add (if specified) a list of properties
	 * @alias utils.copy
	 * 
	 * @param {*} list 		Array or object to copy
	 * @param {*} [props] 	Add propperties to the list
	 * @returns {object}
	 */
	this.copy = function (list, props){
		if (_.is.arr(list)){
			return _.extend(true, [], list, props || []);
		}else if (_.is.obj(list)){
			return _.extend(true, {}, list, props || {});
		}else{
			return list;
		}
	};

	// Maybe rename this to something else, since utils.$arr would be better to be named utils.arr
	this.arr = function (list){
		return Array.prototype.slice.call(list);
	};

	/**
	 * Return an object with a list of default values if they haven't been defined
	 * @alias utils.defaults
	 * 
	 * @param {*} list 
	 * @param {*} defaults Default values to add to an object
	 * @param {*} [isCopy] Should the default values be a copy of the original
	 * 
	 * @returns {object}
	 */
    this.defaults = function (list, defaults, isCopy){
		list = list || {};

		var i;
		for (i in defaults){
			if (i in list) continue;
			list[i] = isCopy ? _.copy(defaults[i]) : defaults[i];
		}

		return list;
	};

	/**
	 * Return the count of items in an array/object/string
	 * @alias utils.count
	 * 
	 * @example 
	 * utils.count('Joe Blo');
	 * // 7
	 * 
	 * utils.count('Joe Blo', /o/g)
	 * // 2
	 * 
	 * utils.count({'name':'Joe', 'age':45})
	 * // 2
	 * 
	 * utils.count([0,2,5])
	 * // 3
	 * 
	 * utils.count('Joe Blo is ok', ' ')
	 * // 4
	 * 
	 * @param {*} list 	
	 * @param {*} [separator=''] Used to split a string OR can be a RegExp and count the number of found matches
	 * 
	 * @returns {number}
	 */
	this.count = function (list, separator){
		if (separator instanceof RegExp){
			var m = list.match(separator);
			return m ? m.length : 0;
		}
		separator = this.defined(separator, '');
		list      = this.toArray(list, separator);
		return list.length;
	};

	/**
	 * Get the first value that match in the callback
	 * @alias utils.first
	 * 
	 * @param {array|object} 	list 		List of values
	 * @param {function} 		callback	Function to call on every items
	 * 
	 * @returns {*} 			First valid value, or null if nothing found
	 */
    this.first = function (list, callback){
		if (list.length === 1 && Array.isArray(list[0])){
			list = list[0];
		}

		for (var i in list){
			if (callback(list[i])){
				return list[i];
			}
		}

		return null;
	};

	/**
	 * Uses {@link utils.first} and  {@link utils.is.def} to find the first defined value.
	 * @alias utils.defined
	 * 
	 * @returns {*}	First defined value
	 */
	this.defined = function (){
		return this.first(arguments, _.is.def);
	};

	/**
	 * Uses {@link utils.first} and {@link utils.is} to find the first truty value
	 * @alias utils.nvl
	 * 
	 * @returns {*} First set value
	 */
	this.nvl = function (){
		return this.first(arguments, _.is);
	};

	/**
	 * Return a argument object. Parse it if it's a url query. Add default values if specified
	 * @alias utils.args
	 * 
	 * @example
	 * utils.args('Value', null, 'key');
	 * // {key: 'Value'}
	 * 
	 * utils.args('a=b&c=999', {'d':true});
	 * // {d: true, a: 'b', c: 999}
	 * 
	 * @param {*} args 
	 * @param {*} [defaults] Default values to have in the returned object
	 * @param {*} [key] 	 If "args" isn't a valid Object or Query String, use this "key" as the object main key
	 * 
	 * @returns {object}
	 */
    this.args = function (args, defaults, key){
		if (key && args && typeof(args) !== 'object' && !~args.toString().indexOf('=')){
			args = _.toSet(key, args);
		}

		args     = args || {};
		defaults = defaults || {};

		// parse args as string like 'key=value&key2=value'
		if (_.is.str(args)){
			args = _.str.parse(args);
		}

		var i;
		for (i in args){
			defaults[i] = args[i];
		}

		return defaults;
	};

    // format ----------------------------------------------------------------------------------------------------------
	/**
	 * Try getting a value formated with a function
	 * @alias utils.format
	 * 
	 * @param {object} 		[ctx] 	Context use with the format function
	 * @param {*} 			value 	Base value to format
	 * @param {function} 	format 	Function for formating
	 * 
	 * @returns {*} 		Formated value or the origial one
	 */
    this.format = function (ctx, value, format){
		if (format === undefined){
			format = value;
			value  = ctx;
		}
		return _.is.fn(format) ? format.call(ctx, value) : value;
	};

	/**
	 * Trim a string OR string values in an Array/Object
	 * @alias utils.trim
	 * 
	 * @param {*} 		obj 
	 * @param {boolean} all Trim the tabs and linebreak too
	 * @returns {*}
	 */
	this.trim = function (obj, all){
        function _trim (s){
            if (!_.is.str(s)) return s;

            if (all){
                s = s.replace(/\t/g, ' ').replace(/\n|\r/g, ' ');
            }
    
            return s.replace(/\s{2,}/g, ' ').trim();
        }

        if (_.is.either(obj,'obj,arr')){
            for (var i in obj){
                obj[i] = _trim(obj[i]);
            }
        }else if (_.is.str(obj)){
            obj = _trim(obj);
        }

        return obj;
    };

	/**
	 * Encode as Base64 a value
	 * @alias utils.encode
	 * 
	 * @example
	 * utils.encode({'name':'Joe', 'age':45})
	 * // "eyJuYW1lIjoiSm9lIiwiYWdlIjo0NX0="
	 * 
	 * @param {*} data Value to encode
	 * 
	 * @returns {string}
	 */
    this.encode = function (data, prefixed){
		if (!_.is.valid(data)) return null;
		data = JSON.stringify(data);
		data = $win.btoa(unescape(encodeURIComponent(data)));

		if (prefixed){
			data = 'data:application/json;base64,' + data;
		}

		return data;
	};

	/**
	 * Decode as Base64 value
	 * @alias utils.decode
	 * 
	 * @example
	 * utils.decode("eyJuYW1lIjoiSm9lIiwiYWdlIjo0NX0=")
	 * // {'name':'Joe', 'age':45}
	 * 
	 * @param {*} data 
	 * 
	 * @returns {*}
	 */
	this.decode = function (data){
		try{
			// remove prefix
			if (_.is.str(data)){
				data = data.replace(/data\:([^;,]+)(;base64),/, '');
			}

			data = decodeURIComponent(escape($win.atob(data)));
			data = JSON.parse(data);
		}catch(e){
			data = null;
		}
		return _.is.valid(data) ? data : null;
	};

    // data ------------------------------------------------------------------------------------------------------------
	this.fetch = this.http = function (url, data, args, callback, ctx, _callback){
		if (_.is.fn(args)){
			callback = args;
			args     = {};
		}else if (_.is.fn(data)){
			callback = data;
			args     = {};
			data     = {};
		}

		args             = args || {};
		args.data        = args.data || data || null;
		args.type        = args.type || null;
		args.ctx         = args.ctx || ctx || null;
		args.loading     = args.loading || null;                   // add a loader element
		args.loadingType = args.loadingType || false;
		args.selector    = args.selector || null;                  // selector for the returned HTML, to fetch only a specific postion
		args.assets      = 'assets' in args ? args.assets : false; // when fetching with a selector, get also the <script> and <style> tags in the head and footer. Option [true, false, style, script]
		args.cache       = args.cache || false;                    // be able to cache the results

		args.queue    = args.queue || null;
		args.delay    = _.toDuration(args.delay || 0);
		args.method   = args.method || (args.data ? 'post' : 'get');
		args.callback = args.callback || callback || null;
		args.timeout  = _.toDuration('timeout' in args ? args.timeout : '100s');

		var request = new XMLHttpRequest();
		var queue   = args.queue ? CONSTS.QUEUE[args.queue] || (CONSTS.QUEUE[args.queue] = []) : null;
		var start   = _.now();
        // TODO add unique...	

		request.timeout = args.timeout;

		if (!url){
			// TODO should an event of callback be triggerd here?
			return;
		}

		// there's a selector in the url
		var index = url.indexOf(' ');
		if (!!~index){
			args.selector = url.slice(index).trim();
			url  		  = url.slice(0, index);
		}

		// update the URL
		url = _.str.replace(url, args.data || {});
		
		if (args.method === 'get' && args.data){
			url += ((~url.indexOf('?') ? '&' : '?') + _.toString(args.data, 'query'));
		}

		// make sure there's a / at the end (because WP asks for that, if not, it first does a 301 redirect)
		url = url.replace(/([^\/])([\?\#].+$)/, '$1/$2');

		// var 
		var dom = null;
	
		// [ ] Maybe change the code for "args.selector", to be used on a specific attribute for parsing it's html OR more the "parsing" to another function

		function _get (data, selector){
			if (_.is.obj(data)){
				data = data[selector];
			}else if (_.is.str(data)){
				// @source jQuery code
				var doc  = $doc.implementation.createHTMLDocument("");
				var head = data.match(/\<head.*?\>([\s|\S]+)\<\/head\>/);
				var base = '<base href="'+$doc.location.href+'" />';

				if (head){
					data = data.replace(head[0], '');
					head = head[1];
				}
				
				// if the <body> exists, set the full <html> block with the data
				if (~data.indexOf('<body')){
					doc.documentElement.innerHTML = data;
				}else{
					doc.body.innerHTML = data;
				}

				doc.head.innerHTML = base + (head || ''); 
				
				dom = doc;
				
				if (selector === ':dom'){
					data = doc;
				}else{
					var root  = $doc.createElement('div');
					var nodes = _.dom.get.all(selector, {'ctx':doc.body});
					
					// add <script>, <style> and <link>
					if (args.assets){
						var assets   = [];
						var scripts  = [];
						var styles   = [];
						var iScripts = [];
						var iStyles  = [];

						// TODO be able to get/create a doc.foot or something like that, to get extra js/style, maybe we can target a specific selector for special "foot" section

						_.dom.get.all('script,link[rel="stylesheet"]', {'ctx':doc.head}, function (n){
							var tag = _.dom.tag(n);
							if (tag === 'link'){
								styles.push(n);
							}else if (tag === 'style'){
								iStyles.push(n);
							}else if (tag === 'script' && n.src){
								scripts.push(n);
							}else if (tag === 'script' && n.childNodes.length){
								iScripts.push(n);
							}
							assets.push(n);
						});

						nodes = assets.concat(nodes);
					}

					var i, l;
					for (i=0, l=nodes.length;i<l;++i){
						root.appendChild(nodes[i]);
					}
					
					data = root.innerHTML;
				}
			}

			return data;
		}

		// TODO add a way to either set an attribute OR a diff classname
		function _loading (v){
			if (!args.loading) return;
			
			if (args.loadingType === 'attrs'){
				_.dom.attrs(args.loading, 'loading', v);
			}else{
				if (v){
					_.dom.addClass(args.loading, 'is-loading');
				}else{
					_.dom.removeClass(args.loading, 'is-loading');
				}
			}
		}

		function _change (){
			if (
				request.readyState !== XMLHttpRequest.DONE 
				|| request.status === 0
			) return;

			_loading(false);

			var type       = args.type || request.getResponseHeader("Content-Type") || '';
			var status     = request.status;
			var allHeaders = request.getAllResponseHeaders().split("\n");
			var headers    = {};
			var response   = null;
			var time       = _.now() - start;

			_.each(allHeaders, function (head){
				if (head = head.trim()){
					var pair = head.split(':');
					var key  = pair[0].trim();
					var value= pair[1].trim();
					headers[key] = value;
				}
			});
			
			// parse the data
			if (type === 'application/json' || ~type.indexOf('json')){
				response = JSON.parse(request.responseText);
				type     = 'json';
			}else if (type === 'application/xml' || type === 'text/xml' || type === 'text/html' || type === 'html' || type === 'xml'){
				response = request.responseXml;
				type     = 'xml';
			}else if (type === 'text/css' || type === 'css'){
				response = _.str.parse(request.responseText, 'css');
				type     = 'css';
			}else{
				response = request.responseText;
				type     = 'text';
			}

			status   = status === 200 && !response ? 204 : status;

			var value = response && args.selector ? _get(response, args.selector) : response;

			// output logs from PHP
			if (headers['content-logs']){
				var logs  = _.decode(headers['content-logs']);
				var time  = headers['content-time'] || '';
				var label = url + (time ? ' ('+time+')' : '');
				
				console.group(label);
				for (var i=0, l=logs.length; i<l; ++i){
					eval('console.log('+logs[i]+')');
				}
				console.groupEnd(label);
			}

			if (_.is.fn(args.callback)){
				var params = [value, (status >= 200 && status <= 299), {
					'type'    : type,
					'headers' : headers,
					'request' : request,
					'status'  : status,
					'response': response,
					'document': dom,
					'time'    : time,
				}];

				_callback && _.apply.ctx(args.ctx, _callback, params);
				_.apply.ctx(args.ctx, args.callback, params);

			}
			
			if (queue){
				queue.shift();

				if (queue.length){
					queue[0]();
				}
			}
		}

		function _call (){
			_loading(true);

			request.onreadystatechange = _change;
			
			// send request
			request.open(args.method, url, true);
			request.setRequestHeader('Ajax', true);

			start = _.now();
				
			if (args.method === 'post' && args.data){
				var data = args.data instanceof FormData ? args.data : _.toForm(args.data);
				request.send(data);
			}else{
				request.send();
			}
		}
		
		if (queue){
			queue.push(_call);

			if (queue.length === 1){
				_call();
			}
		}else if (args.delay){
			setTimeout(_call, args.delay);
		}else{
			_call();
		}
		
		var old = request.abort;
		request.abort = function(){
			_loading(false);
			old.call(this);
		}; 

		return request;
	};

	this.cancel = function (item){
		if (item && item.abort){
			item.abort();
		}else if (_.fn){
			_.fn.cancel(item);
		}else{
			clearTimeout(item);
			clearInterval(item);
		}
		return null;
	};

	this.require = this.requires = function (url, args, callback){
		args     = args || {};
		args.ctx = 'ctx' in args ? args.ctx : null;

		// many ----------------------------------------------------------------
		// TODO deal with array or URLs
		if (_.is.arr(url)){
			var callback = callback || args.callback;
			return _.fn.batch(url, {
				'wait': args.wait,
				'each': function (v, done){ _.require(v, args, done); },
				'all' : function (v){ _.apply.ctx(args.ctx, callback, [v]); }
			});
		}

		// single --------------------------------------------------------------
		if (_.is.fn(args)){
			callback = args;
			args     = {};
		}

		args          = args || {};
		args.async    = 'async' in args ? args.async : true;
		args.cache    = 'cache' in args ? args.cache : true;
		args.ctx      = 'ctx' in args ? args.ctx : null;
		args.callback = callback || args.callback || null;
		args.version  = 'version' in args ? args.version : (window.version || false);
		args.parent   = args.parent || document.head;

		var cache = CONSTS.REQUIRES[url] = args.cache && url in CONSTS.REQUIRES ? CONSTS.REQUIRES[url] : {
			'status': null,
			'queue' : [],
		};

		// add new item to queue
		if (args.callback){
			cache.queue.push({
				'ctx'     : args.ctx,
				'callback': args.callback,
			});
		}

		if (cache.status){
			if (cache.status === STATUS.READY || cache.status === STATUS.ERROR) _done();
			return;
		}else{
			cache.status = STATUS.LOADING;
		}
		
        function _done (success){
			if (_.is.bool(success)){
				cache.status = success ? STATUS.READY : STATUS.ERROR;
			}

			success = cache.status === STATUS.READY;
			
			var items = cache.queue;
			var i=0, l=items.length, v;
			
			cache.queue = [];
			for (;i<l;++i){
				v = items[i];
				_.apply.ctx(v.ctx, v.callback, [url, success]);
			}
        }

		var head  = _.dom.get(args.parent) || document.getElementsByTagName("head")[0];
		var isCss = !!~url.indexOf('.css');
		var url2  = url;

		if (args.version){
			url2 += (!!~url.indexOf('?') ? '&' : '?') + 'v=' + args.version;
		}

		// auto-add the proper protocole
		if (url2.indexOf('//') === 0){
			if (window.location.protocol === 'https:'){
				url2 = 'https:' + url2;
			}else{
				url2 = 'http:' + url2;
			}
		}

        if (isCss){
            var link    = document.createElement('link');
            link.rel  	= 'stylesheet';
			link.type	= 'text/css';
			link.media 	= 'all';
			link.onload = function(){ _done(true); };
			link.onerror= function(){ _done(false); };
            link.href 	= url2;

			head.appendChild(link);
        }else{
            var script   = document.createElement('script');
			script.type  = "text/javascript";
			
			if (args.async){
				script.async = "true";
				script.defer = "true";
			}

            // IE browser
            if (script.readyState){
                script.onreadystatechange = function (){
                    if (this.readyState !== "loaded" && this.readyState !== "complete") return;
                    this.onreadystatechange = null;
                    _done(true);
                };
            // other browsers
            }else{
                script.onload  = function(){ _done(true); };
                script.onerror = function(){ _done(false); };
            }

            script.src = url2;

            head.appendChild(script);
        }

		return url2;
	};

	this.media = function (url, args, callback, index){
		args     = args || {};
		args.ctx = 'ctx' in args ? args.ctx : null;

		// find the media items inside a normal div
		if (_.is.el(url) && !_.is.el(url, 'img,video,audio')){
			url = _.dom.get.all.ctx(url, 'img,video,audio');
		}

		// many ----------------------------------------------------------------
		if (_.is.arr(url)){
			var count    = 0;
			var total    = url.length;
			var items    = [];
			var filtered = [];
			var callback = callback || args.callback;

			if (callback === args.callback){
				args.callback = null;
			}

			_.$arr(url, function (v, i){
				_.media(v, args, _each, i);
			});

			function _each (v, i){
				count++;

				if (v){
					items[i] = v;
				}else{
					items[i] = url[i];
				}

				// TODO deal with empty images
				if (v && v.el){
					filtered.push(v);
				}

				(count === total) && _.apply.ctx(args.ctx, callback, [filtered, items]);
			}

			return items;
		}

		// single --------------------------------------------------------------
		if (_.is.fn(args)){
			args = {'callback':args};
		}

		// args.image = url instanceof Image ? url : null;
		args.cache    = 'cache' in args ? args.cache : true;
		args.data     = 'data' in args ? args.data : {};
		args.version  = 'version' in args ? args.version : (window.media_version || false);
		args.callback = args.callback || callback || null;

		// if cache, keep the same el
		var el = (url instanceof Image || url instanceof HTMLVideoElement || url instanceof HTMLAudioElement) && args.cache ? el : null;
		
		// get the src of the item (if not already an url)
		url = _.toSrc(url, 'media');
		
		var item = CONSTS.MEDIA[url];		
		if (!url) return _call();
		
		if (!item && url){
			var tag = 'img'; // TODO deal with video/audio
			var el  = el || document.createElement(tag);

			item = CONSTS.MEDIA[url] = {
				'el'      : el,
				'src'     : url,
				'type'    : tag,
				'width'   : 0,
				'height'  : 0,
				'queue'   : [],
				'status'  : STATUS.LOADING,
				'isCached': false,
			};

			// image already defined
			if (el instanceof Image && el.naturalWidth && el.naturalHeight){
				_load.apply(el);
			}else{
				el.onload  = _load;
				el.onerror = _error;
				el.src     = url;
			}
		}
		
		// check if the media item is already loaded, if not, add it to a queue
		if (item.status === STATUS.READY || item.status === STATUS.ERROR){
			_done();
		}else{
			item.queue.push(args);
		}
		
		function _load (){
			// @info little fix for IE9 to IE11 with SVG images
			if (!this.width && !this.height){
				document.body.appendChild(this);
				this.width 	= this.offsetWidth;
				this.height = this.offsetHeight;
				document.body.removeChild(this);
			}

			item.width  = this.naturalWidth || this.width;
			item.height = this.naturalHeight || this.height;
			item.status = STATUS.READY;

			// @todo svg

			_done();
		}
		function _svg (){
			// TODO svg
		}
		function _error (){
			item.status = STATUS.ERROR;
			_done();
		}		
		function _done (){
			var queue = item.queue || [];

			_.$arr(queue, function (v, i){
				var el       = item.status === STATUS.ERROR ? null : item.el;
				var isCached = item.isCached; // first time it's requested, it's not a cached version
				var result   = {
					'el'    : el,
					'source': item.el,
					'src'   : item.src,
					'width' : item.width,
					'height': item.height,
					'type'  : item.type,
					'index' : index,
					'cached': isCached,
				};

				_call(result, index);

				item.isCached = true;
			});
		}

		function _call (item){
			_.apply.ctx(args.ctx, args.callback, [item, index]);
			(args.callback !== callback) && _.apply.ctx(args.ctx, callback, [item, index]);
			return item;
		}
		
		return item;
	};

	this.cookie = function (key, value, expire){
		var set    = _.toSet(key, value);
		var prefix = _.theme('cookie_prefix', '');

		if (set){
			// specific amount of time
			if (expire){
				expire = +new Date() + _.toDuration(expire);
				expire = '; expires=' + (new Date(expire)).toUTCString();
			// never expires
			}else if (expire === false){
				// "never" expire (there's a limitation of 400days) https://developer.chrome.com/blog/cookie-max-age-expires/
				expire = +new Date() + _.toDuration('400days');
				expire = '; expires=' + (new Date(expire)).toUTCString();
			// session cookie, will expire when the session is closed
			}else{
				expire = '';
			}

			for (var i in set){
				var v = JSON.stringify(set[i]);
				document.cookie = (prefix + i) + '=' + v + expire + '; path=/';
			}
		}else{
			var crumbs = document.cookie.split('; ');
			var crumb, i, l, pair, k, v;
			
			value = key ? null : {};
			for (i=0, l=crumbs.length; i<l; ++i){
				crumb = crumbs[i];
				pair  = crumb.split('=');
				k	  = pair[0].trim().replace(prefix, '');
				v 	  = pair[1].trim();

				if (key === k){
					return _.toValue(v);
				}else if (!key){
					value[k] = _.toValue(v);
				}
			}

			return value;
		}
	};

    // casting ---------------------------------------------------------------------------------------------------------
	/**
	 * Check and return a object set (if valid). 
	 * @alias utils.toSet
	 * 
	 * @example
	 * utils.toSet('title', 'value');
	 * // {title: 'value'}
	 * 
	 * utils.toSet({'name':'John Doe'});
	 * // {'name':'John Doe'}
	 * 
	 * utils.toSet('key');
	 * // undefined
	 * 
	 * utils.toSet('key', undefined, {'a':'b'});
	 * // {'a':'b'}
	 * 
	 * @param {string|object} 	key 		Key that the value will have OR an object
	 * @param {*} 				[value] 	If key is string, this should be the value used		
	 * @param {*} 				[fallback] 	Fallback in case it's not an object
	 * 
	 * @returns {*}
	 */
	this.toSet = function (key, value, fallback){
		if (_.is.obj(key, true)){
			return key;
		}else if (value !== undefined){
			var values = {};
			values[key] = value;
			return values;
		}else{
			return fallback;
		}
	};
    
	/**
	 * Transform a value into an array
	 * @alias utils.toArray
	 * 
	 * @example
	 * utils.toArray('1,2,3,4')
	 * // ['1','2','3','4']
	 * 
	 * utils.toArray('1,2,3,,,4')
	 * // ['1', '2', '3', '', '', '4']
	 * 
	 * utils.toArray('1,2,,,3,4,true,bob', true)
	 * // [1, 2, 3, 4, true, 'bob']
	 * 
	 * utils.toArray('value name title', ' ')
	 * // ['value', 'name', 'title']
	 * 
	 * @param {*} 					list 				List that will be transformed into an array
	 * @param {*} 					[args] 
	 * @param {string} 				args.separator="," 	Used to split a List string
	 * @param {boolean} 			args.unique=false	Skip duplicates
	 * @param {boolean|function} 	args.filter			Either skip null values OR call a function to filter the items
	 * @param {boolean} 			args.parse			Parse every item and try getting a proper value
	 * @param {boolean} 			args.force			Force an array, in case it has extra properties that aren't necessary
	 * @param {function} 			[callback] 			Function to use on every item
	 * 
	 * @returns {array}
	 */
    this.toArray = function (list, args, callback){
        if (!list && list !== 0){
            return [];
        }

        if (_.is.str(args)){
            args = {'separator':args};
        }else if (_.is.bool(args)){
            args = {'unique':args, 'parse':true};
        }else if (_.is.fn(args)){
            args = {'filter':args};
        }

        args           = args || {};
        args.separator = 'separator' in args ? args.separator : ',';
        args.unique    = 'unique' in args ? args.unique : false;
        args.filter    = callback || args.filter || null;
        args.parse     = args.parse || false;
        args.force     = args.force || false;
		args.return    = args.return || false;
		args.ctx 	   = args.ctx || null;

		var filter = typeof(args.filter) === 'function' ? args.filter : null;
		var arr    = [];
		_.$arr(list, {
			'safe'     : true,
			'separator': args.separator,
			'force'    : args.force,
			'ctx'      : args.ctx,
		}, function (v, i){
			v = args.parse ? _.toValue(v) : v;

			if (filter){
				v = filter.call(args.ctx, v, i);
			}

			if (
				!_.is.valid(v) ||
				(args.unique && !!~arr.indexOf(v))
			) return;

			arr.push(v);
		});

		if (args.return){
			var arr2 = null;
			var v;
			for (var i=0,l=arr.length;i<l;++i){
				v = arr[i];

				if (args.return === 'obj/key'){
					arr2    = arr2 || {};
					arr2[v] = true;
				}
			}

			arr = arr2;
		}

		return arr;
    };

	/**
	 * Make sure an object is returned with a specific key. If the key doens't exists, then an object is 
	 * created with the obj as the value.
	 * @alias utils.toObject
	 * 
	 * @example
	 * utils.toObject('ok')
	 * // {value: 'ok'}
	 * 
	 * utils.toObject('The Label', 'label')
	 * // {label: 'The Label'}
	 * 
	 * var obj = {'label':'Heading'};
	 * utils.toObject(obj, 'label');
	 * // {'label':'Heading'}
	 * 
	 * var obj = {'label':'Heading'};
	 * utils.toObject(obj, 'item');
	 * // {'item':{'label':'Heading'}}
	 * 
	 * @param {*} 		obj 		Source object
	 * @param {*} 		key 		Key value that needs to exists in the object
	 * @param {*} 		[args] 
	 * @param {object} 	args.props	List of added properties
	 * @param {boolean} args.copy  	Copy the main object (if using the same in other places)
	 * 
	 * @returns {object}
	 */
	this.toObject = function (obj, key, args){
		if (_.is.bool(args)){
			args = {'copy':true};
		}

		key = key || 'value';

		args       = args || {};
		args.props = args.props || null;
		args.copy  = args.copy || false;

		// make sure it has a default pattern (if not already set properly)
		if (!_.has(obj, key)){
			obj = _.toSet(key, obj);
		}else if (args.copy){
			obj = _.copy(obj);
		}

		if (args.props){
			obj = _.extend(true, obj, args.props || {});
		}

		return obj
	};

	this.toForm = function (obj){
		var	data = new FormData();
		
		_.obj.traverse(obj, function (i, v, pi, pv){
			if (_.is.arr(pv) || _.is.obj(pv, true)){
				i = pi + '['+i+']';
			}

			if (!_.is.def(v)){
				v = null;
			}
			
			if (!_.is.obj(v, true)){
				data.append(i, v);
			}

			return i;
		});

		return data;
	};

	/**
	 * Return a string version of the object. Detect the type and return the best solution.
	 * If the object is an instance of a class and has a custom toString() function, that function will be called.
	 * @alias utils.toString
	 * 
	 * @example
	 * utils.toString(new Date());
	 * // "2022-07-03 18:38:57 UTC"
	 * 
	 * utils.toString({'name':'John Doe', 'age':40});
	 * // '{"name":"John Doe","age":40}'
	 * 
	 * utils.toString({'name':'John Doe', 'age':40}, 'style');
	 * // 'name:"John Doe"; age:40'
	 * 
	 * utils.toString({'name':'John Doe', 'age':40}, 'attrs');
	 * // 'name="John Doe" age="40"'
	 * 
	 * utils.toString({'name':'John Doe', 'age':40}, [' // ', ' --> ']);
	 * // "name --> "John Doe" // age --> 40"
	 * 
	 * utils.toString({'name':'John Doe', 'age':40}, {
     *     'pair' : 'data-{key}="{value}"',
     *     'join' : ' '
     * });
	 * // data-name="John Doe" data-age="40"
	 * 
	 * @param {*} obj 
	 * @param {*} 						[args] 				Has predefined codes (style, css, attributes, attrs, query, Array, Function, String)
	 * @param {string} 					args.prefix			String to add at the befinning
	 * @param {string|boolean|function} args.pair			Way to glue the key to the value
	 * @param {string|boolean} 			args.join			Way to glue items
	 * @param {string} 					args.suffix			String to add at the end
	 * @param {boolean} 				args.class=true		Use "toSring()" function if it's defined 
	 * @param {boolean} 				args.json=true		If the value type isn't detected, use JSON.stringify on the value
	 * @param {boolean} 				args.pretty			Return pretty JSON when using the JSON.stringify
	 * @param {*} 						args.fallback		If the value type isn't detected, use this fallbak
	 * 
	 * @returns {string}
	 */
    this.toString = function (obj, args){
		if (args === 'style'){
			args = {'join':'; ', 'pair':':', 'json':true};
		}else if (args === 'css'){
            args = {'join':'; ', 'pair':':', 'prefix':'{', 'suffix':'}'};
        }else if (args === 'attributes' || args === 'attrs'){
            args = {'join':' ', 'pair':'{{ key }}="{{ value }}"'};
        }else if (args === 'query'){
            args = {'join':'&', 'pair':'=', 'json':false};
        }else if (_.is.str(args)){
			args = {'join':args};
		}else if (_.is.arr(args)){
			args = {'join':args[0], 'pair':args[1]};
		}else if (_.is.fn(args)){
			args = {'walk':args};
		}else if (args === true){
            args = {'json':true};
        }
    
        args          = args || {};
		args.prefix   = args.prefix || '';
		args.pair     = 'pair' in args ? args.pair : false;
		args.walk     = 'walk' in args ? args.walk : false;
        args.join     = _.defined(args.join, args.separator, false);
		args.suffix   = args.suffix || '';
		args.class    = 'class' in args ? args.class : true;
        args.json     = 'json' in args ? args.json : true;
        args.pretty   = 'pretty' in args ? args.pretty : false;
        args.fallback = 'fallback' in args ? args.fallback : obj;
        
        if (obj === true){
            return 'true';
        }else if (obj === false){
            return 'false';
        }else if (obj === null){
            return 'null';
        }else if (_.is.class(obj, 'Date')){
            var _pad = function (v){ return _.str.pad(v, 0, 2, 'left'); };

            obj = obj.getUTCFullYear() + '-' +
                _pad(obj.getUTCMonth() + 1) + '-' +
                _pad(obj.getUTCDate()) + ' ' +
                _pad(obj.getUTCHours()) + ':' +
                _pad(obj.getUTCMinutes()) + ':' +
                _pad(obj.getUTCSeconds()) + ' UTC';
		}else if (_.is.obj(obj) && _.is.fn(args.walk)){
			var strings = [];
			
			// todo replace this with "obj.traverse"

			var _walk = function (pv, pi){
				_.$arr(pv, function (v, i){
					var r = _.apply(args.walk, [v, i, pi !== undefined ? pv : null, pi]);

					if (r){
						i = r;
					}else if (pi){
						i = pi + '-' + i;
					}

					if (_.is.obj(v, true) || _.is.arr(v)){
						_walk(v, i);
					}
				});
				
				// if (response){
				// 	key = response;
				// }else if (parentKey){
				// 	key = parentKey + args.parentSeparator + key;
				// }
	
				// if (utils.is.obj(value, true) || utils.is.arr(value)){
				// 	for (var i in value){
				// 		_walk(i, value[i], key, value);
				// 	}
				// }else{
				// 	string.push(key + args.pairSeparator + value);
				// }

				// args = {'join':'&', 'pair':'=', 'json':false};
			}
			
			obj = _walk(obj);
        }else if (_.is.obj(obj) && (args.pair !== false || args.join !== false)){
            var pair  = args.pair === true ? '' : args.pair;
            var join  = args.join === true ? '' : args.join;
            var items = [];
    
            for (var i in obj){
                var v = obj[i];

                if (_.is.nbr(i)){
                    items.push(v);
                }else if (_.is(v)){
                    pair = pair || '';

                    if (_.is.str(pair, '{')){
                        v = _.is.obj(v) ? v : {'value':v, 'key':i};
						v = _.str.replace(pair, v, {'array':false});
                        items.push(v);
                    }else if (_.is.fn(pair)){
                        v = _.apply(pair, [v, i]);
                        items.push(v);
                    }else{
						v = _.toString(v, {'json':args.json});
						items.push(i + pair + v);
                    }
                }
            }
    
            if (join !== false){
                return args.prefix + (items.length ? items.join(join || '') : '') + args.suffix;
            }else{
                return items;
            }
		}else if (args.class && typeof obj === 'object' && obj.toString !== Object.prototype.toString){
			return '' + obj.toString();
		}else if (typeof obj === 'function'){
			return '[class ' + obj.prototype.constructor.name + ']';
        }else if (_.is.obj(obj)){
			return JSON.stringify(obj, null, args.pretty ? 4 : 0);
        }else{
            obj = args.fallback;
        }
		
        if (args.json){
            return JSON.stringify(obj, null, args.pretty ? 4 : 0);
        }
    
        return obj;
    };

	this.toQuery = function (obj){
		var strings = [];

		_.toString(obj, function (v, i, pv, pi){
			if (_.is.not(v)) return;
						
			if (_.is.arr(pv)){
				i = pi + '[]';
			}else if (_.is.obj(pv)){
				i = pi + '[' + i + ']';
			}
			
			if (typeof(v) !== 'object'){
				v = encodeURIComponent(v);			
				strings.push(i + '=' + v);
			}

			return i;
		});

		return strings.join('&');
	};

	this.toUrl = function (url, args){
		if (_.is.obj(url)){
			args = url;
			url  = location.href;
		}else if (_.is.bool(url)){
			args = url;
			url  = location.href;
		}
		
		if (_.is.bool(args)){
			args = {'return':args};
		}

		args        = args || {};
		args.hash 	= args.hash || null;
		args.query 	= args.query || {};
		args.return = args.return || null;

		// break appart url
		var hash  = '';
		var query = '';
		
		url = url || location.href;

		var info = url.replace(/\?([^#]+)/, function (m, $1){ query = $1; return ''; })
				 .replace(/#(.+)/, function (m, $1){ hash = $1; return ''; })
				//  .match(/(https?):\/\/([^\:\/]+)(?:\:(\d+))?\/(.*)/);
				 .match(/(?:(https?):\/\/([^\:\/]+)(?:\:(\d+|\.))?|(\.))\/(.*)/);
		
		// _js([url, info]);

		var host      = info[2];
		var domain    = '';
		var subdomain = '';

		if (host){
			domain    = host.split('.');
			subdomain = '';
			
			if (domain.length > 2){
				subdomain = domain.shift();
			}

			domain = domain.join('.')
		}else if (info[4]){
			host   = null;
			domain = info[4];
		}


		query = _.str.parse(query, 'query');
		query = _.extend(query, args.query);

		url = {
			'href'     : url,
			'protocole': info[1] || 'http',
			'host'     : host,
			'port'     : +(info[3]||80),
			// 'path'     : info[4]||'',
			'path'     : info[5]||'',
			'hash'     : hash||'',
			'query'    : query||'',
			'domain'   : domain||'',
			'subdomain': subdomain,
			'secure'   : info[1] === 'https',
			'local'	   : host === location.hostname,
		};
		
		if (args.return === true){
			return url;
		}else if (args.return){
			return url[args.return];
		}

		var q = _.toQuery(query);
		url = (url.host ? (url.protocole + '://' + url.host) : '.') + '/' + url.path + (q?'?'+q:'') + (hash?'#'+hash:'');

		return url;
	};

	this.toUrl.query = function (query){
		return _.toUrl({'query':query});
	};	

	/**
	 * Parse a string and tries returned the proper value.
	 * @alias utils.toValue
	 * 
	 * @example
	 * utils.toValue('true');
	 * // true
	 * 
	 * utils.toValue('-1.444');
	 * // -1.444
	 * 
	 * utils.toValue('["a",1,6]');
	 * // ['a', 1, 6]
	 * 
	 * @param {string} 	str			String value to parse
	 * @param {object} 	[args]
	 * @param {*}		args.ctx	Context to use when the value is "this"
	 * 
	 * @returns {*}
	 */
    this.toValue = function (str, args){
        if (typeof str !== 'string' || str === ''){
            return str;
        }

		args         = args || {};
		args.ctx     = args.ctx || null;
		args.obj     = 'obj' in args ? args.obj : true;
		args.arr     = 'arr' in args ? args.arr : true;
		args.replace = args.replace || {};
        
		var s = str.replace(/^'(.+)'$/, '$1').replace(/^"(.+)"$/, '$1');				// string, but not trimed
        var v = str.trim().replace(/^'(.+)'$/, '$1').replace(/^"(.+)"$/, '$1').trim();

		if (s in args.replace){
			v = args.replace[s];
		}else if (v === 'true'){
            v = true;
        }else if (v === 'false'){
            v = false;
        }else if (v === 'null' || v === 'undefined' || v === null || v === undefined){
            v = null;
        }else if (!isNaN(v) && v !== '' && (v == 0 || v[0] !== '0')){
            v = parseFloat(v);
        }else if (v === 'this'){
            v = args.ctx;
        }else if ((args.obj && v[0] === '{') || (args.arr && v[0] === '[')){
			try{
				v = _.toJson(v);
            }catch (e){}
        }else{
			v = s;
		}

        return v;
    };

	/**
	 * Parse a string/array of values and call {@link utils.toValue} on each item.
	 * @alias utils.toValues
	 * 
	 * @example
	 * utils.toValues('true, blue, "adfsd, asdf"')
	 * // [true, 'blue', 'adfsd, asdf']
	 * 
	 * utils.toValues('[true, blue, "adfsd, asdf"]')
	 * // ['[true, blue, "adfsd, asdf"]']
	 * 
	 * @param {string} 	str			String value to parse
	 * @param {object} 	[args]		Arguments passed to all calls to utils.toValue()
	 * 
	 * @returns {array}
	 */
	this.toValues = function (str, args){
		var values = [];
		if (!str) return values;

		if (_.is.arr(str)){
			for (var i in str){
				var v = args !== false ? _.toValue(str[i], args) : str[i];
				values.push(v);
			}
		}else if (typeof str === 'string'){
			// @info this does not work with complex string like : `"text", 1234, true, { a : "value" }` the object isn't parsed properly
			str.replace(RE.STR_VALUES, function (m, $1){
				var v = args !== false ? _.toValue($1, args) : $1.replace(/^"(.+)"$/, '$1').replace(/^'(.+)'$/, '$1');
				values.push(v);
			});
		}

		return values;
	};

	/**
	 * Evaluate a string and try returning it's JSON representation.
	 * @alias utils.toJson
	 * 
	 * @example
	 * utils.toJson('{ a : 123, bob : [1,2,3] }');
	 * // {a: 123, bob: [1, 2, 3]}
	 * 
	 * utils.toJson('[ 3, 5, "a" ]')
	 * // [3, 5, 'a']
	 * 
	 * @param {string} 	str				JSON string value to parse
	 * @param {object} 	[args]		
	 * @param {object} 	args.ctx		Context used when parsing the string
	 * @param {object} 	args.warn		Log a warning if the JSON couldn't be parsed
	 * @param {object} 	args.fallback	Value to return if the JSON couldn't be parse
	 * 
	 * @returns {object}
	 */
	this.toJson = function (str, args){
		if (_.is.obj(str)) return str;

        args          = args || {};
        args.ctx      = 'ctx' in args ? args.ctx : null;
        args.warn     = 'warn' in args ? args.warn : false;
        args.fallback = 'fallback' in args ? args.fallback : null;

        if (!_.is.str(str)){
			return args.fallback;
        }
        
		str = str.trim().replace(/^\/\/.*/gm, ''); // remove comments
        
		// make sure there's brackets before and after the json data
		if (str[0] !== '{' && str[0] !== '['){
			str = '{'+str+'}';
		}

        var json = args.fallback;
        try{
            var fn = new Function('utils', 'return '+str+';');
			json = fn.apply(args.ctx, [utils]);
		}catch (e){
			if (args.warn){
				_.warn('The JSON string couldn\'t be eval().\n{error}\n\n{str}', {'error':e, 'str':str});
			}
		}

		return json;
    };

	/**
	 * @typedef  {Object} 	toActionObject
	 * 
	 * @property {string}	name
	 * @property {string}	type
	 * @property {array}	params
	 * @property {object}	filters
	 */

	/**
	 * Parse a string and decode an action with special properties. 
	 * Get the params, type (optional) and filters (optional).
	 * @alias utils.toAction
	 * 
	 * @example
	 * utils.toAction('callback.type(param1, param2, true) :filter1 :filter2(2)');
	 * // {'name':'callback', 'type':'type', 'params':['param1', 'param2', true], {'filters':{
	 * //	'filter1' : [],
	 * //	'filter1' : [2],
	 * // }}
	 * 
	 * @param {string} 	str 				String version of an action (eg. "name.type(params...) :filter1 :filter2")
	 * @param {object} 	[args] 
	 * @param {*} 		args.ctx			Context to call the action or pass for the "this" value
	 * @param {string} 	args.type="."		Type separator (eg. "name.type") 
	 * @param {string} 	args.filters=":" 	Filters separator (eg. "name :filter")
	 * @param {object} 	args.apply	 		Try calling the function right away
	 * @param {*} 		[ctx] 				Context to use (unless specified in "args")
	 * 
	 * @return {toActionObject}
	 */
    this.toAction = function (str, args, ctx){
		if (!_.is.str(str)) return null;
		
		if (args === true){
			args = {'apply':args};
		}

		args 		 = args || {};
		args.ctx     = args.ctx || ctx || null;
		args.type    = args.type || '.';     // separator for defining an extra type
		args.filters = args.filters || ':';  // separator for extra filters
		args.apply   = args.apply || false;
		args.replace = args.replace || {};
		
		var name    = str;
		var type    = null;
		var params  = [];
		var filters = {};
		
		function _callback (s){
			s = s.match(RE.FUNCTION_PARAMS);

			var n = s[1];
			var p = _.toValues(s[2] || '', {'ctx':args.ctx, 'replace':args.replace});

			return {
				'name'  : n,
				'params': p,
			};
		}
		
		var i = str.indexOf(args.filters);
		if (~i){
			filters = str.substr(i + 1).trim().split(args.filters);
			name    = str.substr(0, i).trim();
			filters = _.each(filters, function (v, i){
				v = _callback(v);
				return {
					'$id'   : v.name,
					'$value': v.params,
				};
			});
		}

		var c  = _callback(name);
		var p  = c.name.trim().split(args.type);
		name   = p[0];
		type   = p[1] || null;
		params = c.params;

		if (args.apply){
			return _.apply(name, params, {'ctx':args.ctx});
		}

		return {
			'name'   : name,
			'type'   : type,
			'params' : params,
			'filters': filters,
		};
	};

	/**
	 * Parse a Duration string and return a number value in milliseconds.
	 * @alias utils.toDuration
	 * 
	 * @example
	 * utils.toDuration('3s')
	 * // 3000
	 * 
	 * @param {string} 	str 	String number of seconds
	 * 
	 * @returns {number}
	 */
    this.toDuration = function (str){
		if (!_.is.valid(str)) return 0;

		if (_.is.str(str)){
			var time = parseFloat(str);

			if (~str.indexOf('min')){
				time *= 60000;
			}else if (~str.indexOf('hour')){
				time *= 3.6e+6;
			}else if (~str.indexOf('day')){
				time *= 8.64e+7;
			}else if (~str.indexOf('week')){
				time *= 6.048e+8;
			}else if (~str.indexOf('month')){
				time *= 2.628e+9;
			}else if (~str.indexOf('year')){
				time *= 3.154e+10;
			}else if (~str.indexOf('ms')){
				time = time;
			}else if (~str.indexOf('s')){
				time *= 1000;
			}
		}else{
            time = str;
        }

		return isNaN(time) ? 0 : time;
	};

	/**
	 * Parse a item (element, image, background image, link) and tries getting it's image/link. 
	 * @alias utils.toSrc
	 * 
	 * @example
	 * utils.toSrc('url(https://image.jpg)')
	 * // "https://image.jpg"
	 * 
     * var img = new Image();
     * img.src = "https://image.jpg";
     * utils.toSrc(img);
	 * // "https://image.jpg"
	 * 
	 * @param {*} 		src 		Source where to find the "src"
	 * @param {object} 	[args] 		If "string", then the type is specified.
	 * @param {string} 	args.type	Forced type to check
	 * 
	 * @returns {string} Src of the image/link/string
	 */
	this.toSrc = function (src, args){
		if (_.is.str(args)){
			args = {'type':args};
		}
		
		args 		= args || {};
		args.type 	= args.type || null;

		var type = args.type;
		if (_.is.el(src)){
			var tag = src.tagName.toLowerCase();
			if (type === 'media' || type === 'image' || (!type && src instanceof Image)){
				type = 'media';
				src  = src.getAttribute('src') || '';
			}else if (type === 'href' || type === 'link' || tag === 'a' || tag === 'link'){
				type = 'href';
				src  = src.getAttribute('href') || '';
			}else if (type === 'src' || type === 'script' || tag === 'script'){
				type = 'src';
				src  = src.getAttribute('src') || '';
			}else if (type === 'background' || !type){
				type = 'background';
				src  = $win.getComputedStyle(src).backgroundImage;
			}
		}
		
		if (!_.is.str(src)){
			return false;
		}

		src = ~src.indexOf('url(') ? src.match(RE.SRC_URL)[1] : src;
		src = src.trim().replace(/^"|"$/g, '');

		if (
			(type === 'image' && !src.match(RE.IMAGE_EXT))
			|| (type === 'video' && !src.match(RE.VIDEO_EXT))
			|| (type === 'audio' && !src.match(RE.AUDIO_EXT))
			|| (type === 'media' && !src.match(RE.MEDIA_EXT))
		){
			src = '';
		}
		
		// @info an hashtag means a local element
		if (
			(src && src[0] === '#' )
			|| src === 'none'
		){
			src = false;
		}

		return src ? src : false;
	};

	/**
	 * Return a slug version of a string
	 * @alias utils.toSlug
	 *
	 * @example
	 * utils.toSlug('John Doe is    -  - - here')
	 * // "john-doe-is-here"
	 * 
	 * utils.toSlug('John Doe is here', 'space');
	 * // "john doe is here"
	 * 
	 * utils.toSlug('John Doe is here', 'camel');
	 * // "johnDoeIsHere"
	 * 
	 * @param {string}	str 	String to update
	 * @param {string}	[type] 	Type of returned slug [space, underscore, slash, camel, words, default=dash];
	 * 
	 * @returns {string}
	 */
	this.toSlug = function (str, type){
		if (!str) return '';

		str = str.trim().replace(RE.SLUG_CASE, function ($1){
			return '-' + $1.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
		}).replace(/\s/g, '').replace(/-+/g, '-').replace(/^-+/, '');

		str = str.replace(/-*$/, '');

		if (type === 'space'){
			return str.replace(/\-/g, ' ');
		}else if (type === 'underscore'){
			return str.replace(/\-/g, '_');
		}else if (type === 'slash'){
			return str.replace(/\-/g, '/');
		}else if (type === 'camel' || type === 'words'){
			if (type === 'words'){
				str = '-' + str;
			}
			return str.replace(/(\-[a-z0-9])/g, function ($1){
				return $1.substring(1).toUpperCase();
			});
		}else{
			return str;
		}
	};

	/**
	 * Parse the Key/Value of CSS style and get the proper "slug" name for the key (with prefix like -webkit if needed), and the proper value with
	 * the unit if needed and not specified.
	 * @alias utils.toStyle
	 * 
	 * @example
	 * utils.toStyle('marginTop', 33);
	 * // "margin-top:33px"
	 * 
	 * utils.toStyle('--color', 'red');
	 * // --color:red
	 * 
	 * @param {string} 	key 			Key of the CSS style
	 * @param {*} 		value 			Value of the css style
	 * @param {boolean} [returnObject] 	Return the key/value as an object instead of returning the string version
	 * 
	 * @returns {string|object}
	 */
	this.toStyle = function (key, value, returnObject){
		if (key.indexOf('--') === 0){
			return returnObject ? {
				'var'  : key,
				'value': value,
			} : (key + ':' + value);
		}

		var k = CONSTS.DOM.CACHE.STYLE.PREFIXED_NAMES[key];
		if (!k){	
			var styles 		= CONSTS.DOM.CACHE.STYLE.COMPUTED || (CONSTS.DOM.CACHE.STYLE.COMPUTED = $win.getComputedStyle($doc.documentElement, ''));
			var camelCase	= key.replace(/\-([a-z])/g, function (m){ return m[1].toUpperCase(); });
			var upperCase	= camelCase[0].toUpperCase() + camelCase.slice(1);
			var dashCase	= camelCase.replace(/([A-Z])/g, '-$1').toLowerCase();

			if (camelCase in styles)				k = dashCase;
			else if ('webkit'+upperCase in styles)	k = '-webkit-' + dashCase;
			else if ('moz'+upperCase in styles)		k = '-moz-' + dashCase;
			else if ('ms'+upperCase in styles)		k = '-ms-' + dashCase;
			else if ('o'+upperCase in styles)		k = '-o-' + dashCase;
			else 									k = dashCase;

			CONSTS.DOM.CACHE.STYLE.PREFIXED_NAMES[key] = k;
		}

		var v = value;
		if (_.is.either(v, 'nbr,str')){
			v = v.toString().replace(/;\s*$/, '');

			if (~CONSTS.DOM.CACHE.STYLE.PX_VALUES.indexOf(k) && !v.toString().match(/(calc|var)\(/) ){
				v = v.replace(RE.CSS_NUMBER, function (m, $1){
					return ' ' + (+parseFloat($1).toFixed(8)) + 'px';
				}).trim();
			}
			// format the URL to be well formated (with the "url(...)" wrapper)
			if (~CONSTS.DOM.CACHE.STYLE.URL_VALUES.indexOf(k)){
				v = v.replace(RE.CSS_URL, 'url("$1")');
			}
			// format rgba HEX colors
			v = v.replace(RE.COLOR_RGBA, function (m, rgba){
				rgba = _.toArray(rgba);

				if (rgba.length === 2 && rgba[0] in COLOR.NAMES){
					var rgb = COLOR.NAMES[rgba[0]].replace('#', '');
					var r   = parseInt(rgb.substring(0,2), 16);
					var g   = parseInt(rgb.substring(2,4), 16);
					var b   = parseInt(rgb.substring(4,6), 16);
					var a   = rgba[1];
					m = 'rgba(' + [r,g,b,a] + ')';
				}

				return m;
			});
		}
		
		// @fix IE10 has a bug with NULL, so force ''
		if (_.is.not(v)){
			v = '';
		}

		return returnObject ? {
			'key'  : k,
			'value': v,
		} : (k + ':' + v);
	};

	/**
	 * Parse a string and return a valid RegExp verion.
	 * @alias utils.toRegExp
	 * 
	 * @param {string} 	str 				String to convert to Regexp
	 * @param {*} 		[args] 		
	 * @param {boolean}	args.group			All string is grouped
	 * @param {boolean}	args.global=true	Do a global RegExp search
	 * @param {boolean}	args.exact			Wrap RegExp with "^" and "$"
	 * @param {string}	args.prefix			Add a prefix to the RegExp
	 * @param {string}	args.suffix			Add a suffix to the RegExp
	 * @param {boolean}	args.case=true		Match case or not
	 * @param {boolean}	args.return			Return a string or the RegExp
	 * 
	 * @returns {string|RegExp}
	 */
    this.toRegExp = function (str, args){
		if (args === true){
			args = {'global':true};
		}
		if (_.is.arr(str) && str.length >= 3){
			args        = args || {};
			args.prefix = str[0];
			args.suffix = str[2];
			str         = str[1];
		}

		args        = args || {};
		args.group  = 'group' in args ? args.group : false;
		args.global = 'global' in args ? args.global : true;
		args.exact  = args.exact || false;
		args.prefix = args.prefix || '';
		args.suffix = args.suffix || '';
		args.case   = 'case' in args ? args.case : true;
		args.return = 'return' in args ? args.return : null;

		str = str.replace(/([-+().*\/\[\]$^])/g, '\\$1');

		if (args.prefix){
			str = args.prefix + str;
		}
		if (args.suffix){
			str = str + args.suffix;
		}
		if (args.group){
			str = '('+str+')';
		}
		if (args.exact){
			str = '^' + str + '$';
		}

		if (args.return === 'string'){
			return str;
		}else{
			return new RegExp(str, (args.global ? 'g' : '') + (args.case ? '' : 'i'))
		}
	};
	
	/**
	 * Parse a string,array,object and try replacing the "prefix" with the alias string.
	 * @alias utils.toAlias
	 * 
	 * @example
	 * utils.toAlias('&--name', 'red');
	 * // "red--name"
	 * 
	 * utils.toAlias('&--name', 'red', true);
	 * // ".red--name"
	 * 
	 * utils.toAlias(['&--name', '&--value'], 'red');
	 * // ["red--name", "red--value"]
	 * 
	 * utils.toAlias({'&--name' : true}, 'red');
	 * // {"red--name": true}
	 * 
	 * @param {*} 		obj 				Object to add the alias too
	 * @param {string} 	alias 				String that will replace the "prefix"
	 * @param {*} 		[args] 
	 * @param {string} 	args.prefix="&"		Prefix to find in the object
	 * @param {boolean} args.classname 		The alias is a classname, so add the "." before
	 * 
	 * @returns {*}
	 */
	this.toAlias = function (obj, alias, args){
		if (!alias) return obj;

		if (args === true){
			args = {'classname':true};
		}

		args           = args || {};
		args.prefix    = args.prefix || '&';
		args.classname = args.classname || false;

		if (args.classname){
			alias = '.' + alias;
		}

		var re = _.toRegExp(args.prefix, true);

		function _alias (v){ 
			if (_.is.str(v)){
				return v.replace(/(^|[\s"'.\()])\&/g, '$1' + alias);
			}else{
				return v;
			}
		};
		
		if (_.is.arr(obj)){
			for (var i=0, l=obj.length;i<l;++i){
				obj[i] = _alias(obj[i]);
			}
		}else if (_.is.obj(obj, true)){
			var all = {};
			var i, k, v;
			for (i in obj){
				k = _alias(i);
				v = _alias(obj[i]);
				all[k]= v;
			}
			obj = all;
		}else{
			obj = _alias(obj);
		}

		return obj;
	};

	/**
	 * Convert a value/array into 4. A great shortcuts for padding/margin values (eg.: top, right, bottom, left).
	 * @alias utils.to4Values
	 * 
	 * @example
	 * utils.to4Values('45');
	 * // ['45', '45', '45', '45']
	 * 
	 * utils.to4Values('5, 10.5, 1');
	 * // ['5', '10.5', '1', '10.5']
	 * 
	 * utils.to4Values('50x150');
	 * // ['50', '150', '50', '150']
	 * 
	 * utils.to4Values('true bob', ':value');
	 * // [true, 'bob', true, 'bob']
	 * 
	 * @param {*} 			arr				
	 * @param {*} 			[args]			:number / :value / {string} separator / {function} filter
	 * @param {string} 		args.separator 	String separator for text value
	 * @param {function} 	args.filter 	Filter the values 
	 * @param {*} 			args.fallback 	If the value doens't exists, use this fallback
	 * 
	 * @return {array}
	 */
	this.to4Values = function (arr, args, only2){
		if (args === ':number'){
			args = {'filter':function (v){ 
				// make sure it's always a number (0 by default)
				v = parseFloat(v); 
				return isNaN(v) ? 0 : v; 
			}};
		}else if (args === ':value'){
			args = {'filter':_.toValue};
		}else if (_.is.str(args)){
			args = {'separator':args};
		}else if (_.is.fn(args)){
			args = {'filter':args};
		}

		args            = args || {};
        args.separator  = args.separator || null;
        args.filter     = args.filter || null;
        args.fallback   = args.fallback || null;
		args.two 		= args.two || only2;

		// auto detect the separator
		if (_.is.str(arr) && !args.separator){
			if (~arr.indexOf(';')) 		args.separator = ';';
			else if (~arr.indexOf('x')) args.separator = 'x';
			else if (~arr.indexOf(',')) args.separator = ',';
			else 						args.separator = ' ';
		}

		function _val (options){
			var v = _.defined(options);
			if (_.is.fn(args.filter)) v = args.filter(v);
			if (_.is.invalid(v))      v = args.fallback;
			return v;
		}

		arr = _.toArray(arr, args.separator);

		return args.two ? [
			_val([arr[0]]),
			_val([arr[1], arr[0]]),
		] : [
			_val([arr[0]]),
			_val([arr[1], arr[0]]),
			_val([arr[2], arr[0]]),
			_val([arr[3], arr[1], arr[0]])
		]
	};

	this.toBounds = function (rect, args){
		args 		 = args || {};
		args.offsetX = 'offsetX' in args ? args.offsetX : 0;
		args.offsetY = 'offsetY' in args ? args.offsetY : 0;
		args.padding = 'padding' in args ? args.padding : null;
		args.margin  = 'margin' in args ? args.margin : null;
		
		var p;
		if (args.margin){
			p = _.to4Values(args.margin || 0, 'number').map(function (v){ return -v; });
		}else if (args.padding){
			p = _.to4Values(args.padding || 0, 'number');
		}else{
            p = [0,0,0,0];
        }

		var x = 0;
		var y = 0;
		var w = 0;
		var h = 0;

		if (rect instanceof Array){
			x = rect[0] || 0;
			y = rect[1] || 0;
			w = rect[2] || 0;
			h = rect[3] || 0;
		}else if (typeof rect === 'object'){
			if ('x' in rect) 			x = rect.x;
			else if ('x1' in rect) 		x = rect.x1;
			else if ('left' in rect) 	x = rect.left;

			if ('y' in rect) 			y = rect.y;
			else if ('y1' in rect) 		y = rect.y1;
			else if ('top' in rect) 	y = rect.top;
			
			if ('w' in rect) 			w = rect.w;
			else if ('width' in rect)	w = rect.width;
			else if ('x2' in rect) 		w = rect.x2 - x;
			else if ('right' in rect) 	w = rect.right - x;

			if ('h' in rect) 			h = rect.h;
			else if ('height' in rect)	h = rect.height;
			else if ('y2' in rect) 		h = rect.y2 - y;
			else if ('bottom' in rect) 	h = rect.bottom - y;
			
			// radius for circles
			if ('radius' in rect){
				x -= rect.radius;
				y -= rect.radius;
				w = rect.radius * 2;
				h = rect.radius * 2;
			}
		}

		x = (isFinite(x) ? x : 0) + p[3] + args.offsetX;
		y = (isFinite(y) ? y : 0) + p[0] + args.offsetY;
		w = (isFinite(w) ? w : 0) - (p[3] + p[1]);
		h = (isFinite(h) ? h : 0) - (p[0] + p[2]);

		// make sure the height/width are not negative
		if (h < 0) h = 0;
		if (w < 0) w = 0;
		
		return {
			'top'	 : y,
			'right'	 : x + w,
			'bottom' : y + h,
			'left'   : x,
			'x'		 : x,
			'y'		 : y,
			'w'		 : w,
			'h'		 : h,
			'width'	 : w,
			'height' : h,
			'center' :{
				'x': x + (w / 2),
				'y': y + (h / 2)
			}
		};
	};

	/**
	 * Simple class creation with a specific name.
	 * @alias utils.toClass
	 * 
	 * @example
	 * var Person = utils.toClass('Person');
	 * var p 	  = new Person();
	 * // Person {}
	 * 
	 * var proto  = {'name':'John', 'list':['a', 'b', 'c']};
	 * var Person = utils.toClass('Person', proto);
	 * 
	 * a = new Person();
	 * a.list.push('d');
	 * // Person {list: ['a', 'b', 'c', 'd']}
	 * 
	 * b = new Person();
	 * // Person {list: ['a', 'b', 'c']}
	 * 
	 * var List = utils.toClass('List', Array, {
	 * 	'push':function (v){ this.$super(v); }
	 * });
	 * var l = new List();
	 * l.push(123);
	 * // List[123]
	 * 
	 * @param {string} 		name		Name of the class
	 * @param {object} 		[extend] 	Extended constructor
	 * @param {object} 		[proto] 	Prototype object/function
	 * 
	 * @return {function}
	 */
	this.toClassOld = function (args, Definition){
		if (_.is.fn(args)){
			Definition = [args, args = Definition][0]; // doing a little switcharoo
		}else if (_.is.str(args)){
			args = {'name':args};
		}

		args         = args || {};
		args.name    = args.name || null;
		args.extend  = args.extend || null;
		args.base    = args.base || null                // default class needed
		
		args.param   = args.param || null;              // data used as the 2nd attribute when using a function
		args.proto   = _.$arr(args.proto || [], true);  // Move objects to the proto objects

		args.prepare = args.prepage || null;
		args.preInit = args.preInit || null;
		args.postInit= args.postInit || null;
		
		// have a way to prepare the object (like)
		// args.prepare= function (){};

		// Maybe, not delete anything with "$...", so it's available to other function (like API)

		// helpers -------------------------------------------------------------
		function _initializing (v){
			if (_.is.bool(v)) CONSTS.INITIALIZING = v;
			return CONSTS.INITIALIZING;
		};

		function _instance (v){
			if (_.is.fn(v)){
				_initializing(false);
				v = new v();
				_initializing(true);
			}
			return v;
		};

		function _toProto (v){
			if (_.is.fn(v)){
				v.prototype.$static = {};
				v.prototype.$get    = {};  // getters
				v.prototype.$set    = {};  // setters
				v.prototype.$       = {};  // cache object
				v 					= new v(_, args.param);
			}
			return v;
		};

		// setup ---------------------------------------------------------------
		var name = Definition.name || args.name || _.random('Class');
		Definition = _toProto(Definition);
		
		var $vars    = Definition.$ || {};
		var $setters = Definition.$set || {};
		var $getters = Definition.$get || {};
		var $static  = Definition.$static || {};
		
		var $base 	 = args.base || null;
		var $extend  = Definition.$extend || args.extend || null;
		
		delete(Definition.$set);
		delete(Definition.$get);
		delete(Definition.$static);		
		delete(Definition.__proto__.$set);
		delete(Definition.__proto__.$get);
		delete(Definition.__proto__.$static);

		// extend --------------------------------------------------------------
		var Base   = _toProto($base);
		var Extend = _.is.fn($extend) ? $extend.prototype : $extend;
		var types  = (Extend ? (Extend.types || []) : []).concat(name);

		// add the getter/setter
		if (Base){
			$setters = _.extend(Base.$set || {}, $setters);
			$getters = _.extend(Base.$get || {}, $getters);
		}

		// Default to Base since there's no Extend
		if (Base && !Extend){
			$extend = Base;
		// Merge the Base and Extend together (the extend needs to be merged)
		}else if (
			Extend 
			&& Base 
			&& !Base.isPrototypeOf(Extend)
			&& Extend.$base !== Base
		){
			$extend       = _instance($extend);
			$extend       = _.extend(true, {}, $extend, Base);
			$extend.$base = $base;
		}

		var Extend = $extend;
		if (!_.is.fn(Extend)){
			Extend 			 = function Extend (){};
			Extend.prototype = $extend || {};
		}

		// merge extend $static with the current one
		if (Extend.prototype.$static){
			$static = _.obj.mergeOld({}, [Extend.prototype.$static, $static]);
		}
		
		// init ----------------------------------------------------------------
		var defaults  = {};
		var prototype = _instance(Extend);
		
		// props ---------------------------------------------------------------
		var i, v;
		// get the "object/array" from the prototype
		for (i in prototype){
			v = prototype[i];
			if (_.is.obj(v, true) || _.is.arr(v, true)){
				defaults[i] = v;
			}
		}
	
		// merge the definition values to default (and prototype if the value isn't an array/object)
		_.obj.mergeOld(defaults, Definition, {
			'proto' : prototype,
		});

		// move the '$' from defaults to proto
		for (var i in defaults){
			if (i === '$' || i[0] !== '$') continue;
			prototype[i] = defaults[i];
			delete(defaults[i]);
		}

		// getter/setter -------------------------------------------------------
		// automatic getter/setter (uses _.$arr so the "i" and "v" are consistent)
		_.$arr($vars, {'ctx':this}, function (v, i){
			if (v === undefined) return;
			if (!(i in $setters)){
				$setters[i] = function (vv){ this.$[i] = vv; };
			}
			if (!(i in $getters)){
				$getters[i] = function (){ return this.$[i]; };
			}
		});
		
		// setters
		for (i in $setters){
			var get = $getters[i] || _.fn.empty;
			var set = $setters[i];
			if (_.is.fn(Definition[i])) continue;
			_.obj.prop(prototype, i, get, set);
		}		
		// getters
		for (i in $getters){
			// if the this already exists in setters, it's been already set
			if (i in $setters || _.is.fn(Definition[i])) continue;
			var get = $getters[i];
			var set = _.fn.empty;
			_.obj.prop(prototype, i, get, set);
		}

		_.call(args.setup, [prototype, defaults]);

		// create --------------------------------------------------------------
		function _init (){
			_.extend(true, this, defaults);
			
			if (!_initializing()) return;
			var args       = _.$arr(arguments);
			var $wait      = this.$wait;    
			var $preload   = this.$preload; 
			var $init	   = __init.bind(this, args);

			if ($wait === true){
				_.fn.request($init);
			}else if ($wait){
				var time = _.toDuration($wait);
				setTimeout($init, time);
			}else if ($preload){
				_.apply.ctx(this, $preload, [$init]);
			}else{
				return $init();
			}

			return this;
		};

		function __init (params){
			var $preInits  = this.$static.$preInits || [];
			var $postInits = this.$static.$postInits || [];
			
			// pre-inits -------------------------------------------------------
			_.apply.ctx(this, args.preInit, params);
			for (var i in $preInits) _.apply.ctx(this, $preInits[i], params); 
			var response = _.apply.ctx(this, this.preInit, params, {'fallback':null});

			if (_.is.arr(response)){
				params = response;
			}
			
			// init ------------------------------------------------------------
			var response = _.apply.ctx(this, this.init, params, {'fallback':null});

			// post inits ------------------------------------------------------
			_.apply.ctx(this, args.postInit, params);
			for (var i in $postInits) _.apply.ctx(this, $postInits[i], params);
			_.apply.ctx(this, this.postInit, params);			

			return _.is.def(response) ? response : this;
		};

		// create a new Class with the option of calling NEW with the arguments
		var $create = '\
			var WAIT = false;\
			function INIT (ctx, args)		{ (!WAIT && $init.apply(ctx, args)); }\
			function __CLASS__()		 	{ INIT(this, arguments); return this; }\
			__CLASS__.$new = function (args){ \
				WAIT = true; var obj = new __CLASS__(); WAIT = false;\
				INIT(obj, args);\
				return obj;\
			};\
			return __CLASS__;\
		'.replace(/__CLASS__/g, name);

		var klass 					= new Function('$init', $create)(_init);
		klass.prototype             = prototype;
		klass.prototype.constructor = klass;
		klass.prototype.$static     = klass; // to access the $static
		
		klass.$preInits      		= [];
		klass.$postInits     		= [];

		// static --------------------------------------------------------------
		$static.types = types;
		$static.slug  = _.toSlug(name);

		for (var i in $static){
			klass[i] = $static[i];
		}

		return klass;
	};

	function _isInitializing (v){
		// temporarily skip the init() to call a Class
		if (_.is.fn(v)){
			var o = CONSTS.INITIALIZING;
			CONSTS.INITIALIZING = false;
			var r = v();
			CONSTS.INITIALIZING = true;
			return r;
		}else if (_.is.bool(v)){
			CONSTS.INITIALIZING = v;
		}else{
			return CONSTS.INITIALIZING;
		}
	};

	this.toProto = function (cls, param){
		if (_.is.fn(cls)){
			var p = cls.prototype;

			p.$static = p.$static || {};
			p.$get    = p.$get || {};
			p.$set    = p.$set || {};
			p.$       = p.$ || {};

			_isInitializing(function (){
				cls = new cls(_, param);
			});
		}
		return cls;
	};
	
	// new version of toClass
	this.toClass = function (args, Definition){
		if (_.is.fn(args)){
			Definition = [args, args = Definition][0]; // doing a little switcharoo
		}else if (_.is.str(args)){
			args = {'name':args};
		}

		args         = args || {};
		args.name    = args.name || null;
		args.extend  = args.extend || null;
		args.base    = args.base || null                // default class needed
		
		args.param   = args.param || null;              // data used as the 2nd attribute when using a function
		args.proto   = _.$arr(args.proto || [], true);  // Move objects to the proto objects

		args.setup    = args.setup || null;
		args.prepare  = args.prepage || null;   // TODO have a way to prepare the object (like)
		args.preInit  = args.preInit || null;
		args.postInit = args.postInit || null;

		// TODO args.setup, prepare, preInit, ... should be saved in the $static maybe, so it's always executed
		
		// helpers -------------------------------------------------------------
		function _instance (v){
			_.is.fn(v) && _isInitializing(function (){ v = new v(); });
			return v;
		};

		// setup ---------------------------------------------------------------
		var name = Definition.name || args.name || _.random('Class');
		
		Definition = _.toProto(Definition, args.param);
		
		var $setters = Definition.$set || {};
		var $getters = Definition.$get || {};
		var $static  = Definition.$static || {};
		
		var $base 	 = args.base || null;
		var $extend  = Definition.$extend || args.extend || null;

		// extend --------------------------------------------------------------
		var Base   = _.toProto($base, args.param);
		var Extend = _.is.fn($extend) ? $extend.prototype : $extend;
		var $types = [];
		
		// Default to Base since there's no Extend
		if (Base && !Extend){
			$extend = Base;
		// Merge the Base and Extend together (the extend needs to be merged)
		}else if (
			Extend 
			&& Base 
			&& !Base.isPrototypeOf(Extend)
			&& Extend.$base !== Base
		){
			$extend       = _instance($extend);
			$extend       = _.extend(true, $extend, Base);
			$extend.$base = $base;
		// Clear the Base, since it's already used
		}else{
			Base = null;
		}

		// add the getter/setter (if the Base is added)
		if (Base){
			$setters = _.extend({}, Base.$set || {}, $setters);
			$getters = _.extend({}, Base.$get || {}, $getters);
		}

		var Extend = $extend;
		if (!_.is.fn(Extend)){
			Extend 			 = function Extend (){};
			Extend.prototype = $extend || {};
		}
	
		// merge extend $static with the current one
		if (Extend.prototype.$static){
			$static = _.obj.merge({}, [Extend.prototype.$static, $static]);
		}

		var $types  = (Extend.types || []).concat(name);
		var $setups = (Extend.$setups || []);

		if (args.setup && !~$setups.indexOf(args.setup)){
			$setups.push(args.setup);
		}
		
		// _.call(Definition.$onPreSetup, [Definition]);

		// props/proto ---------------------------------------------------------
		var prototype = _instance(Extend);
		var defaults  = {};

		// Merge the Definition properties to the new Extend instance
		prototype = _.obj.merge(prototype, Definition);

		// move some objects/array to the default
		for (var i in prototype){
			var v = prototype[i];

			// skip anything that starts with "$" but isn't just "$". We use "$" as a default data holder
			if (i[0] === '$' && i !== '$') continue;

			// skip none object and specified args.proto indexes
			if (
				!_.is.obj(v, true) 
				&& !_.is.arr(v, true)
				&& !~args.proto.indexOf(i)
			) continue;

			defaults[i] = v;
		}
		
		var $vars = defaults.$ || {};
		
		// getter/setter -------------------------------------------------------
		// automatic getter/setter (uses _.$arr so the "i" and "v" are consistent)
		_.$arr($vars, {'ctx':this}, function (v, i){
			if (v === undefined) return;
			if (!(i in $setters)){
				$setters[i] = function (vv){ this.$[i] = vv; };
			}
			if (!(i in $getters)){
				$getters[i] = function (){ return this.$[i]; };
			}
		});
		
		// setters
		for (var i in $setters){
			var get = $getters[i] || _.fn.empty;
			var set = $setters[i];
			_.obj.prop(prototype, i, get, set);
		}		
		
		// getters only
		for (var i in $getters){
			// if the this already exists in setters, it's been already set
			if (i in $setters) continue;
			var get = $getters[i];
			var set = _.fn.empty;
			_.obj.prop(prototype, i, get, set);
		}
		
		
		// Finished setup
		_.call.ctx(prototype, prototype.$onSetupClass, [Extend.prototype, {
			'name'      : name,
			'defaults'  : defaults,
			'definition': Definition,
		}]);

		// [ ] have a way to modifiy some properties (like $style = string, and merge all the $style from Definition and Extend, ...)
		// _.call(Definition.$onPreSetup, [Definition]);
		
		// _.call.ctx(prototype, prototype.$onPreSetup, [Definition, Extend.prototype, name]);


		// create --------------------------------------------------------------
		var count     = 0;
		var firstInit = false;

		function _init (){
			// _.extend(true, this, defaults); // [ ] Test, should this be there?
			if (!_isInitializing()) return;

			if (!firstInit){
				firstInit = true;
				_.call.ctx(this, this.$onFirstInit);
			}

			// Add all the default obj/arr values
			_.extend(true, this, defaults);

			var args       = _.$arr(arguments);
			var $wait      = this.$wait;    
			var $preload   = this.$preload; 
			var $init	   = __init.bind(this, args);

			if ($wait === true){
				_.fn.request($init);
			}else if ($wait){
				var time = _.toDuration($wait);
				setTimeout($init, time);
			}else if ($preload){
				_.apply.ctx(this, $preload, [$init]);
			}else{
				return $init();
			}

			return this;
		};

		function __init (params){
			// var $preInits  = this.$static.$preInits || [];
			// var $postInits = this.$static.$postInits || [];
			
			// pre-inits -------------------------------------------------------
			_.apply.ctx(this, args.preInit, params);
			// for (var i in $preInits) _.apply.ctx(this, $preInits[i], params); 
			var response = _.apply.ctx(this, this.preInit, params, {'fallback':null});

			if (_.is.arr(response)){
				params = response;
			}
			
			// init ------------------------------------------------------------
			var response = _.apply.ctx(this, this.init, params, {'fallback':null});

			// post inits ------------------------------------------------------
			// for (var i in $postInits) _.apply.ctx(this, $postInits[i], params);
			_.apply.ctx(this, this.postInit, params);			
			_.apply.ctx(this, args.postInit, params);
			
			return _.is.def(response) ? response : this;
		};

		// create a new Class with the option of calling NEW with the arguments
		var $create = '\
			var WAIT = false;\
			function INIT (ctx, args){ (!WAIT && $init.apply(ctx, args)); }\
			function __CLASS__(){ INIT(this, arguments); return this; }\
			__CLASS__.$new = function (args){ \
				WAIT = true; var obj = new __CLASS__(); WAIT = false;\
				INIT(obj, args);\
				return obj;\
			};\
			return __CLASS__;\
		'.replace(/__CLASS__/g, name);

		var klass 					= new Function('$init', $create)(_init);
		klass.prototype             = prototype;
		klass.prototype.constructor = klass;
		klass.prototype.$static     = klass; // to access the $static
				
		// static --------------------------------------------------------------
		// $static.$preInits      		= [];
		// $static.$postInits     		= [];
		$static.types   = $types;
		$static.slug    = _.toSlug(name);
		
		for (var i in $static){
			klass[i] = $static[i];
		}
		
		_.call(prototype.$onPostSetup, [prototype, defaults]);

		return klass;
	};

    // logs ------------------------------------------------------------------------------------------------------------
    var _backtrace = window._backtrace = function (index){
		index = index === undefined ? 1 : index;
		
		var base   = (window.theme_settings || {});
		var host   = base.url || '';
		var script = base.scripts || '';
		var stack  = (new Error()).stack.split("\n").map(function (v){
			var v = v.match(/^(?:\s*at)?(.*?)?\@?(?:\(?(http.+))(?:\:(\d+))(?:\:(\d+))/);
			if (!v) return;
	
			var fn   = (v[1] || '').trim().replace('@', '');
			var path = (v[2] || '').trim().replace(script, '/').replace(host, '/').replace(/[?#].+$/, '').replace(/\/+/, '\/').replace('/http', 'http');
			var line = v[3];
			var msg  = path + (fn?' ['+fn+']':'') + ' [line ' + line + ']';
	
			return {
				'function': fn,
				'method'  : fn ? fn.split('.').pop() : '',
				'path'    : path,
				'line'    : +line,
				'message' : msg,
			};
		}).filter(function (v){ return !!v;});

		return stack.slice(index);
	};
	
	var _log = this._log = window._log = function (args, params){
		if (params === undefined){
			params = args;
			args   = {};
		}

		args                = args || {};
		args.file           = 'file' in args ? args.file : true;
		args.prefix         = 'prefix' in args ? args.prefix : '';
		args.prefixFunction = args.prefixFunction || false;
		args.title          = 'title' in args ? args.title : true;       // auto title if the 1st param is a string
		args.trim           = 'trim' in args ? args.trim : true;
		args.data           = 'data' in args ? args.data : null;         // auto title if the 1st param is a string
		args.color          = 'color' in args ? args.color : 'black';
		args.style          = 'style' in args ? args.style : '';
		args.once           = args.once || false;                        // TODO
		args.trace          = args.trace || false;                       // show the trace of the actions
		args.backtrace      = 'backtrace' in args ? args.backtrace : 3;

		params = _.$arr(params);
	
		var stack  = _backtrace(args.backtrace);
		var params = params || [];
		var prefix = args.prefix;
		var title  = args.title;
		var file   = stack[0];
		var iframe = window.parent !== window;

		if (args.trace){
			title = '';
			// TODO a better "stack" visual
			console.log(stack);
		}else{
			var has_title = (params.length >= 1 && _.is.str(params[0])); 
							// || (params.length == 1 && utils.is.either(params[0], 'str,nbr,bool'));
	
			if (title === true && has_title){
				title = params.shift().toString();
			}else if (title === true){
				title = '';
			}
		}

		if (title && args.data){
			title = _.str.replace(title, args.data);
		}

		if (args.prefixFunction && file && file.method){
			prefix += '.' + file.method + '()';
		}

		// TODO simplify this code, maybe mix (item + color, then create arguments)

		// file = file ? file.path + (iframe?' [iframe]':'') + (file.function?' ['+file.function+']':'') + ' [line ' + file.line + ']' : '';
		
		var file_str 	 = args.file && file ? file.path + (iframe?' [iframe]':'') + (file.function?' ['+file.function+']':'') + ' [line ' + file.line + ']' : '';
		var prefix_style = "background:"+args.color+"; color:white; border-radius:2px; font-weight:bold; font-size:10px; padding:.25em .7em .3em;";
		var file_style   = "font-size:10px; color:#999; margin-bottom:3px;";
		var title_style  = "margin-top:.25em; color:"+args.color+"; font-weight:bold;" + (args.style ? ' ' + args.style : '');
		var log 		 = args.trace ? console.warn : console.log;
		var first 	     = title || file_str ? '' : params.pop();

		if (first === undefined){
			first = '';
		}
		
		if (prefix && file_str && title){
			log('%c'+file_str+'\n%c'+prefix+'%c '+title, file_style, prefix_style, title_style, first);
		}else if (prefix && title){
			log('%c'+prefix+'%c '+title, prefix_style, title_style, first);
		}else if (title){
			log('%c'+title, title_style, first);
		}else if (prefix && file_str){
			log('%c'+prefix+'%c '+file_str, prefix_style, file_style, first);
		}else if (prefix){
			log('%c'+prefix, prefix_style, first);
		}else if (file_str){
			log('%c'+file_str, file_style, first);
		}else if (typeof first !== 'object' && !params.length){
			log('%c'+first, title_style);
		}else{
			params = [first].concat(params);
		}
		
		if (params.length){
			console.log.apply(null, params);
		}
	};

	window.__js = function (){
		// TODO, need to show this code where it's been called
		_log({'file':false}, arguments);
	};

	window._js = function (){
		_log({'prefix':'LOG'}, arguments);
	};

	window._p = function (){
		console.clear();
		_log({'prefix':'LOG', 'file':false}, arguments);
	};

	window._warn = function (){
		_log({
			'prefix' : 'WARN',
			'color'	 : '#f58303',
		}, arguments);
	};

	window._err = function (){
		_log({
			'prefix' : 'ERROR',
			'color'	 : 'red',
		}, arguments);
	};

	window._info = function (){
		_log({
			'prefix' : 'INFO',
			'color'	 : '#cbcbcb',
			'style'  : 'color:#cbcbcb;',
		}, arguments);
	};

	window._trace = function (){
		_log({
			'prefix': 'TRACE',
			'color' : '#ea9f4b',
			'trace' : true,
		}, arguments);
	};

	window._debug = function (ctx, msg, trace){
		if (msg === undefined){
			msg = ctx;
			ctx = '*';
		}

		if (msg === FFTO.START || msg === FFTO.STOP){
			CONSTS.LOGS.DEBUG[ctx] = (msg === FFTO.START);
			return;
		}

		if (CONSTS.LOGS.DEBUG[ctx]){
			trace ? console.trace(msg) : console.log(msg);
		}
	};

	this.log = function (msg, data, params){
		msg = _.str.replace(msg, data);
		_log(msg, params);
	};

	this.warn = function (msg, data, params){
		msg = _.str.replace(msg, data);
		_warn(msg, params);
	};

	this.err = function (msg, data, params){
		msg = _.str.replace(msg, data);
		_err(msg, params);
	};

    this.deprecated = function (msg, alt){
		if (alt){
            msg = '[DEPRECATED] "'+msg+'" is deprecated, use "'+alt+'" instead';
		}else{
			msg = '[DEPRECATED] '+msg;
		}
        this.warn(msg);
	};

	this.toLog = function (prefix, color){
		return function (){
			_log({
				'prefix' : prefix,
				'color'	 : color,
			}, arguments);
		}
	};

	this.time = window.__time = function (key, args, log){
		if (_.is.bool(key)){
			args = key;
			key  = '*';
		}
		if (_.is.bool(args)){
			args = {'reset':true};
		}else if (_.is.str(args)){
			args = {'text':args};
		}

		args       = args || {};
		args.reset = args.reset || false;
		args.text  = args.text || '';
		args.log   = log || args.log || false;

		var now  = Date.now();
		var start= args.reset ? 0 : (CONSTS.TIMERS[key] || 0);
		var time = start ? (now - start) / 1000 : 0; // in seconds
		var reset= args.reset || !start;

		if (time < 0.0001){
			time = '0s';
		}else{
			time = time + 's';
		}

		CONSTS.TIMERS[key] = now;

		if (!reset && args.log){
			var log = key && key !== '*'  ? key : '';

			if (args.text){
				log = log ? log+': '+args.text : args.text; 
			}

			log = log ? ' ' + log : '';
			log = '[' + _.str.pad(time, ' ', 10, 'right') + ']' + log;

			_log({
				'prefix': 'Timer',
				'color' : '#0c28af',
				'file'	: false,
			}, [log]);
		}

		return time;
	};

	window._time = function (key, args){
		_.time(key, args, true);
	};

	/**
	 * Test a callback many times and return the time it took. Perfect for testing performances.
	 * @alias utils.test
	 * 
	 * @param {number} 		times 
	 * @param {function} 	callback 
	 */
	this.test = function (callback, count){
		var start = +new Date();
		
		count = count || 1;
		for (var i=0;i<count; ++i) callback();

		var time = (+new Date()) - start;
		var text = (time/1000) + 's' + (count > 1 ? ' [x'+count+']' : '');
		
		_log({
			'prefix' : 'TEST',
		}, text);
	};

    // extra -----------------------------------------------------------------------------------------------------------
	this.add = function (namespace, callback){
		if (callback === undefined){
			callback  = namespace;
			namespace = null;
		}

		var obj  = this;
		var cName= null;
		if (namespace){
			namespace = namespace.split('.');

			var i, name;
			for (i in namespace){
				name = namespace[i];
				obj  = (obj[name] = obj[name] || {});
			}

			cName = namespace.join('_').toUpperCase();
		}

		if (_.is.obj(callback)){
			var i;
			for (i in callback){
				obj[i] = callback[i];
			}
		}else if (_.is.fn(callback)){
			var $consts = CONSTS;

			// create a static constant holder for the new group
			if (cName){
				$consts = CONSTS[cName] = CONSTS[cName] || {};
			}

			callback.apply(obj, [$consts, CONSTS, CONSTS.RE, this, $win, $doc]);
		}
	};

	// info
	window.site = window.site || {};
	var v = 'v' + FFTO.VERSION;
	if (window.site.js){
		window.site.js = [window.site.js, v];
	}else{
		window.site.js = v;
	}
}(window, document));

// Alias namespaces
var namespace = window.FFTO_NAMESPACE || window.NAMESPACE || 'Website';
window[namespace] = FFTO;
window._          = window._ || FFTO.Utils;
window._.v2       = FFTO.Utils;

// console.log('V2.A');
FFTO.Utils.add('str', function (STR, CONSTS, RE, _){
    STR.REPLACE = {};

	/**
	 * Split a string with different types of separator (string, number, regex). 
	 * 
	 * @memberof utils.str
	 * @function split
	 * 
	 * @example
	 * utils.str.split('John Doe');
	 * // ['J', 'o', 'h', 'n', ' ', 'D', 'o', 'e']
	 * 
	 * utils.str.split('John Doe', 3);
	 * // ['Joh', 'n D', 'oe']
	 * 
	 * utils.str.split('a,b,c', ',')
	 * // ['a', 'b', 'c']
	 * 
	 * utils.str.split('a + b + c', '+', true);
	 * // ['a', '+', 'b', '+', 'c']
	 * 
	 * utils.str.split('a + bbb - ccccc * ddddddd', /[\+\-\*]/g)
	 * // ['a', 'bbb', 'ccccc', 'ddddddd']
	 * 
	 * utils.str.split('a + bbb - ccccc * ddddddd', /[\+\-\*]/g, true);
	 * // ['a', '+', 'bbb', '-', 'ccccc', '*', 'ddddddd']
	 * 
	 * 
	 * @param {string} 				str 			Value to split
	 * @param {*} 					[separator=1]	Either a string, a number or a RegExp	
	 * @param {object} 				[args] 
	 * @param {boolean} 			args.trim=true 	Trim the string values
	 * @param {boolean} 			args.all		Keep the separator in the results
	 * @param {boolean|function} 	args.filter		Filter empty values OR call the filter callback to change the value
	 * 
	 * @returns {array}
	 */
	this.split = function (str, separator, args){
		if (_.is.bool(args)){
			args = {'all':args};
		}
        
        separator   = separator === undefined ? 1 : separator;

		args        = args || {};
		args.trim   = 'trim' in args ? args.trim : true;
		args.all    = 'all' in args ? args.all : false;  
		args.filter = args.filter || null;
		
        var isNbr = _.is.nbr(separator);
        separator = isNbr ? new RegExp('.{1,'+separator+'}', 'g') : separator;
        
		var isRegExp = !isNbr && separator instanceof RegExp;
		var arr = [];
        if (_.is.fn(separator)){
            arr = _.apply(separator, [str]);
        }else if (_.is.str(separator)){
			arr = str.split(separator);

			if (args.all){
				var list = [];
				_.each(arr, {'trim':false}, function (v, i){
					if (i) list.push(separator);
					list.push(v);
				});
				arr = list;
			}
		}else if (isNbr){
			arr = str.match(separator);
            arr = _.toArray(arr, {'force':true});
		}else if (isRegExp){
			var seps = [];
			arr = str.replace(separator, function (v){
				seps.push(v);
				return FFTO.KEY;
			}).split(FFTO.KEY);

			if (args.all){
				var list = [];
				_.each(arr, {'trim':false}, function (v, i){
					var s = seps[i];
					if (v){
						v = _.apply(args.filter, [v, false]);
						if (_.is.def(v)) list.push(v);
					}
					if (s){
						v = _.apply(args.filter, [s, true]);
						if (_.is.def(v)) list.push(s);
					}
				});
				arr = list;
			}else{
				isRegExp = false;
			}
		}

		if (args.filter && !isRegExp){
			arr = _.each.filter(arr, args.filter);
		}

		if (args.trim){
			arr = _.trim(arr);
		}

		return arr || [];
	};

    /**
	 * Parse a string and return an object. The args adapts to string|array|function
	 * 
	 * @memberof utils.str
	 * @function parse
	 * 
	 * @example 
	 * utils.str.parse('a=1&b=2&c=3'); 	
	 * // {a: 1, b: 2, c: 3}
	 * 
	 * utils.str.parse('a=1;b=99', ';');							
	 * // {a: 1, b: 99}
	 * 
	 * utils.str.parse('{background:white; color:black;}', 'style'); 	
	 * // {background: 'white', color: 'black'}
	 * 
	 * utils.str.parse('key="value" key2="value2"', 'attrs') 		
	 * // {key: 'value', key2: 'value2'}
	 * 
	 * @param {*} 			str 					
	 * @param {object} 		[args]					Argument options 
	 * @param {string} 		args.separator='&'		String that separates pairs
	 * @param {string} 		args.pair='='			String that separates a pair key/value
	 * @param {function} 	args.callback			Function called on each pair 
	 * @param {boolean} 	args.clean=true			Cleanup string values by remove wrapping apostrophe (if they are there)
	 * 
	 * @returns {object}
	 */
    this.parse = function (str, args, data){
		if (_.is.str(str) && args === 'css'){
			var css = data || {};
			str = str.replace(RE.CSS_COMMENTS, '');

			str.replace(RE.CSS_BLOCKS, function (m, $1, $2){
				var key = $1.trim();
				css[key] = _.str.parse($2, 'style');
			});

			return css;
		}
		
		if (_.is.str(str) && args === 'selector'){
			var path     = str.match(RE.CSS_SELECTOR_ITEMS);
			var selector = data || {};
			var i, l, v, p;

			for (i=0, l=path.length; i<l; ++i){
				v = path[i];
				p = v[0];

				if (p === '#'){
					selector.id = v.slice(1);
				}else if (p === '.'){
					selector.class = selector.class || [];
					selector.class.push(v.slice(1));
				}else if (p === '='){
					selector.html = v.slice(1);
				}else if (p === '{'){
					v = _.str.parse(v, 'style');
					selector.style = selector.style || {};
					selector.style = _.extend(selector.style, v);
				}else if (p === '['){
					v = _.str.parse(v, 'attrs');
					selector.attrs = selector.attrs || {};
					selector.attrs = _.extend(selector.attrs, v);
				}else if (p === ':'){
					var pair   = v.slice(1).replace(')', '').split('(');
					v 		   = {};
					v[pair[0]] = _.toValue(pair[1] || true);
					selector.states = selector.states || {};
					selector.states = _.extend(selector.states, v);
				}else{
					selector.tag = v;
				}
			}
			
			return selector;
		}

        if (args === 'style'){
            args = {'join':';', 'pair':':', 'prefix':'{', 'suffix':'}'};
        }else if (args === 'attributes' || args === 'attrs'){
            args = {'join':' ', 'pair':'=', 'prefix':'[', 'suffix':']'};
        }else if (args === 'query'){
            args = {'join':'&', 'pair':'=', 'callback':function (v, i, d){
				_.set(data, i, v);
				return;
			}};
        }else if (_.is.str(args)){
			args = {'join':args};
		}else if (_.is.arr(args)){
			args = {'join':args[0], 'pair':args[1]};
		}else if (_.is.fn(args)){
			args = {'callback':args};
		}

        args          = args || {};
        args.join     = args.join || args.separator || '&';
        args.pair     = args.pair || '=';
        args.prefix   = args.prefix || '';
        args.suffix   = args.suffix || '';
        args.callback = args.callback || null;

        var data = {};
		if (_.is.str(str)){
            str = str.replace(args.prefix, '').replace(args.suffix, '').trim();
	        str = _.str.split(str, args.join);

            for (var i=0, l=str.length; i<l; ++i){
                var v = str[i].trim();
                if (!v) continue;

                var pair = v.split(args.pair);
                try{
					var key      = pair[0].trim();
					var value    = _.toValue(pair[1]);
					var response = _.apply(args.callback, [value, key, data], {'fallback':undefined});

					if (response !== undefined){
                    	data[key] = response;
					}
                }catch (e){}
            }
		}else if (_.is.obj(str, true)){
			data = str;

			if (_.is.fn(args.callback)){
				for (var i in data){
                    var v = data[i];
					data[i] = _.apply(args.callback, [v, i]);
				}
			}
		}

		return data;
    };

	/**
	 * Repeat a string 
	 * 
	 * @memberof utils.str
	 * @function repeat
	 * 
	 * @param {string} str		Value to repeat
	 * @param {number} count	Number of time to repeat the value
	 * 
	 * @return {string}
	 */
    this.repeat = function (str, count){
		if (typeof count !== 'number' || count < 0) return '';
		return new Array((count+1) | 0).join(str.toString());
    };

	/**
	 * Pad a string with a string value
	 * 
	 * @memberof utils.str
	 * @function pad
	 * 
	 * @param {string} 			str				Value to pad
	 * @param {string} 			pad				Value to use as padding
	 * @param {object} 			[args]			
	 * @param {number} 			args.length		0 = will use the pad length
	 * @param {number|string} 	args.offset		Position in the padded text [left, right, center, Number]
	 * @param {string} 			args.padding	Padding text around the text
	 * @param {string} 			[offset]		Where the padding should be done [left, center, right]
	 * 
	 * @return {string}
	 */
    this.pad = function (str, pad, args, offset){
        str = _.is(str) ? str.toString() : '';

		if (_.is.nbr(args)){
			args = {'length':args};
		}else if (_.is.str(args)){
			args = {'padding':args};
		}

		args         = args || {};
		args.length  = 'length' in args ? args.length : 0;                  
		args.offset  = 'offset' in args ? args.offset : (offset || 'right');
		args.padding = args.padding || '';                                 

		if (args.length){
			pad = _.str.repeat(pad, args.length);
		}else{
			args.length = pad.length;
		}

		var p = 0;
		if (args.padding){
			str = args.padding + str + args.padding;
			pad = args.padding + pad + args.padding;
			p 	= args.padding.length;
		}

		var sLength = str.length;
		var pLength = pad.length
		var length  = pLength - sLength;
		var offset  = 0;

		if (args.offset === 'right') 		offset = 0;
		else if (args.offset === 'center')	offset = length/2 | 0;
		else if (args.offset === 'left')	offset = length;
		else 							 	offset = args.offset;

		str = pad.substring(0, offset) + str + pad.substring(offset + sLength);
		str = str.substring(0, pLength);

		if (p){
			str = str.substring(p, str.length - p);
		}

		return str;
    };

	this.trim = function (str){
		if (!_.is.str(str)) return '';
		// return str.replace(/[\x{200B}-\x{200D}\x{FEFF}]/, '') // remove the "zero width character"
		str = str.replace(/(^\n\s*)|(\s*\n$)/g, '');	// remove beginning and end of line breaks
		str = str.replace(/\s*\n+\s*/g, "\n\n");		// more than 2 line break
		str = str.replace(/^(\s|\t)+|(\s|\t)+$/g, '');
		str = str.replace(/ {2,}/g, ' ');				// needs to be " " instead of "\s", for some reason it consider the "\n" too
		return str.trim();
	};
	
	/**
	 * Find variables in a string and replace them with values found in the data.
	 * 
	 * @memberof utils.str
	 * @function replace
	 * 
	 * @example
	 * var obj = {
     *     'name'  : 'John doe',
     *     'age'   : 38,
     *     'info'  : {'sex':'male', 'single': true},
     *     'childs': ['alex', 'bob', 'joe'],
     * };
	 * 
	 * utils.str.replace('Name "{ name }"', obj);
	 * // 'Name "John doe"'
	 * 
	 * utils.str.replace('Name "{ childs.1 }"', obj);
	 * // 'Name "bob"'
	 * 
	 * utils.str.replace('Name "{ ages }"', obj);
	 * // Age ""
	 * 
	 * utils.str.replace('Age "{ ages || age }"', obj);
	 * // Age "38"
	 * 
	 * utils.str.replace('Name "{ name :upper }"', obj, {'filters':{
     *     'upper' : function (v){ return v.toUpperCase(); }
     * }});
	 * // Name "JOHN DOE"
	 * 
	 * @param {string} 	str					String to parse the variables
	 * @param {object} 	data				Value to use as padding
	 * @param {object} 	[args]
	 * @param {string} 	args.suffix="{{"	Suffix for variables
	 * @param {string} 	args.prefix="}}"	Suffix for variables
	 * @param {string} 	args.affix=":"		Spearator for filters
	 * @param {object} 	args.filters		List of filters to use on the values
	 * @param {string} 	args.separator=""	If 'str' is an array, the values can be joined with this separator
	 * @param {*} 		args.fallback		If the value in the data isn't found, return this fallback
	 * 
	 * @return {string}
	 */
	this.replace = function (str, data, args){
		args     = args || {};
		args.var = 'var' in args ? args.var : /\$([a-z_-]+)/ig;
		
		// TODO change "var" to "match", to be more like ffto_string_replace() in PHP

		// TODO need to deal with {{ $index }} ans {{ $value }}, the args.var clean those, and it shouldn't

		// add variants for the variables (instead of prefix/suffix)
		if (_.is.str(str) && args.var){
			str = str.replace(args.var, '{{$1}}');
		}

		if (!_.is.str(str, '{{')) return str;
		
		data 		   = data || {};
        args.prefix    = args.prefix || '{{';	// TODO maybe rename prefix/suffix to " delimiters:['{{', '}}'] "
		args.suffix    = args.suffix || '}}';
		args.affix     = args.affix || ':';		
		args.filters   = args.filters || null;						 // list of filters for all strings
		args.separator = 'separator' in args ? args.separator : '';
		args.fallback  = 'fallback' in args ? args.fallback : '';
		args.array 	   = 'array' in args ? args.array : true;

		var key = args.prefix + args.affix + args.suffix;
		var RE  = STR.REPLACE[key];
		if (!RE){
			var p = '\\' + args.prefix.split('').join('\\');
			var a = '\\' + args.affix.split('').join('\\');
			var s = '\\' + args.suffix.split('').join('\\');

			RE = STR.REPLACE[key] = {
				VAR   : new RegExp(p+'\\s*([^'+s+a+']+)(?:'+a+'([^'+s+']*))?\\s*'+s, 'g'),
				IF    : new RegExp(p+'\\s*@if\\s+(!)?([^'+s+']+)\\s*'+s+'([\\s\\S]+?)'+p+'\\s*@endif\\s*'+s, 'gm'),
				PREFIX: new RegExp('((?:' + p + ')+)', 'g'),
				SUFFIX: new RegExp('((?:' + s + ')+)', 'g')
			};
		}

		// simplify the prefix/suffix if it's repeated
		str = str.replace(RE.PREFIX, args.prefix).replace(RE.SUFFIX, args.suffix);

		if (args.array && _.is.arr(data)){
			var values = [], i, l, v;
			for (i=0, l=data.length; i<l; ++i){
				// make sure the item is an obj (a shallow copy of the original if already an object)
				v = data[i];
				v = _.is.obj(v) ? _.copy(v) : {'value':v};

				// make sure index, value, $value, $index exists
				v.index  = 'index' in v ? v.index : i;
				v.value  = 'value' in v ? v.value : data[i];
				v.$value = data[i];
				v.$index = i;

				v = _.str.replace(str, v, args);
				values.push(v);
			}
			return values.join(args.separator);
		}else{
			// simple if(s)
			str = str.replace(RE.IF, function (match, isNot, key, content){
				isNot = isNot === '!' ? true : false;

				var value  = _.get(data, key);
				var isTrue = !!value;

				return isNot !== isTrue ? content : '';
			});

			// Variable replacement
			var values 	 = [];
			var isSingle = str.replace(RE.VAR, '') === '';

			str = str.replace(RE.VAR, function (m, text, filters){
				var v = _.get(data, text, args.fallback);

				if (!_.is.def(v)){
					v = args.prefix + text + args.suffix;
				}

				// filters
				if (args.filters && filters){
					filters.split(args.affix).forEach(function (f){
						f = _.toAction(f, {'ctx':data});
						
						if (f.name in args.filters){	
							v = _.apply(args.filters[f.name], [v].concat(f.params), {'ctx':data});
						}
					});
				}

				values.push(v);

				return v;
			});

			if (values.length === 1 && isSingle){
				str = values[0];
			}
		}

		return str;
	};
});
FFTO.Utils.add('nbr', function (NBR, CONSTS, RE, _){
    this.get = function (nbr, args){
        // TODO 
        return nbr;
    };

    // casting -----------------------------------------------------------------
    this.toTime = function (nbr){
		var isNegative = nbr < 0;

		nbr = Math.abs(nbr);

		var hours   = Math.floor(nbr / 3600);
		var minutes = Math.floor(nbr / 60 % 60);
		var seconds = Math.floor(nbr % 60);

		if (seconds < 10){
			seconds = '0' + seconds; 
		}
		if (hours && minutes < 10){
			minutes = '0' + minutes; 
		}

		return (isNegative ? '-' : '') + (hours ? hours + ":" : '') + minutes + ':' + seconds;  
	};

	this.toDuration = function (time){
		if (!_.is.nbr(time)){
			return time;
		}
		if (time === null || time === undefined){
			time = 1000;
		}
		return Math.round(time / 10)/100 + 's';
	};
});
FFTO.Utils.add('math', function (MATH, CONSTS, RE, _){
    this.clamp = function (nbr, min, max, priority){
		priority = priority || 'min';

		if (min === undefined && max === undefined){
			min = 0;
			max = 1;
		}
		if (max === undefined){
			max = min;
			min = 0;
		}

		if (
			typeof nbr !== 'number'
			|| isNaN(nbr)
			|| !isFinite(nbr)
		) return priority === 'max' ? max : min;

		if (priority === 'max'){
			return Math.min(Math.max(min, nbr), max);
		}else{
			return Math.max(Math.min(max, nbr), min);
		}
    };

	// linear interpolation
	this.lerp = this.ratio = function (from, to, ratio, easing){
		var value = null;
		var range = null;

		if (_.is.obj(from)){
			easing = ratio;
			ratio  = to;
			range  = from;
			from   = null;
			to     = null;
		}

		easing = _.easing(easing);
		ratio  = ratio || 0;
		ratio  = easing(ratio);
		
		// range of values (ex.: [0,1,1,1,0] OR {0:0, 0.2:1, 0.8:1, 0.9:0})
		if (range){
			var values = [];
			var isArray= range instanceof Array;
            var i, l, r, prev, next;

			for (i in range){
                r = parseFloat(i);
                r = isArray ? r / (range.length-1) : r;
				values.push({'ratio':r, 'value':range[i]});
			}

			if (values.length){
				values.sort(function (a, b){ 
                    return a.ratio - b.ratio; 
                });

				// make sure there's a 0 and 1 ratio
				if (values[0].ratio !== 0){
					values.unshift({'ratio':0, 'value':values[0].value});
				}
				var last = values.length-1;
				if (values[last].ratio !== 1){
					values.push({'ratio':1, 'value':values[last].value});
				}

				for (i=1, l=values.length; i<l; ++i){
					prev = values[i-1];
					next = values[i];

					// in between 2 values
					if (ratio >= prev.ratio && ratio < next.ratio){
						r     = (ratio - prev.ratio) / (next.ratio - prev.ratio);
						value = prev.value + (next.value - prev.value) * r;
						break;
					}else if (ratio < prev.ratio){
						value = prev.value;
						break;
					}else if (ratio >= next.ratio){
						value = next.value;
					}
				}
			}
		}else{
			from  = parseFloat(from);
			to    = parseFloat(to);
			value = from + (to - from) * ratio;
		}

		return value;
	};

	// move from a number to another by a value, can't get outside
	this.move = function (from, to, nbr){
		var diff = (to - from);
		
		// TODO add "nbr" minimum, so it never goes below a certain amount

		// need to make sure it's a positive by default
		nbr  = Math.abs(nbr);
		nbr *= diff < 0 ? -1 : 1;

		var value = from + nbr;
		
		// make sure it doesn't overflow
		if (Math.abs(nbr) > Math.abs(diff)){
			value = to;
		}

		return value;
	};

	this.loop = function (nbr, min, max){
		if (max === undefined){
			max = min;
			min = 0;
		}

		var value = nbr;
		var diff  = max - min;

		if (value < min){
			value = max + (((nbr+1) - min) % (diff+1));
		}else if (value > max){
			value = min + ((nbr - min) % (diff+1));
		}
		
		return value;
	};

    // casting -----------------------------------------------------------------
	this.toRatio = function (nbr, min, max, args){
		if (_.is.either(max, 'obj,bool')){
			args = max;
			max  = min;
			min  = 0;
		}
		if (_.is.bool(args)){
			args = {'contain':args};
		}

		args         = args || {};
		args.contain = args.contain || false;
		args.easing  = args.easing || false;

		if (max === undefined){
			max = min;
			min = 0;
		}

		if (args.contain){
			if (nbr < min){
				nbr = min;
			}else if (nbr > max){
				nbr = max;
			}
		}

		var r = (nbr - min) / (max - min);

		if (args.easing){
			r = _.ease(args.easing, r);
		}

		return r;
	};

	this.toRatios = function (items){
		if (_.is.obj(items, true)){
			// This doenst work if we give the items a string key,
			
			/*
			var count = items.count || 0;
			var wait  = items.wait || 0;
			var time  = items.time || 1;
			items = _.each(count, function (v, i){ 
				return {
					'time' : time,
					'delay': i ? wait: 0,
				};
			});
			*/
		}else if (_.is.nbr(items)){
			items = _.each(items, function (){ return 1; });
		}


		var total = 0;
		var items = _.each(items, function (v, i){
			if (typeof v === 'number'){
			 	v = {'time':v};
			}

			v.time  = v.time || 0;
			v.delay = v.delay || 0;
			v.from  = total + v.delay;
			v.to    = v.from + v.time;

			total = v.to;

			return v;
		});

		for (var i in items){
			items[i] = [
				items[i].from / total,	// from ratio
				items[i].to / total		// to ratio
			];
		}

		return items;
	};
});


FFTO.Utils.add('fn', function (FN, CONSTS, RE, _, $win, $doc){
	FN.WHEN_BANK = {};
	FN.TICKS     = {};

	/**
	 * Return empty function that return the first parameter
	 * 
	 * @memberof utils.fn
	 * @function empty
	 * 
	 * @param {*} v Value
	 * 
	 * @return {*}
	 */
	this.empty = function (v){ return v; };

	/**
	 * Check if a state is ready (true) and call the callback, if not ready, add it to a queue
	 * 
	 * @memberof utils.fn
	 * @function when
	 * 
	 * @example
	 * utils.fn.when('ready', function (){ console.log('Ok'); });
	 * setTimeout(function (){
	 * 	utils.fn.when('ready', true);
	 * 	// call the function and console.log('Ok')
	 * }, 1000);
	 * 
	 * @param {string} 			 	key 		State key to check
	 * @param {function|boolean} 	callback 	Add/call a callback OR make a state ready, which will call all the callbacks in queue
	 * @param {object} 				[data]		Data that holds all the states 
	 * @param {*} 					[ctx] 		Context to use on all callbacks
	 * 
	 * @returns {boolean|null}
	 */
	this.when = function (key, callback, bank, ctx){
		bank = bank || CONSTS.FN.WHEN_BANK;
		
		var value = bank[key]; 
		
		// call callbacks
		if (!_.is.valid(callback)){
			// when there's has been no callbacks and wasn't changed to true, the result is null
			if (value === true){
				return true;
			// array is a list of callbacks
			}else if (value === false || value instanceof Array){ 
				return false;
			}else{
				return null;
			}
		}

		var isDone = value === true;
		var e 	   = {'ctx':ctx};
		if (_.is.fn(callback)){
			if (isDone){
				_.apply(callback, [e], {'ctx':ctx});
			}else{
				value = _.is.arr(value) ? value : [];
				value.push(callback);
			}
		}else if (callback === true){
			var callbacks = _.is.arr(value) ? value : [];
			var i, l;

			// need to put at true value before doing the callbacks, if the callback try asking if the key is true
			bank[key] = true;

			for (i=0, l=callbacks.length;i<l;++i){
				_.apply(callbacks[i], [e], {'ctx':ctx});
			}

			value = true;
		}else if (callback === false){
			value = false;
		}
		
		bank[key] = value;

		return value;
	};

	this.when.ctx = function (ctx, bank){
		bank = bank || {};
		return function (key, callback, ctx2){
			return _.fn.when(key, callback, bank, ctx2 || ctx);
		}
	};

	/**
	 * Update a callback with a "this.$super" function that can call oldCallback.
	 * 
	 * @memberof utils.fn
	 * @function super
	 * 
	 * @example
	 * function a (v){ return v + '!'; }
     * function b (v){ return '[' + this.$super(v) + ']'; }
	 * var c = utils.fn.super(b, a);
	 * 
	 * c('John');
	 * // "[John!]"
	 * 
	 * @param {function} callback 		Current function
	 * @param {function} oldCallback 	Super function to call when using this.$super() in the current function (the old function)
	 * 
	 * @return {function}
	 */
	this.super = function (callback, oldCallback){
		if (callback !== oldCallback && typeof callback === 'function' && typeof oldCallback === 'function' && CONSTS.RE.SUPER_FUNCTION.test(callback)){
			return function (){
				var old = this.$super;

				// TODO try fixing the bug with infinite loop of $super();

				this.$super = oldCallback;

				var response = callback.apply(this, arguments);
				if (old){
					this.$super = old;
				}else{
					delete(this.$super);
				}

				return response;
			}
		}else{
			return callback;
		}
	};

	this.request = function (callback, ctx, isDouble){
		if (_.is.bool(ctx)){
			isDouble = ctx;
			ctx      = null;
		}

		callback = ctx ? callback.bind(ctx) : callback; 

		if (!$win.requestFrame){
			$win.requestFrame = $win.requestAnimationFrame || $win.webkitRequestAnimationFrame || $win.mozRequestAnimationFrame || $win.msRequestAnimationFrame || $win.oRequestAnimationFrame || (function() {
		        var timeLast = 0;
		        return function(fn) {
		            var timeCurrent = (new Date()).getTime();
		            var timeDelta;

		            // Dynamically set the delay on a per-tick basis to more closely match 60fps.
		            // Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671.
		            timeDelta 	= Math.max(0, 16 - (timeCurrent - timeLast));
		            timeLast 	= timeCurrent + timeDelta;

		            return setTimeout(function() {
						fn(timeCurrent + timeDelta);
					}, timeDelta);
		        };
		    })();
		}

		var request = {'frameId':null};

		if (isDouble){
			// TODO find a way to cancel both
			request.frameId = $win.requestFrame(function (){
				request.frameId = $win.requestFrame(callback);
			});
		}else{
			request.frameId = $win.requestFrame(callback);
		}

		return request;
	};

	this.cancel = function (item){
		if (item && _.is.fn(item.stop)){
			item.stop();
		}else if (item && _.is.fn(item.cancel)){
			item.cancel();
		}else if (_.is.fn(item)){
			item();
		}else if (item && _.is(item.frameId)){
			if (!$win.cancelFrame){
				$win.cancelFrame = $win.cancelAnimationFrame || $win.webkitCancelRequestAnimationFrame || $win.webkitCancelAnimationFrame || $win.mozCancelRequestAnimationFrame || $win.mozCancelAnimationFrame || $win.oCancelRequestAnimationFrame || $win.oCancelAnimationFrame || $win.msCancelRequestAnimationFrame || $win.msCancelAnimationFrame || function (id){
					return clearTimeout(id);
				};
			}
			$win.cancelFrame(item.frameId);
		}else if (_.is.nbr(item)){
			clearTimeout(item);
			clearInterval(item);
		}
		return null;
	};

	this.wait = function (delay, ctx, callback){
		var isInterval = false;
		var timeout    = false;
		
		if (_.has(delay, 'interval')){
			isInterval = true;
			delay      = delay.interval;
		}
		if (_.is.fn(delay)){
			callback = delay;
			delay    = true;
		}
		if (_.is.fn(ctx)){
			callback = ctx;
			ctx      = null;
		}
		if (!_.is.fn(callback)){
			return;
		}

		function _call (){
			var r = _.apply(callback, null, {'ctx':ctx});
			if (isInterval && r === false){
				clearInterval(timeout);
			}
		}
		
		if (!delay){
			_call();
		}else if (delay === true){
			timeout = _.fn.request(_call);
		}else{
			_
			delay   = _.toDuration(delay);
			timeout = isInterval ? setInterval(_call, delay) : setTimeout(_call, delay);
		}

		return timeout;
	};

	// TODO maybe, move "ctx" to the end of the args
	// @source https://gist.github.com/nmsdvid/8807205
	this.debounce = function (ctx, wait, callback, now){
		if (_.is.either(ctx, 'str,nbr')){
			now      = callback;
			callback = wait;
			wait     = ctx;
			ctx      = null;
		}

		wait = _.toDuration(wait);
		
		var timeout;
		return function() {
			var c = ctx || this;
			args = arguments;

			clearTimeout(timeout);

			timeout = setTimeout(function(){
				timeout = null;
				!now && callback.apply(c, args);
			}, wait);

			(now && !timeout) && callback.apply(c, args);
		};
	};

	// TODO maybe, move "ctx" to the end of the args
	this.throttle = function (ctx, wait, callback, now){
		if (_.is.either(ctx, 'str,nbr')){
			now      = callback;
			callback = wait;
			wait     = ctx;
			ctx      = null;
		}

		now  = now === undefined ? true : now;
		wait = _.toDuration(wait);

		var pause = false;
		return function () {       
			var c = ctx || this;

			if (!pause){
				args  = arguments;
				pause = true;

				now && callback.apply(c, args);  

				setTimeout(function () { 
					!now && callback.apply(c, args);  
					pause = false; 
				}, wait);
			}
		}
	};

	this.tick = function (args, callback, done, ctx){
		if (_.is.fn(args)){
			ctx      = done;
			done     = callback;
			callback = args;
			args     = {};
		}else if (_.is.bool(args)){
			args = {'now':args};
		}else if (_.is.either(args, 'str,nbr')){
			args = {'wait':args};
		}

		args       = args || {};
		args.key   = args.key || false; 								 // cache the ticker, so it can be cancelled if called with the same name again
		args.ctx   = 'ctx' in args ? args.ctx : ctx;
		args.wait  = _.toDuration('wait' in args ? args.wait : false);
		args.delay = _.toDuration('delay' in args ? args.delay : false);
		args.now   = 'now' in args ? args.now : true;
		
		// conditions to stop the ticking
		args.frames   = 'frames' in args ? args.frames : false;
		args.duration = _.toDuration('duration' in args ? args.duration : false);
		args.easing   = args.easing || null;

		args.from 	  = 'from' in args ? args.from : null;
		args.to 	  = 'to' in args ? args.to : null;
		args.move 	  = 'move' in args ? args.move : null;

		var isRange = false;
		var isMove  = false;
		var frames  = args.frames;
		var mult    = 1;
		if (args.from !== null && args.to !== null){
			isRange = true;

			if (args.move){
				isMove = true;
				frames = Math.ceil(Math.abs(args.to - args.from) / args.move);
			}else{
				frames = Math.abs(args.to - args.from);
				mult   = args.to < args.from ? -1 : 1;
			}
		}

		// TODO add a way (like frames), to move by distance, maybe with tensions, spring, ....

		var start  	  = _.now();
		var count     = 0;
		var request   = null;
		var easing 	  = _.easing(args.easing);
		var isTicking = false;
		var isStarted = false;

		var self = {
			'start': null,
			'stop' : null,
			'wait' : args.wait,
		};
		
		self.start = function (reset){
			if (isTicking) return this;
			isTicking = true;
			
			if (args.delay){
				request = setTimeout(_start, args.delay);
			}else{
				_start();
			}

			function _start (){
				if (reset === true){
					start     = _.now();
					count     = 0;
					isStarted = false;
				}
				_tick();
			}

			return this;
		};

		self.stop = function (lastTick){
			if (!isTicking) return this;
			
			isTicking = false;
			_.fn.cancel(request);
			
			// one last tick
			(lastTick === true) && _tick(true);

			return this;
		};

		function _tick (isStopped){
			var now   = _.now();
			var time  = now - start;
			var ratio = 0;

			if (_.is.nbr(frames)){
				ratio = count / frames;
			}else if (_.is.nbr(args.duration)){
				ratio = time / args.duration;
			}

			if (ratio > 1 || isNaN(ratio)) ratio = 1;

			var r = _.apply(easing, [ratio], {'fallback':ratio});
			var v = count;
			
			if (isMove){
				v = _.math.lerp(args.from, args.to, r);
			}else if (isRange){
				v = args.from + count * mult;
			}

			var evt = {
				'frame'        : count,
				'frames'       : frames || 0,
				'time'         : time,
				'duration'     : args.duration || 0,
				'now'          : now,
				'value'		   : v,
				'ratio'        : r,
				'originalRatio': ratio,
				'isStart'      : !isStarted,
				'isEnd'        : ratio === 1,
				'isStopped'    : isStopped === true
			};

			isStarted = true;

			var response = _.apply.ctx(args.ctx, callback, [evt, ratio]);
			(ratio === 1) && _.apply.ctx(args.ctx, done, [evt]);
			
			// the callback stops itself
			if (response === false || ratio >= 1){
				return self.stop(false);
			}
			if (!isTicking){
				return;
			}

			count++;

			if (self.wait){
				request = setTimeout(_tick, self.wait);
			}else{
				request = _.fn.request(_tick);
			}
		}

		if (args.now){
			self.start(true);
		}
		
		if (args.key){
			_.cancel(FN.TICKS[args.key]);
			FN.TICKS[args.key] = self;
		}

		return self;
	};

	this.animate = function (args, callback, done, ctx){
		if (_.is.either(args, 'str,nbr')){
			args = {'duration':args};
		}else if (_.is.fn(args)){
			done     = callback;
			callback = args;
			args     = {'duration':1000};
		}
		return _.fn.tick(args, callback, done, ctx);
	};

	this.batch = function (list, args){
		args        = args || {};
		args.wait   = args.wait || false;
		args.now    = 'now' in args ? args.now : true;
		args.ctx    = args.ctx || null;
		args.onEach = args.onEach || null;
		args.onDone = args.onDone || null;
		
		var keys  = _.$arr(list, function (v, i){ return i; });
		var last  = keys.length-1;
		var items = list instanceof Array ? [] : {};
		var index = -1;

		function _next (){
			if (index >= last){
				return _done();
			}

			var i = keys[++index];
			var v = list[i];

			// _set([i, v, keys, list]);

			// TODO deal with value VS function, like pipe()

			_.apply(args.onEach, [v, function (vv){
				_set(vv, i);
				if (args.wait === true)		_next();
				else if (args.wait === 0)	_.fn.request(_next);
				else if (args.wait)			_.fn.wait(args.wait, _next);
			}]);

			!args.wait && _next();
		}

		function _set (v, i){
			if (v !== undefined){
				items[i] = v;
			}else{
				items[i] = list[i];
			}
		}

		function _done (){
			_.apply.ctx(args.ctx, args.onDone, [items]);
		}

		args.now && _next();

		return items;
	};
});


FFTO.Utils.add('arr', function (ARR, CONSTS, RE, _){
	function _sortNumeric (a, b){ return a - b; };
	function _sortRandom (){ return 0.5 - Math.random(); }

	function _index (arr, search, args){ 
		if (_.is.bool(args)){
			args = {'single':args};
		}
			
		args        = args || {};
		args.single = 'single' in args ? args.single : false;

		var index = -1;
		if (search === ':first'){
			index = 0;
		}else if (search === ':last'){
			index = arr.length - 1;
		}else if (search === ':random' || search === '?'){
			index = Math.round(Math.random() * (arr.length-1));
		}else if (search === '??'){
			// random BUT goes through the list before getting another item that's similar
			// TODO
		}else if (_.is.percent(search)){
			index = Math.round((arr.length-1) * (parseFloat(search) / 100));
		}else if (_.is.str(search) && search.indexOf(':index(') === 0){
			index = parseFloat(search.replace(':index(', ''));
		}else if (_.has(search, ':index')){
			index = search[':index'];
		}else{
			index = _.arr.filter(arr, search, _.extend({}, args, {
				'return': 'index',
			}));
		}

		if (!args.single && !(index instanceof Array)){
			index = [index];
		}

		return index;
	};

	this.get = function (arr, search, args){
		if (_.is.bool(args)){
			args = {'return':args};
		}

		args          = args || {};
		args.loop     = args.loop || false;
		args.return   = args.return || false;                       // [:index, :value, true = both]
		args.fallback = 'fallback' in args ? args.fallback : null;

		var index = _index(arr, search, _.extend({}, args, {
			'single': true,
		}));

		if (args.loop){
			index = index % arr.length;
			if (index < 0){
				index = arr.length + index;
			}
		}

		if (!(index in arr)){
			index = -1;
		}

		var v = arr[index];
		if (v === undefined){
			v = args.fallback;
		}

		if (args.return === true || args.return === 'index'){
			return index;
		}else if (args.return === 'both'){
			return {
				'index' : index,
				'value' : v,
			};
		}else{
			return v;
		}
	};

	this.get.byIndex = function (arr, index, args){
		// make sure it's an index search if the index is a number
		index = _.is.nbr(index) ? {':index':index} : index;
		return _.arr.get(arr, index, args);
	};

	this.get.item = function (arr, search, args, returnIndex){
		if (_.is.str(args)){
			args = {'closest':args};
		}

		args         = args || {};
		args.props   = args.props || 'id,element,elements,target,targets,trigger,triggers';
		args.closest = args.closest || '[item]';
		args.return  = args.return || returnIndex;

		return _.arr.get(arr, search, {
            'index'   : true,
            'props'   : args.props,
            'closest' : args.closest,
            'return'  : args.return,
        });
	};

	this.loop = function (arr, search){
		return this.get(arr, {':index':search}, {'loop':true});
	};

	this.filter = function (arr, search, args){
		if (_.is.bool(args)){
			args = {'single':args};
		}

		args          = args || {};
		args.trim     = 'trim' in args ? args.trim : true;  // trim the value
		args.single   = args.single || false;               // only 1 item to return
		args.index 	  = args.index || false;				// compare with the index
		args.props 	  = args.props || false;				// check specific properties
		args.closest  = args.closest || false;              // if search is a node, check through the props if one contains the element
		args.alias    = args.alias || false;                // used for args.closest
		args.return   = args.return || false;               // return the index
		args.get      = args.get || false;                  // if the data to search is in a property
		
		arr = _.$arr(arr);
		
		var is    = _.is.valid(search);
		var list  = [];
		var props = args.props ? _.$arr(args.props) : false;
		var i, l, v;
		for (i=0, l=arr.length; i<l; ++i){
			v = arr[i];
			v = args.get ? _.get(v, args.get) : v;

			if (
				(!is && _.is(v)) ||
				(is && args.index && i == search) ||
				(is && _.is.like(v, search, {
					'props'  : props,
					'closest': args.closest,
					'alias'  : args.alias,
					'params' : {'index':i}
				}))
			){
				if (args.return === true || args.return === 'index'){
					list.push(i);
				}else{
					list.push(v);
				}
			}

			if (args.single && list.length >= 1){
				break;
			}
		}

		return args.single ? list[0] : list;
	};

	this.create = function (count, callback, ctx){
		var arr = [];
		for (var i=0; i<count; ++i){
			var value = i + 1;
			value = _.apply.ctx(ctx, callback, [value, i]);
			arr.push(value);
		}
		return arr;
	};

	this.insert = function (arr, items, args){
		if (_.is.bool(args)){
			args = {'unique':args};
		}else if (!_.is.obj(args)){
			args = {'index':args};
		}
		
		args        = args || {};
		args.unique = args.unique || false;
		args.index  = 'index' in args ? args.index : arr.length;

		arr   = _.$arr(arr);
		items = _.$arr(items);

		if (args.unique){
			items = items.filter(function (v, i, s){ 
				return s.indexOf(v) === i && !~arr.indexOf(v); 
			});
		}

		var index = _.nbr.get(args.index, {'max':arr.length, 'decimals':false});

		// add the items at a specific index
		arr.splice.apply(arr, [index, 0].concat(items));

		return arr;
	};

	this.remove = function (arr, search, args){
		if (args === true){
			args = {'all':true};
		}

		args         = args || {};
		args.replace = 'replace' in args ? args.replace : undefined;
		args.all     = args.all || false;
		
		arr    = _.$arr(arr);
		search = args.all ? search : [search];

		var removed = [];
		var indexes = [];
		var index 	= -1;
		var i, ii;
				
		// search through all the items to remove
		_._each(search, function (s){
			ii      = _index(arr, s);
			indexes = indexes.concat(ii);
		});

		// re-order the indexes to be able to remove them easily
		indexes.sort(_sortNumeric);
		
		for (i=indexes.length-1; i>=0; --i){
			index = indexes[i];
			removed.unshift(arr[index]);
			arr.splice(index, 1);
		}

		if (args.replace && ~index){
			var replace = args.replace instanceof Array ? args.replace : [args.replace];
			arr.splice.apply(arr, [index, 0].concat(replace));
		}

		return removed;
	};

	this.remove.all = function (arr, items, args){
		args     = args || {};
		args.all = true;
		return _.arr.remove(arr, items, args);
	};

	this.remove.at = function (arr, index, args){
		return _.arr.remove(arr, {':index':index}, args);
	};

    /**
	 * Shuffle an array
	 * 
	 * @memberof utils.arr
	 * @function shuffle
	 * 
	 * @param {array} arr Array to shuffle
	 * 
	 * @return {array}
	 */
	this.shuffle = function (arr){
		var j, x, i;
	    for (i = arr.length; i; i--) {
	        j = Math.floor(Math.random() * i);
	        x = arr[i - 1];
	        arr[i - 1] = arr[j];
	        arr[j] = x;
	    }
		return arr;
	};

	this.unique = function (arr, args){
		arr = _._each(arr, args);
		return arr.filter(function (v, i, s){ return s.indexOf(v) === i; });
	};

	this.slice = function (arr, index, count, args){
		if (_.is.fn(args)){
			args = {callback:args};
		}

		args          = args || {};
		args.ctx      = args.ctx || null;
		args.callback = args.callback || null;

		var list = [];
		var max  = arr.length-1;

		index = _.math.loop(index, max);
		
		var move = count < 0 ? -1 : 1;
		var c 	 = Math.abs(count);
		var i    = index;
		var ii, v, r;
		while (list.length != c){
			ii = _.math.loop(i, max);
			v  = arr[ii];
			r  = _.apply.ctx(args.ctx, args.callback, [v, i, ii], {fallback:v});
			_.is(r) && list.push(r);
			i += move;
		}

		return list;
	};

	this.sort = function (arr, orderBy, args){
		// TODO
	};
});


FFTO.Utils.add('obj', function (OBJ, CONSTS, RE, _){
    /**
	 * Add getter/setter to an object
	 * 
	 * @memberof utils.obj
	 * @function prop
	 * 
	 * @param {object} 		obj 	Object to modify
	 * @param {string} 		name 	Name of the getter/setter
	 * @param {function} 	getter 	Getter function
	 * @param {function} 	setter 	Setter function
	 * 
	 * @return {object}
	 */
	this.prop = function (obj, name, getter, setter){
		Object.defineProperty(obj, name, {
			get:getter && function (){ return getter.apply(this); },
			set:setter && function (){ setter.apply(this, arguments); }
		});
		return obj;
	};

	// [deprecated]
	this.mergeOld = function (obj, sources, args){
		if (!_.is.arr(sources, true)){
			sources = [sources];
		}

		args        = args || {};
		args.proto  = args.proto;
		args.skip   = _.$arr(args.skip || [], true);
		args.onEach = args.onEach || null;

		function _obj (v){ return _.is.obj(v, true); };
		function _arr (v){ return _.is.arr(v, true); };

		var proto = args.proto || obj;

		var i, ii, v;
		for (i in sources){
			for (ii in sources[i]){
				v = sources[i][ii];

				if (~args.skip.indexOf(ii)) continue;
				
				// test
				if (_.call(args.onEach, [v, ii, ]) === false){
					continue;
				}

				// TODO maybe add other types of merging, like string, appending text...

				// merge object
				if (_obj(v)){
					obj[ii] = _obj(obj[ii]) ? obj[ii] : {};
					obj[ii] = _.extend(true, obj[ii], v);
				// concat arrays
				}else if (_arr(v)){
					obj[ii] = _arr(obj[ii]) ? obj[ii] : [];
					obj[ii] = obj[ii].concat(v);
				// superize the function
				}else if (_.is.fn(v)){
					proto[ii] = _.fn.super(v, proto[ii]);
				// save the value
				}else{
					proto[ii] = v;
				}
			}
		}

		return obj;
	};

	this.merge = function (obj, extend, args){
		if (_.is.either(args, 'str,arr,fn')){
			args = {'skip':args};
		}

		extend     = _.is.arr(extend, true) ? extend : [extend];
		args       = args || {};
		args.obj   = args.obj;
		args.proto = args.proto;
		args.skip  = args.skip || null;

		function _obj (v){ return _.is.obj(v, true); };
		function _arr (v){ return _.is.arr(v, true); };
		function _fn  (v){ return _.is.fn(v); }

		var skip  = args.skip;
		var proto = args.proto || obj;

		// skip arrays of keys
		if (_.is.either(skip, 'str,arr')){
			var keys = _.$arr(args.skip, true);
			skip = function (i){ return !!~keys.indexOf(i); };
		}
		
		var i, key, v, o;
		for (i in extend){
			for (key in extend[i]){
				o = obj[key];		// current object value
				v = extend[i][key];	// extend valud

				// skip keys if the function returns true
				if (_.call(skip, [key, {
					'old'   : key in obj ? obj[key]: proto[key],
					'value' : v,
					'obj'   : obj,
					'proto' : proto,
					'extend': extend[i],
				}]) === true){
					continue;
				}

				// [ ] maybe merge strings?? or that would be with the skip function

				// merge object
				if (_obj(v)){
					o 		 = _obj(o) ? o : {};
					obj[key] = _.extend(true, {}, o, v);
				// concat arrays
				}else if (_arr(v)){
					o 		 = _arr(o) ? [].concat(o) : [];
					obj[key] = o.concat(v);
				// superize the function
				}else if (_fn(v)){
					proto[key] = _.fn.super(v, o);
				// save the value
				}else{
					proto[key] = v;
				}
			}
		}

		return obj;
	};

	this.traverse = function (obj, args){
		if (_.is.fn(args)){
			args = {'callback':args};
		}

		args          = args || {};
		args.ctx      = args.ctx || null;
		args.callback = args.callback || null;

		// todo
		function _walk (key, value, parentKey, parentValue){
			var response = _.apply(args.callback, [key, value, parentKey, parentValue], {'ctx':args.ctx});
			
			if (response){
				key = response;
			}

			if (_.is.obj(value, true) || _.is.arr(value)){
				for (var i in value){
					_walk(i, value[i], key, value);
				}
			}
		}

		for (var i in obj){
			_walk(i, obj[i]);
		}

		// return string.join(args.separator);
	};
});
FFTO.Utils.add('dt', function (DT, CONSTS, RE, _){
	RE.DT_UPDATE    = /(?:(?:(?:(?<operator>\+|\-)\s*(?<nbr>\d+)|(?<relative>first|last))\s?(?<attr>[a-z]+))|(?<day>monday|tuesday|wednesday|thursday|friday|saturday|sunday))/g;
    RE.DT_TIME      = /\d{2}\:\d{2}/;
    RE.DT_ATTRS_IN  = /(year|month|day|hour|minute|min|second|sec|millisecond|Y{1,4}|M{1,4}|D{1,3}|h{1,2}|m{1,2}|s{1,2}|ms)/gi;
    // RE.DT_ATTRS_OUT = /(year|month|day|hour|minute|min|second|sec|millisecond|YYYY|YY|MMMM|MMM|MM|M|WW|W|DDD|DD|D|ddd|dd|d|HH|hh|H|h|mm|m|ss|s|ms|A|a)/g;
    RE.DT_ATTRS_OUT2 = /(year|month|day|hour|minute|min|second|sec|millisecond|d|D|j|l|N|w|W|F|m|M|n|t|Y|y|a|A|g|G|h|H|i|s|u|P)/g;
    
	DT.MINUTE_IN_SECONDS = 60;
	DT.HOUR_IN_SECONDS   = 60 * 60;
	DT.DAY_IN_SECONDS    = 60 * 60 * 24;
	DT.WEEK_IN_SECONDS   = 60 * 60 * 24 * 7;
	DT.MONTH_IN_SECONDS  = 60 * 60 * 24 * 30;
	DT.YEAR_IN_SECONDS   = 60 * 60 * 24 * 365;
	DT.DAYS              = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
    DT.LOCALES = {
        EN : {
            'month_long'   : 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
            'month_short'  : 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
            'weekday_long' : 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
            'weekday_short': 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
            'weekday_mini' : 'S,M,T,W,T,F,S'.split(','),
        },
        FR : {
            'month_long'   : 'janvier,février,mars,avril,mai,juin,juillet,août,septembre,octobre,novembre,décembre'.split(','),
            'month_short'  : 'janv,févr,mars,avr,mai,juin,juil,août,sept,oct,nov,déc'.split(','),
            'weekday_long' : 'dimanche,lundi,mardi,mercredi,jeudi,vendredi,samedi'.split(','),
            'weekday_short': 'dim,lun,mar,mer,jeu,ven,sam'.split(','),
            'weekday_mini' : 'd,l,m,m,j,v,s'.split(','),
        },
        ES : {
            'month_long'   : 'Enero,Febrero,Marzo,Abril,Mayo,Junio,Julio,Agosto,Septiembre,Octubre,Noviembre,Diciembre'.split(','),
            'month_short'  : 'Ene,Feb,Mar,Abr,May,Jun,Jul,Ago,Sep,Oct,Nov,Dic'.split(','),
            'weekday_long' : 'Domingo,Lunes,Martes,Miércoles,Jueves,Viernes,Sábado'.split(','),
            'weekday_short': 'Dom,Lun,Mar,Mié,Jue,Vie,Sáb'.split(','),
            'weekday_mini' : 'D,L,M,X,J,V,S'.split(','),
        },
    };

    this.decode = function (dt, format, lang){
        lang = (lang || 'en').toUpperCase();

        /*
        var locales = DT.LOCALES[lang] || DT.LOCALES.EN;
        var attrs   = [];
        var str     = dt;
        var re      = format || 'Y-m-d H:i:s';

        // convert the format to a regexp version
        re = re.replace(RE.DT_ATTRS_IN, function (m, $1){
            attrs.push($1.replace(/\s$/, ''));
            return '(.+?)';
        });
        re = new RegExp('^' + re + '$');

        _js(dt, re);
        */

        /*
        date = new Date();
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        date.setDate(1);	// @info date need to be 1, if it's the "31" and the month to be selected has less than 31 days, it breaks

        utils.string.match(str, re, function (number, i){
            var attr = attrs[i];

            if (isNaN(number)){
                var index;

                if (~(index = locales.month_long.indexOf(number))){
                    number = index+1;
                }else if (~(index = locales.month_short.indexOf(number))){
                    number = index+1;
                }
            }else{
                number = parseFloat(number);
            }

            if (number === null){
                return;
            }

            attr = attr.toLowerCase();

            switch (attr){
                case 'year': case 'yyyy': case 'yy': 						date.setYear(number); break;
                case 'month': case 'mmmm': case 'mmm': case 'mm': case 'm':	date.setMonth(number-1); break;
                case 'day': case 'dddd': case 'ddd': case 'dd': case 'd':  	date.setDate(number); break;
                case 'hour': case 'hh': case 'h': 							date.setHours(number); break;
                case 'minute': case 'min': case 'mm': case 'm':				date.setMinutes(number); break;
                case 'second': case 'sec': case 'ss': case 's':				date.setSeconds(number); break;
                case 'millisecond': case 'ms' : 							date.setMilliseconds(number); break;
            }
        });

        return date;
        */
    };

    // [ ] Add returned values, is_today, .... like in the PHP code
    this.get = function (dt, args, format){
        if (_.is.obj(dt, true)){
            args = dt;
            dt   = 'now';
        }

        if (_.is.str(args)){
            args = {'update':args};
        }

        args 			= args || {};
		// args.input 	= 'input' in args ? args.input : null;
		args.update 	= 'update' in args ? args.update : null;
        args.time 		= 'time' in args ? args.time : true;            // include time or not, or set it
        args.clone      = 'clone' in args ? args.clone : true;          // by default, always create a new date object
		args.format 	= 'format' in args ? args.format : format;
		args.lang 		= 'lang' in args ? args.lang : 'EN';

        var is_string = _.is.str(dt);

        // if the date contains the update (eg.: 'now +3days')
		if (!args.update && is_string && dt.match(RE.DT_UPDATE)){
			args.update = dt.match(RE.DT_UPDATE).join(' ');
			dt 		    = dt.replace(RE.DT_UPDATE, '').trim();
		}

        // [ ] Maybe add a way to return a random date (in between 2 dates maybe)

        // Decode 
        if (dt instanceof Date){
            dt = args.clone ? new Date(dt.getTime()) : dt;
		}else if (dt === 'now' || !dt){
			dt = new Date();
		}else if (dt === 'today'){
            dt = new Date();
            args.time = false;			
		}else if (is_string && args.input){
            // TODO
            // date = utils.date.decode(date, args.input, args.lang);
        }else if (is_string){
            // add time 00:00:00 if not set in the string
            if (!dt.match(RE.DT_TIME)){
                dt += ' 00:00:00';
            }
			
			dt = dt.replace(/-/g, '/'); // safari doesn't understand "2010-01-01 00:00:00" but understand "2010/01/01 00:00:00"
			dt = Date.parse(dt);
			dt = new Date(dt);
		}else if (!isNaN(dt)){
            dt = parseFloat(dt);
			dt = new Date();
        }

        // Return false if the date is not parsed
        if (!(dt instanceof Date)){
            return false;
        }
        
        // Update the time
        if (args.time === false){
			dt.setHours(0);
			dt.setMinutes(0);
			dt.setSeconds(0);
			dt.setMilliseconds(0);
        }else if (_.is.str(args.time)){
            var pm   = args.time.match(/pm/i);
            var time = args.time.replace(/am|pm/, '').split(':');
            var h    = 0 in time ? parseFloat(time[0]) + (pm ? 12 : 0) : null;
            var m    = 1 in time ? parseFloat(time[1]) : 0;
            var s    = 2 in time ? parseFloat(time[2]) : 0;

            // the hour is needed to set the time
            if (h !== null){
                dt.setHours(h);
                dt.setMinutes(m);
                dt.setSeconds(s);
                dt.setMilliseconds(s % 1 ? (s % 1 * 100) : 0);
            }
        }
        
        // Update date
        if (args.update){
            var update = args.update;

            function _update (attr, v){
                attr = attr ? attr.toLowerCase().replace(/s$/, '') : null;

                var day = DT.DAYS.indexOf(attr);
                if (~day){
                    dt.setDate(dt.getDate() - dt.getDay() + day);
                }else if (attr === 'day' && v === 'first'){
                    dt.setDate(1);
                }else if (attr === 'day' && v === 'last'){
                    dt.setDate(1);
                    dt.setMonth(dt.getMonth() + 1);
                    dt.setDate(0);
                }else if (attr === 'year'){
                    dt.setYear(dt.getFullYear() + v);
                }else if (attr === 'month'){
                    dt.setMonth(dt.getMonth() + v);
                }else if (attr === 'week'){
                    dt.setDate(dt.getDate() + (v * 7));
                }else if (attr === 'day'){
                    dt.setDate(dt.getDate() + v);
                }else if (attr === 'hour'){
                    dt.setHours(dt.getHours() + v);
                }else if (attr === 'minute'){
                    dt.setMinutes(dt.getMinutes() + v);
                }else if (attr === 'second'){
                    dt.setSeconds(dt.getSeconds() + v);
                }
            }
            
            if (_.is.str(update)){
                var lastOperator = '+';
                _.match(update, RE.DT_UPDATE, function (e){
                    var operator = e.operator || lastOperator;
                    
                    if (e.day){
                        _update(e.day);
                    }else if (e.relative){
                        _update(e.attr, e.relative);
                    }else{
                        var nbr = parseFloat(e.nbr) * (operator === '-' ? -1 : 1);
                        _update(e.attr, nbr);
                        lastOperator = operator;
                    }
                });
            }else{
                update = update instanceof Array ? update : [update];
                var v, attr, i=0, l=update.length;
                for (; i<l; ++i){
                    for (attr in update[i]){
                        v = update[i][attr];
                        _update(attr, v);
                    }
                }
            }
        }

        // Format date
        if (args.format){
            var format = args.format;

            // TODO
            if (format === ':timestamp'){
            }else if (format === ':utc-timezone'){
            }else if (format === ':utc'){
            }else if (format === ':utc-date'){
            }else if (format === ':utc-time'){
            }else if (format === ':atom' || format === ':iso'){
            }else if (format === ':atom-micro' || format === ':iso-micro'){
                format = 'Y-m-d\TH:i:s.uP';
            }

            if (format === ':full')				    format = 'Y-m-d H:i:s';
            else if (format === ':date')			format = 'Y-m-d';
            else if (format === ':date-compact')	format = 'Ymd';
            else if (format === ':time')			format = 'H:i:s';
            // else if (format === ':text' && $time)	format = __tx('date/format:text-time', 'F j, Y g:i a');		// fr: 'j F Y G \h i'
            else if (format === ':text')			format = 'F j, Y';
            else if (format === ':date-text')		format = 'F j, Y';
            else if (format === ':datetime-text')	format = 'F j, Y g:i a';
            else if (format === ':date-numeric')	format = 'm.d.Y';
            else if (format === ':time-text')		format = 'g:i a';
    
            var lang    = (lang || 'en').toUpperCase();
            var locales = DT.LOCALES[lang] || DT.LOCALES.EN;
            
            var YEAR       = dt.getFullYear();
            var MONTH      = dt.getMonth();
            var DATE       = dt.getDate();
            var DAY        = dt.getDay();
            var HOUR       = dt.getHours();
            var MIN        = dt.getMinutes();
            var SEC        = dt.getSeconds();
            var M          = dt.getMilliseconds();
            var today      = new Date(Date.UTC(YEAR, MONTH, DATE));
            var startYear  = new Date(Date.UTC(YEAR, 0, 1));
            var startMonth = new Date(Date.UTC(YEAR, MONTH, 1));
            var diffYear   = today.getTime() - startYear.getTime();
            var dayYear    = Math.floor(diffYear / (DT.DAY_IN_SECONDS * 1000)) + 1;

            function _gmt (dt){
                const offsetInMinutes = dt.getTimezoneOffset();
                const hours           = Math.floor(Math.abs(offsetInMinutes) / 60);
                const minutes         = Math.abs(offsetInMinutes) % 60;
                const sign            = offsetInMinutes <= 0 ? '+' : '-';
                return `${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            };

            // Using the same formats as PHP (https://www.php.net/manual/en/datetime.format.php)
            var data = {
                // DAY
                'd' : _.str.pad(DATE, '0', 2, 'left'),
                'D' : locales.weekday_short[DAY],
                'j' : DATE,
                'l' : locales.weekday_long[DAY],
                'N' : DAY === 0 ? 7 : DAY,  // ISO 8601 numeric representation of the day of the week (Monday = 1 to Sunday = 7)
                'S' : false, // TODO English ordinal suffix for the day of the month, 2 characters (st, nd, rd or th. Works well with j)
                'w' : DAY,
                'z' : false, // TODO The day of the year (starting from 0)
                'W' : false, // TODO ISO 8601 week number of year, weeks starting on Monday
                // MONTH
                'F' : locales.month_long[MONTH],
                'm' : _.str.pad(MONTH + 1, '0', 2, 'left'),
                'M' : locales.month_short[MONTH],
                'n' : MONTH + 1,
                't' : false, // TODO Number of days in the given month
                // YEAR
                'L' : false, // TODO Whether it's a leap year,
                'o' : false, // TODO ISO 8601 week-numbering year. This has the same value as Y, except that if the ISO week number (W) belongs to the previous or next year, that year is used instead
                'X' : false,
                'x' : false,
                'Y' : YEAR,
                'y' : YEAR.toString().slice(2),
                // TIME
                'a' : HOUR >= 12 ? 'pm' : 'am',
                'A' : HOUR >= 12 ? 'PM' : 'AM',
                'B' : false,
                'g' : HOUR % 12,
                'G' : HOUR,
                'h' : _.str.pad(HOUR % 12, '0', 2, 'left'),
                'H' : _.str.pad(HOUR, '0', 2, 'left'),
                'i' : _.str.pad(MIN, '0', 2, 'left'),
                's' : _.str.pad(SEC, '0', 2, 'left'),
                'u' : M,
                // TIMEZONE 
                'P' : _gmt(dt),
            };

            // synonyms
            data.year 	         = data.Y;
            data.month           = data.F;
            data.day 	         = data.l;
            data.date 	         = data.j;
            data.hour 	         = data.G;
            data.minute 	     = data.i;
            data.min 	         = data.i;
            data.second 	     = data.s;
            data.sec 	         = data.s;
            data.millisecond 	 = data.u;
                        
            dt = format.replace(RE.DT_ATTRS_OUT2, function (m, key){
                return key in data ? data[key] : key;
            });
		}

        return dt;
    };

    this.is = function (a, b, args){
        if (!a || !b) return false;

        if (_.is.bool(args)){
            args = {'time':args};
        }

        args      = args || {};
        args.time = 'time' in args ? args.time : true;
        
        // make sure if a time is compare with today, there shouldn't be time for both
        if (a === 'today' || b === 'today'){
			args.time = false;
        }

		a = this.get(a, {'time':args.time});
        b = this.get(b, {'time':args.time});
        
		return a.getTime() === b.getTime();
    };

    this.clone = function (dt){
		return this.get(dt, {'clone':true});
	};
});
// TODO for classnames duration arguments, I should use a timecode and clear it when changing the values before it's triggerd maybe

/** 
 * Utils DOM helpers
 * @namespace _.dom
 * 
 */
FFTO.Utils.add('dom', function (DOM, CONSTS, RE, _, $win, $doc){
	var $     = this;
	var $html = $doc.documentElement;

	DOM.IS_READY  = false;
	DOM.IS_LOADED = false;
	DOM.ON_READY  = [];
	DOM.ON_LOAD   = [];
	DOM.DUMMY     = null,

	DOM.SCREEN = {
		BODY  : false,
		WIDTH : 0,
		HEIGTH: 0,
	};

    DOM.CACHE = {
		ATTRS    : '$ATTRS',
		STYLE    : '$STYLE',
		TRANSFORM: '$TRANSFORM',
		DATA     : '$DATA',
		HTML 	 : '$HTML',
	};

	DOM.CACHE.STYLE = {
		TRANSFORM_VALUES : [
			'translateX', 'translateY', 'translateZ',
			'scale', 'scaleX', 'scaleY', 'scaleZ',
			'rotate', 'rotateX', 'rotateY', 'rotateZ',
			'skewX', 'skewY',
			'perspective', 'perspectiveX', 'perspectiveY',
			'centerX', 'centerY',
		],
		PX_VALUES : [
			'top','right','bottom','left',
			'height','width','min-height','max-height','min-width','max-width',
			'border-top','border-right','border-bottom','border-left','border-top-width', 'border-right-width','border-bottom-width','border-left-width','border-radius',
			'border-spacing',
			'background-size', 'background-position', // @note do not put "background" in this, espacially when using rgba()
			'margin','margin-top','margin-right','margin-bottom','margin-left',
			'padding','padding-top','padding-right','padding-bottom','padding-left',
			'font-size',
		],
		URL_VALUES : [
			'background', 'background-image',
			'border', 'border-image', 'border-left',
			'cursor',
			'list-style',
		],
		COMPUTED      : null,
		PREFIXED_NAMES: {},
		HEAD_CSS      : null,
		ONCE_CSS      : {},
		CUSTOM        : {},
	};

	DOM.SVG_NAMESPACES = {
		'xlink:href' : 'http://www.w3.org/1999/xlink',
	};

	DOM.MOUSE_BUTTONS = {
		0 : null,
		1 : 'primary',
		2 : 'secondary',
		4 : 'auxiliary',
		8 : 'back',
		16: 'forward',
	};

	DOM.EVENT = {
		ALT_DELEGATE : {
			'mouseenter'  : 'mouseover',
			'mouseleave'  : 'mouseout',
			'pointerenter': 'pointerover',
			'pointerleave': 'pointerout',
		},
		CLASSES : {
			'click'     : 'MouseEvent',
			'dblclick'  : 'MouseEvent',
			'mouseover' : 'MouseEvent',
			'mouseout'  : 'MouseEvent',
			'mouseenter': 'MouseEvent',
			'mouseleave': 'MouseEvent',
			'mousemove' : 'MouseEvent',
			'mousedown' : 'MouseEvent',
			'wheel'     : 'MouseEvent',
			'select'    : 'MouseEvent',
			'focus'     : 'FocusEvent',
			'blur'      : 'FocusEvent',
			'reset'     : 'Event',
			'submit'    : 'Event',
			'keydown'   : 'KeyboardEvent',
			'keypress'  : 'KeyboardEvent',
			'keyup'     : 'KeyboardEvent',
			'change'    : 'Event',
			'load'      : 'ProgressEvent',
		},
		BINDS : {},
		CUSTOM: {},
	};

	DOM.VARS = {
		SHEETS: [],
		KEYS  : null,
	};

	// RE.EVENT_NAME 	= /(?:^|(?:(?:([a-zA-Z][a-zA-Z0-9_]*?)_)?([a-zA-Z][a-zA-Z0-9_]*)_))on([A-Z][a-zA-Z0-9+]+)/; // {attr|tag|class}_{value|name}_on{eventname}
	RE.EVENT_NAME 	= /(?:^|(?:(?:([a-zA-Z][a-zA-Z0-9_]*)_)?([a-zA-Z][a-zA-Z0-9_]*)_))on([A-Z][a-zA-Z0-9+]+)/; // {attr|tag|class}_{value|name}_on{eventname}
    RE.NUMBER_UNITS	= /(\-?\d+(?:\.\d+)?(?:em|rem|%|vh|vw|px|sw|sh|cw|ch|w|h))/g;

	this.is = function (el, selector){
		if (_.is.str(el)){
			el = _.dom.get(el);
		}

		if (!el || !_.is.el(el, true)) return false;
		
		if (el === selector){
			return true;
		}else if (_.is.fn(selector)){
			return !!selector(el);
		}else if (_.is.obj(selector, true)){
			var i, values;

			if ('tag' in selector && el.tagName.toLowerCase() !== selector.tag.toLowerCase()){
				return false;
			}			
			if ('html' in selector && el.innerHTML.trim() !== selector.html.trim()){
				return false;
			}
			if ('text' in selector && el.innerText.trim() !== selector.html.trim()){
				return false;
			}
			if ('contains' in selector && !~el.innerText.trim().indexOf(selector.contains.toString().trim())){
				return false;
			}
			if ('style' in selector){
				values = _.dom.style(el);
				for (i in selector.style){
					if (values[i] !== selector.style[i]){
						return false;
					}
				}
			}
			if ('attrs' in selector){
				values = _.dom.attrs(el);
				for (i in selector.attrs){
					if (values[i] !== selector.attrs[i]){
						return false;
					}
				}
			}
			if ('classnames' in selector){
				// TODO check if the classnames are in the el
				// values = _.dom.classnames(el);
			}
			if ('value' in selector){
				// TODO
			}

			// TODO others match maybe... (:empty, :button, :checked, :disabled, ...)

			return true;
		}else if (_.is.str(selector)){
			var match = (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector);
			var value = false;

            try{
				value = match && match.call(el, selector);
			}catch(e){} // @info in IE11 and less, a selector starting with a dash isnt valid (eg.: classname "-test" will break)
				
			return !!value;
		}else{
			return false;
		}
	};

	this.els = function (els, callback, args){
		if (_.is.obj(callback)){
			callback = [args, args = callback][0];
		}
		
		if (args === false){
			args = {'get':false};
		}else if (args === true){
			args = {'tag':true};
		}

		args      = args || {};
		args.get  = 'get' in args ? args.get : true;
		args.tag  = args.tag || false;
		args.root = 'root' in args ? args.root : false;

		if (_.is.el(els)){
			els = [els];
		}

		if (args.get){
			els = _.dom.get.all(els, {
				'tag' : args.tag,
			});	
		}

		return _.toArray(els, function (el, i){
			if (
				!_.is.el(el, args.tag)
				&& (!args.root || (args.root && !_.is.el(el, ':root')))
			) return;

			var r = _.apply(callback, [el, i]);
			return r === undefined ? el : r;
		});
	};

	this.create = function (tag, args){
		if (_.is.obj(tag, true)){
			args = _.extend({}, args || {}, tag);
			tag  = args.tag || 'div';
		// }else if (_.is.str(tag)){
		// 	 tag = tag.trim();
		}

		if (args === ':frag'){
			args = {'return':'frag'};
		}else if (args === ':array'){
			args = {'return':'array'};
		}else if (_.is.str(args)){
			args = {'html':args};
		}

		args           = args || {};
		args.alias     = args.alias || '';
		args.svg       = args.svg || false;
		args.text	   = 'text' in args ? args.text : null;
		args.textNodes = 'textNodes' in args ? args.textNodes : true;
		args.namespace = args.namespace || null;
		args.return    = args.return || null;

		// TODO auto detect is-svg by tag types and if the parent is an svg

		tag = tag || args.tag || 'div';

		// auto-detecting of innerHTML
		var isInner = args.text === true || (args.text === null && _.is.str(tag) && !tag.match(RE.CSS_SELECTOR));
		var isArray = args.return === 'array' || args.return === 'frag';

		function _create (tag){
			if (tag === 'svg'){
				args.svg 					= true;
				args.attrs['xmlns'] 		= 'http://www.w3.org/2000/svg';
				args.attrs['xmlns:xlink'] 	= 'http://www.w3.org/1999/xlink';
			}
			if (args.svg){
				args.namespace = 'http://www.w3.org/2000/svg';
			}

			if (args.namespace){
				return document.createElementNS(args.namespace, tag)
			}else{
				return document.createElement(tag);
			}
		}

		function _template (el){
			el = el.content ? el.content.childNodes : el.childNodes;
			el = _.$arr(el);
			el = !args.textNodes ? _.dom.els(el) : el;
			el = el.length > 1 || isArray ? el : el[0];
			return el;
		}
		
		var el = null;
		if (_.is.el(tag, 'template')){
			el = tag.cloneNode(true);
			el = _template(el);
		}else if (_.is.el(tag)){
			el = args.clone ? tag.cloneNode(true) : tag;
		}else if (isInner){
			var frag = $doc.createElement('template');
			var html = args.alias ? tag.replace(/\&([a-z]+\;)/g, '~$1').replace(/\&/g, args.alias).replace(/\~([a-z]+\;)/g, '\&$1') : tag;
			frag.innerHTML 	= html;
			el = _template(frag);	
		}else if (_.is.str(tag)){
			var data = _.str.parse(tag, 'selector');
			el = _create(data.tag);
			
			if (data.class)  args.class = [].concat(args.class || [], data.class);
			if (data.attrs)  args.attrs = _.extend(data.attrs, args.attrs || {});
			if (data.props)  args.props = _.extend(data.props, args.props || {});
			if (data.events) args.events = _.extend(data.events, args.events || {});
		}

		_.dom.update(el, args);

		if (args.return === 'array'){
			return _.toArray(el);
		}else if (args.return === 'frag'){
			var frag = $doc.createDocumentFragment();

			for (var i in el){
				frag.appendChild(el[i]);
			}

			el = frag;
		}else if (args.return === 'html'){
			return el.innerHTML;
		}else if (args.return === 'extract'){
			return _.dom.extract(el, {'alias':args.alias});
		}

		return el;
	};

	this.update = function (els, args, alias){
		args        = args || {};
		args.class  = args.class || null;
		args.style  = args.style || null;
		args.attrs  = args.attrs || null;
		args.data   = args.data || null;
		args.alias  = 'alias' in args ? args.alias : alias;
		args.html   = 'html' in args ? args.html : ('children' in args ? args.children : null);
		args.add 	= args.add || args.parent || '';

		// merge all classnames
		if ('class' in args || 'classname' in args || 'classnames' in args){
			args.class = args.class || args.classname || args.classname;
		}		

		var parent     = args.add ? _.dom.get(args.add) : null;
		var classnames = _.is.valid(args.class) ? args.class : null;

		_.dom.els(els, function (el){
			if ('id' in args) 			el.id = args.id;
			if (classnames !== null) 	_.dom.classnames(el, classnames, args.alias);
			if (args.props)				_.dom.props(el, args.props);
			if (args.attrs)				_.dom.attrs(el, args.attrs);
			if (args.style)				_.dom.style(el, args.style);
			if (args.data)				_.dom.data(el, args.data);
			if (args.events)			_.dom.event(el, args.events, {'ctx':args.ctx});
			if (args.html !== null)		_.dom.html(el, args.html);
			if (parent)					parent.appendChild(el);
			
			// args.value    = 'value' in args ? args.value : null;
			// args.context  = args.context || null;
			// args.replace  = args.replace || {};
		});
	};

	this.add = function (els, position, target, args){
		if (target === undefined){
			target   = position;
			position = null;
		}
		
		var target = _.dom.get(target);
		if (!target || els === target) return;
		
		if (_.is.bool(args)){
			args = {'text':args};
		}

		args             = args || {};
		args.text        = args.text || false;                     // create textNode if it's not a selector
		args.assets      = 'assets' in args ? args.assets : true;  // add assets script/style to the page
		args.allChildren = args.children || true;                  // parent.children OR .childNodes
		// args.textNodes	 = 'textNodes' in args ? args.textNodes : true;

		if (!(els instanceof DocumentFragment)){
			els = _.dom.get.all(els, {
				'frag': true,
				'text': args.text,
			});
		}

		var el       = els.children[0];
		var parent   = target.parentNode;
		var assets   = _.dom.get.all('script,link[rel="stylesheet"]', {'ctx':els});
		var scripts  = [];
		// var eScripts = [];                                                           // external scripts
		// var iScripts = [];                                                           // inline scripts
		
		// parse the assests. remove unecessary <style>, <link> and <script>. then prepare the <script> to parse
		if (assets.length){
			// current assets
			var srcs    = [];
			var inlines = [];
			var ids     = [];
			
			_.dom.get.all('script,link[rel="stylesheet"]').map(function (n){ 
				if (n.href) 		srcs.push(n.href); 
				if (n.src) 			srcs.push(n.src);
				if (n.id)			ids.push(n.id);
				if (n.textContent)  inlines.push(n.textContent); // check for duplicate content
			});

			for (var i=0, l=assets.length; i<l; ++i){
				var asset = assets[i];
				var tag   = _.dom.tag(asset);
				var src   = asset.getAttribute('src') || asset.getAttribute('href');
				var id 	  = asset.getAttribute('id');
				var txt   = asset.textContent;

				// already exists, just remove from the html
				if (
					(src && !!~srcs.indexOf(src))
					|| (id && !!~ids.indexOf(id))
					|| (txt && !!~inlines.indexOf(txt))
				){
					_.dom.remove(asset);
					continue;
				}

				// _js(id, ids.indexOf(id), src, srcs.indexOf(src));

				// Inner HTML that needs to be eval()
				if (tag === 'script'){
					var inline = !!(!src && asset.childNodes.length)
					var value  = inline ? asset.innerHTML.trim() : src;
					
					scripts.push({
						'id'    : id,
						'el'	: asset,
						'value' : value,
						'inline': inline,
					});

					_.dom.remove(asset); // need to be removed, in case we re-use dom.add() on the same elements
				}
			}
		}

		if (parent){
			if (position === 'before'){
				parent.insertBefore(els, target);
			}else if (position === 'after'){
				parent.insertBefore(els, target.nextSibling);
			}else if (position === 'replace'){
				parent.insertBefore(els, target);
			}else if (position === 'wrap'){
				parent.insertBefore(els, target);
			}
		}
		
		if (position === 'wrap'){
			var deep = el;
			while (deep.children.length){ deep = deep.children[0]; }
			deep.appendChild(target);
		}else if (position === 'prepend'){
			target.insertBefore(els, target.childNodes[0]);
		}else if (position === 'html' || position === 'children'){
			target.innerHTML = '';
			target.appendChild(els);
		}else if (_.is.nbr(position)){
			var c = args.allChildren === 'all' ? target.childNodes : target.children;
			if (c[position]){
				target.insertBefore(els, c[position]);
			}else{
				target.appendChild(els);
			}
		}else if (position === 'replace'){
			parent && parent.removeChild(target);
		}else{
			target.appendChild(els);
		}

		// Go through all the scripts, add the external ones, and eval the inline ones
		if (scripts.length){
			// _warn(scripts);

			_.fn.batch(scripts, {
				'wait'  : true,
				'onEach': function (v, next){
					if (v.inline){
						var s = document.createElement('script');
						if (v.id) s.id = v.id;

						s.textContent = v.value;
						document.head.appendChild(s);
						next();
					}else{
						_.require(v.value, {
							'async'	  : false,
							'version' : false,
							// 'parent'  : document.body,
							'callback': next,
						});
					}
				},
			});
		}

		return el;
	};
	
	this.remove = function (els){
		return _.dom.els(els, function (el){
			el.parentNode && el.parentNode.removeChild(el);
		});
	};

	this.contains = function (els, child, includeSelf){
		child = _.dom.get(child);
		if (!child) return false;

		var is = false;
		_.dom.els(els, {'root':true}, function (el){
			if (includeSelf && el === child){
				is = true;
			}
			if (!is && child && el.contains && el.contains(child)){
				is = true;
			}
			if (is){
				return BREAK;
			}
		});

		return is;
	};

	// nodes -------------------------------------------------------------------
	/**
	 * Search through the DOM for one (or many) nodes. Can also create a new node (if args.text is true)
	 * @alias utils.dom.get
	 * 
	 * @param {*} selector 
	 * @param {*} args 
	 * @param {*} callback 
	 * @param {*} ctx 
	 * 
	 * @returns {HTMLElement | Node[]}
	 */
	this.get = function (selector, args, callback, ctx){
		if (_.is.fn(args)){
			ctx      = callback;
			callback = args;
			args     = {};
		}else if (args === true){
			args = {'all':true};
		}

		args          = args || {};
		args.ctx      = args.ctx || ctx || $doc;
		args.include  = args.include || false;      // Include the contexts into the return elements
		args.parent   = args.parent || false;       // the context needs to be the current parent selector
		args.prop 	  = args.prop || false;			// the context needs to be saved as a prop (will replace args.parent)

		args.closest   = args.closest || false;                        // get the closest parent
		args.filter    = args.filter || null;
		args.alias     = args.alias || '';
		args.frag      = args.frag || false;                           // turn into documentFragment
		args.text      = args.text || false;                           // create nodes IF the selector is a string (and not a CSS selector)
		args.window    = args.window || false;							// if window is passed, it can be used
		// args.textNodes = 'textNodes' in args ? args.textNodes : true;
		args.callback  = args.callback || callback;
		args.remove    = args.remove || false;
		args.query 	   = args.query || false;			// transform to Query object
		args.all       = args.all || false;          	// by default, a frag returns all elements

		if (args.callback === true){
			args.all      = true;
			args.callback = null;
		}
		if ('self' in args){
			args.include = args.self;
		}

		var isRoot 	 = false;
		var isNew 	 = false;
		var elements = [];
		var els      = null;

		// context -------------------------------------------------------------
		var ctxs = args.ctx;
		
		// @source jQuery code
		if (_.is.str(ctxs) && !!~ctxs.indexOf('<')){
			var doc = $doc.implementation.createHTMLDocument("");
			doc.body.innerHTML = ctxs;
			ctxs = doc.documentElement;
		}
	
		ctxs = _.is.arr(ctxs) ? ctxs : [ctxs];

		// validate the contexts
		var ctx, all = [];
		for (var i=0, l=ctxs.length; i<l; ++i){
            ctx = _.is.str(ctxs[i]) ? _.dom.get(ctxs[i]) : ctxs[i];
			if (!ctx) continue;
			
			all.push(ctx);
            
			// include the current context if it's the same thing as the selector
			if (args.include && _.dom.is(ctx, selector)){
				elements.push(ctx);
			}
		}
		ctxs = all;

		function _alias (s, isSelector){
			var a = (isSelector ? '.' : '') + args.alias;
			return _.toAlias(s, a);
		}

		// elements ------------------------------------------------------------
		if (args.window && selector === window){
			elements.push(selector);
		}else if (_.is.node(selector) || _.is.el(selector, args.tag)){
			elements.push(selector);
		}else if (_.is.str(selector) && (args.text || selector.trim()[0] === '<' || ~selector.indexOf('&'))){
			isNew    = true;
			elements = _.dom.create(selector, {
				'return' : 'array',
				'alias'	 : args.alias,
				'parent' : args.parent,
			});
		}else if (_.is.either(selector, 'str,fn')){
			// selector for ID that starts with a number breaks, so instead we convert them to attribute selector
			selector = _alias(selector, true);
			selector = _.is.str(selector) ? selector.replace(/(?:(?:^|\s)#([^\s]+))/g, '[id="$1"]') : selector;

			for (var i=0, l=ctxs.length; i<l; ++i){
				ctx = ctxs[i];
				els = [];

				if (_.is.fn(selector)){
					els = selector.call(ctx, ctx);
				}else if (ctx && _.is.fn(ctx.querySelectorAll)){
					// skip back to the root for the ctx
					if (selector.indexOf(':root') === 0){
						isRoot = true;      // skip the "parent" filter checkup when using ":root"
						ctx    = document;
					}

					if (CONSTS.SUPPORT.SCOPE === undefined && !!~selector.indexOf(':scope')){
						try{
							$doc.querySelector(':scope *');
							CONSTS.SUPPORT.SCOPE = true;
						}catch (e){
							CONSTS.SUPPORT.SCOPE = false;
						};
					}

					try{
						if (ctx !== $doc && !(ctx instanceof DocumentFragment) && CONSTS.SUPPORT.SCOPE === false){
							var v = _.random('attr_');
							var s = selector.replace(':scope', '[' + v + ']');

							ctx.setAttribute(v, '');
							els = ctx.querySelectorAll(s);
							ctx.removeAttribute(v);
						}else{
							els = ctx.querySelectorAll(selector);
						}
					}catch (e){}
				}

				// add temporarely the "ctx" to the els
				for (var i in els){
					els[i].$ctx = ctx;
				}

				els      = _.toArray(els);
				elements = elements.concat(els);
			}
		}else if (_.is.list(selector)){
			selector = _.toArray(selector);
			for (var i=0, l=selector.length; i<l; ++i){
				els      = _.dom.get(selector[i], {'ctx':ctxs, 'all':args.all, 'textNodes':args.textNodes});
				elements = elements.concat(els);
			}
		}

		elements = _.$arr(elements);

		var all = elements;

		// the found elements needs to be inside that specific parent matching the context (unless it's newly created)
		if (!isNew && _.is.either(args.parent, 'str,fn')){
			els = [];

			for (var i in elements){
				var el = elements[i];
				var p  = null;

				// go through the parents and test all parents
				if (_.is.fn(args.parent)){
					var n = el;
					while (n){
						p = args.parent(n, isRoot);
						
						// parent filter will return "false" is all ok, or the Node if it's valid
						if (p === false || _.is.el(p)){
							break;
						}

						n = n.parentElement;
					}
				}else{
					p = _.dom.closest(el, args.parent);
				}
				
				(!p || ~ctxs.indexOf(p)) && (els.push(el));
			}
			elements = els;
		}

		// filter the elements
		if (_.is.fn(args.callback) || args.closest || args.filter || args.remove){
			els = [];
			for (var i in elements){
				var el = elements[i];

				// closest
				if (args.closest && !(el = _.dom.closest(elements[i], args.closest))){
					continue;
				}

				// filter type
				if (args.filter && !_.dom.is(el, args.filter)){
					continue;
				}

				// remove
				if (args.remove && el.parentNode){
					el.parentNode.removeChild(el);
				}

				var response = args.callback ? _.apply(args.callback, [el]) : el;
				if (_.is.def(response)){
					el = response;
				}
				if (el){
					els.push(el);
				}

				// stop here if only 1 item
				if (el && !args.all){
					break;
				}
			}
			elements = els;
		}

		// remove the temporary CTX
		for (var i in all){
			delete(all[i].$ctx);
		}

		// only get the first element
		if (!args.all && elements.length){
			elements = [elements[0]];
		}

		// turn the elements into a fragment
		if (args.frag){
			els = $doc.createDocumentFragment();
			for (var i in elements){
				els.appendChild(elements[i]);
			}
			return els;
		}

		if (args.query){
			return _.$$(elements);
		}

		return args.all ? elements : elements[0];
	};

	this.get.ctx = function (ctx, selector, args, callback){
		return _.dom.get(selector, args, callback, ctx);
	};

	this.get.all = function (selector, args, callback, ctx){
		if (_.is.fn(args)){
			ctx 	 = callback;
			callback = args;
			args     = {};
		}

		args     = args || {};
		args.ctx = args.ctx || ctx;
		args.all = true;

		return _.dom.get(selector, args, callback);
	};

	this.get.all.ctx = function (ctx, selector, args, callback){
		return _.dom.get.all(selector, args, callback, ctx);
	};

	// Get only the text nodes
	this.get.text = function (els, callback){
		var n, texts=[];
		_.dom.els(els, function (el){
			var walk=document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
			while(n=walk.nextNode()){
				if (
					!n.textContent.trim()          				// nothing inside
					|| _.dom.closest(n, 'pre, svg, script')   	// skip all text nodes in <pre>, <svg> and <script>
				) continue;
		
				n = _.apply(callback, [n]);

				if (n){
					texts.push(n);
				}				
			}
		});
		return texts;
	};

	this.extract = function (el, args){
		if (_.is.str(args)){
			args = {'single':args};
		}else if (_.is.arr(args)){
			args = {
				'single': args[0],
				'group' : args[1],
			};
		}

		args        = args || {};
		args.self 	= args.self || false;
		args.parent = args.parent || false;
		args.single = 'single' in args ? args.single : 'el';
		args.group  = 'group' in args ? args.group : 'els';
		args.clean  = args.clean || false;                         // remove the attribute
		args.alias 	= args.alias || null;
		args.format = args.format || null;							// format the node found (eg.: for adding/changing the attributes)
		// args.filter = args.filter || null;
		// args.ctx    = args.ctx || null;

		var items    = {'self':el};
		var single   = args.single ? '[' + args.single + ']' : null;
		var group    = args.group ? '[' + args.group + ']' : null;
		var selector = '';

		if (single && group)	selector = [single, group].join(',');
		else if (single) 		selector = single;
		else if (group)			selector = group;

		var children = _.dom.get.all(selector, {
			'ctx'    : el,
			'include': args.self,
			'parent' : args.parent,
		});

		function _add (name, node, isArray){
			if (!name) return;

			// modifiers
			var remove = !!~name.indexOf('!remove');
			name = name.replace(/!.+/, '').trim();

			var attr = '';
			if (isArray){
				attr 		= args.group;
				items[name] = items[name] || [];
				items[name].push(node);
			}else{
				attr 		= args.single;
				items[name] = node;
			}

			if (args.clean){
				node.removeAttribute(attr);
			}

			// automaticly add a &--alias classname
			if (args.alias){
				_.dom.addClass(node, '&--' + name, args.alias);
			}

			if (args.format){
				_.apply(args.format, [node, name]);
			}

			if (remove){
				node.parentNode.removeChild(node);
			}
		}
		
		for (var i=0, l=children.length; i<l; ++i){
			var child 	= children[i];
			var single  = args.single ? child.getAttribute(args.single) : null;
			var group 	= args.group ? child.getAttribute(args.group) : null;

			// single = _.format(single, args.filter, args.context);
			// group  = _.format(group, args.filter, args.context);

			_add(single, child);
			_add(group, child, true);
		}

		return items;
	};

	this.parents = function (el, args, single){
		var el      = _.dom.get(el);
		var parents = [];
		if (!el) return parents;

		if (_.is.str(args)){
			args = {'selector':args};
		}

		args              = args || {};
		args.selector     = args.selector || null;
		args.until        = args.until || null;
		args.includeSelf  = args.includeSelf || false;
		args.includeUntil = 'includeUntil' in args ? args.includeUntil : true;
		args.filter 	  = args.filter || null;
		args.single 	  = 'single' in args ? args.single : single;

		if (!args.includeSelf){
			el = el.parentNode;
		}

		while (el){
			var stop = _.dom.is(el, args.until);
			if (stop && !args.includeUntil){
				break;
			}

			if (!args.selector || (args.selector && _.dom.is(el, args.selector))){
				var v = _.apply(args.filter, [el]);
				_.is(v) && parents.push(v);
			}

			if (args.single && parents.length){
				break;
			}

			if (stop){
				break;
			}

			el = el.parentNode;
		}

		return args.single ? parents[0] : parents;
	};

	this.parent = function (el, selector, args){
		return this.parents(el, selector, true);
	};


	this.closest = function (el, selector, args){
		var el = _.dom.get(el);
		if (!el) return;

		args       = args || {};
		args.until = args.until || null;

		var until = _.dom.get(args.until);		
		if (_.is.fn(el.closest) && _.is.str(selector)){
			el = el.closest(selector);
			el = el && until && el.contains(until) ? null : el;
		}else{
			var closest = null;
			while (el && !closest){
				if (_.dom.is(el, selector)){
					closest = el;
				}
				if (closest || el === until){
					break;
				}
				el = el.parentNode;
			}
			el = closest;
		}
		
		return el;
	};

	this.offsetParent = function (el){
		el = _.dom.get(el);
		if (!el) return;

		if (el.offsetParent){
			return el.offsetParent;
		}else{
			// for some elements, the offsetParent is always null
			while (el && el !== document){
				el = el.parentNode;
				var style = window.getComputedStyle(el);
				if (style.position !== 'static'){
					return el;
				}
			}

			return window.body;
		}
	};

	/**
	 * Find the first (or all) scroll parent from the element.
	 * @alias utils.dom.scrollParent
	 * 
	 * @param {node}		el				HTML Element
	 * @param {object}		[args]		
	 * @param {object}		args.fallback	Fallback node/element to return if nothing is found
	 * @param {string}		args.direction  Check which direction the scrollbars are active [any, vertical, horizontal]
	 * @param {boolean} 	args.strict 	Scrollbar needs to be visibly there (either SCROLL or the content is bigger than the container)
	 * @param {boolean}		args.all		Return all the scrollParent
	 */
	this.scrollParent = function (el, args){
		if (args === false){
			args = {
				'strict'  : true,
				'fallback': false,
			};
		}

		el 				= _.dom.get(el);
		args 			= args || {};
		args.fallback 	= 'fallback' in args ? args.fallback : $win;
		args.direction 	= 'direction' in args ? args.direction : 'any';
		args.strict 	= 'strict' in args ? args.strict : false;		
		args.all 		= args.all || false;

		if (!el) return args.fallback;

		var parents = [], style, oWidth, sWidth, cWidth, oHeight, sHeight, cHeight, isScrollW, isScrollH;
		while (el && ((!parents.length && !args.all) || args.all)){
			style     = _.is.el(el) ? $win.getComputedStyle(el) : null;
			oWidth    = style ? style.getPropertyValue('overflow-x') : null;
			sWidth    = el.scrollWidth;
			cWidth    = el.clientWidth
			oHeight   = style ? style.getPropertyValue('overflow-y') : null;
			sHeight   = el.scrollHeight;
			cHeight   = el.clientHeight;
			isScrollW = oWidth === 'scroll' || (oWidth === 'auto' && (!args.strict || sWidth > cWidth));
			isScrollH = oHeight === 'scroll' || (oHeight === 'auto' && (!args.strict || sHeight > cHeight));

			if (
				(args.direction === 'any' && (isScrollW || isScrollH)) ||
				(args.direction === 'both' && isScrollW && isScrollH) ||
				(args.direction === 'vertical' && isScrollH) ||
				(args.direction === 'horizontal' && isScrollW)
			){
				parents.push(el);
			}

			el = el.parentNode;
		}

		if (args.fallback){
			parents.push(args.fallback);
		}
		
		return args.all ? parents : parents[0];
	};
	
	this.children = function (el, args, single){
		var el       = _.dom.get(el);
		var children = [];
		if (!el) return children;

        if (_.is.bool(args)){
            args = {'text':args};
        }else if (_.is.str(args)){
			args = {'selector':args};
		}

		args          = args || {};
		args.text     = 'text' in args ? args.text : false;			// include TextNode
		args.selector = 'selector' in args ? args.selector : null;	// filter the nodes with a selector
		args.single   = args.single || single;
			
        var children = [];
		if (el.children && !args.text){
			children = el.children || [];
		}else{
			var nodes    = el.childNodes;
			var children = [];
			var i=0, node;
			while (node = nodes[i++]){
				if (node.nodeType === 1 || (args.text && node.nodeType === 3)){
					children.push(node);
				}
			}
		}		

		children = _.toArray(children, function (node){
			return !args.selector || _.dom.is(node, args.selector) ? node : null;
		});

		if (args.single){
			children = children[0];
		}

		return children;
	};

	this.siblings = function (el, args, single){
		var el       = _.dom.get(el);
		var children = [];
		if (!el) return children;

		if (_.is.bool(args)){
            args = {'text':args};
        }else if (_.is.str(args)){
			args = {'selector':args};
		}

		args          = args || {};
		args.text     = 'text' in args ? args.text : false;
		args.previous = 'previous' in args ? args.previous : true;
		args.next     = 'next' in args ? args.next : true;
		args.selector = args.selector || null;
		args.single   = 'single' in args ? args.single : single;

		if (args.selector === ':previous'){
			args.previous = true;
			args.next     = false;
			args.selector = null;
		}else if (args.selector === ':next'){
			args.previous = false;
			args.next     = true;
			args.selector = null;
		}

		var els  = [];
		var node = el;
		if (args.previous){
			while (node = node.previousSibling){
				if (node.nodeType !== 1 && !(args.text && node.nodeType === 3)) continue;
				els.unshift(node);
			}
		}

		var node = el;
		if (args.next){
			while (node = node.nextSibling){
				if (node.nodeType !== 1 && !(args.text && node.nodeType === 3)) continue;
				els.push(node);
			}
		}

		els = _.toArray(els, function (node){
			return !args.selector || _.dom.is(node, args.selector) ? node : null;
		});
        
		return args.single ? els[0] : els;
	};

	// attrs/props -------------------------------------------------------------
	this.index = function (el, selector){
		if (!_.is.node(el)) return -1;

		var children = [];
		if (selector === true){
			children = el.parentNode ? el.parentNode.childNodes : [];
		}else if (selector){
			children = selector;
		}else if (el.parentNode){
			children = el.parentNode.children;
		}
		children = children && children.length ? _.dom.get.all(children) : [];

		return children.indexOf(el);
	};

	/**
	 * Return the tag of a node element
	 * 
	 * @memberof utils.dom
	 * @function tag
	 * 
	 * @example 
	 * var el = document.createElement('div');
	 * utils.dom.tag(el);
	 * // "div"
	 * 
	 * utils.dom.tag(el, 'span');
	 * // <span>
	 * 
	 * @param {*} 				el 			Node element
	 * @param {boolean|string} [replace] 	Change or remove the tag of the element
	 * 
	 * @returns {string}
	 */
	this.tag = function (el, replace){
		var tag = (el ? el.tagName || '' : '').toLowerCase();
	
		if (tag && replace){
			if (tag !== replace){
				var children = _.dom.get.all(el.childNodes, {'frag':true});

				if (_.is.str(replace)){
					var attrs = _.dom.attrs(el);

					replace = $doc.createElement(replace);
					_.dom.attrs(replace, attrs);
					_.dom.add(replace, 'replace', el);
					_.dom.add(children, replace);

					el = replace;
				}else{
					_.dom.add(children, 'replace', el);
				}
			}

			return el;
		}

		return tag;
	};

	this.props = this.prop = function (els, key, value){
        var set = _.toSet(key, value);
		els = _.dom.get(els, true);

        if (set){
			_.dom.els(els, function (el){ 
				var i, v;
				for (i in set){
					v = set[i];
					if (_.is.fn(el[i])){
						el[i].apply(null, v);
					}else{
						el[i] = v;
					}
				};
			}, false);
        }else if (els[0] && key){
            return els[0][key];
        }else{
            return null;
        }
    };
	
	this.attrs = this.attr = function (els, key, value){
		var set = _.toSet(key, value);
		els = _.dom.get(els, true);

		// clear the attributes of the elements
		if (key === false){
			value = _.$arr(value);
			_.dom.els(els, function (el){ 
				_.$arr(el.attributes, function (attr){
					if (value.length && ~value.indexOf(attr.name)) return;
					el.removeAttribute(attr.name);
				});
				_.cache(el, DOM.CACHE.ATTRS, null);
			});
		}else if (set){
			var hasChanged = false;
			_.dom.els(els, function (el){ 
				var cache = value === true ? {} : _.cache(el, DOM.CACHE.ATTRS) || {};
				var i, v;
				for (i in set){
					v = set[i];
					if (v === cache[i]) continue;

					cache[i]   = v;
					hasChanged = true;

					if (_.is.not(v)){
						el.removeAttribute(i);
					}else{
						v = v === true ? '' : v;

						if (i in DOM.SVG_NAMESPACES){
							el.setAttributeNS(DOM.SVG_NAMESPACES[i], i, v);
						}else{
							el.setAttribute(i, v);
						}
					}
				};

				_.cache(el, DOM.CACHE.ATTRS, cache);
			}, false);
			return hasChanged;
		}else if (els[0] && key){
			return els[0].getAttribute(key);
		}else if (els[0]){
			return _.each(els[0].attributes, function (v, i){
				return {
					'$id'   : v.name.toString(),
					'$value': v.value.toString(),
				};
			});
		}

		return null;
	};

	this.data = function (els, key, value){
		var set = _.toSet(key, value);
		els = _.dom.get(els, true);
		els = set ? els : [els[0]];

		// get the data cached first 
		_.dom.els(els, function (el){
			var cache = value === true ? null : _.cache(el, DOM.CACHE.DATA);
			if (cache) return;
			
			var script = _.dom.get(':scope > script[type="json/data"]', {'ctx':el});
			script && _.dom.remove(script);
			cache = (script ? _.toJson(script.innerHTML) : null) || {};

			_.each(el.attributes, function (v, i){
				if (v.name.indexOf('data-') !== 0) return;
				i = v.name.toString().replace('data-', '');
				i = _.toSlug(i, 'camel');
				v = _.toValue(v.value.toString(), {'arr':false});
				cache[i] = v;
			});

			_.cache(el, DOM.CACHE.DATA, cache);
		});

		if (set){
			var hasChanged = false;
			_.dom.els(els, function (el){ 
				var cache = _.cache(el, DOM.CACHE.DATA);
				var i, v;

				for (i in set){
					v = set[i];
					if (cache[i] === v) continue;
					cache[i]   = v;
					hasChanged = true;
				}; 

				_.cache(el, DOM.CACHE.DATA, cache);
			}, false);
			return hasChanged;
		}else if (els[0]){
			var cache = _.cache(els[0], DOM.CACHE.DATA);
			return key ? cache[key] : cache;
		}

		return null;
	};

	this.value = function (el, value, data){
		el = _.dom.get(el);
		if (!el) return;

		var type = el.hasAttribute('contenteditable') ? 'html' : el.tagName.toLowerCase();
		if (type === 'input'){
			type = el.type || 'text';
		}

		if (value === undefined){
			// custom function to get the value
			value = _.apply(el.get, null, {'ctx':el});
			
			if (!_.is.valid(value)){
				if (type === 'file'){
					value = el.multiple ? _.toArray(el.files) : (el.files[0] || '');
				}else if (type === 'radio' || type === 'checkbox'){
					if (el.checked){
						value = el.hasAttribute('value') ? el.value : true;
					}else{
						value = false;
					}
				}else if (type === 'html'){
					value = el.innerHTML;
				}else if (type === 'select'){
					var values = [];
					var i, l, v;
					for (i=0, l=el.options.length; i<l; ++i){
						v = el.options[i];
						if (v.selected){
							values.push(v.value);
						}
					}
					if (el.multiple){
						value = values;
					}else{
						value = values[0] === undefined ? -1 : values[0];
					}
				}else{
					value = el.value;
				}
			}

			value = _.is.str(value) ? value.trim() : value;

			return _.toValue(value);
		}else{
			if (type === 'file' && !value){
				el.value = ''; // all that can be done for files is to be reset
			}else if (type === 'radio' || type === 'checkbox'){
				if (value instanceof Array){
					// the indexOf needs to be compared with strings
					el.checked = !!~value.join().split(',').indexOf(el.value);
				}else if (el.hasAttribute('value')){
					el.checked = el.value == value;
				}else{
					el.checked = !!value;
				}
			}else if (type === 'select'){
				var values = (value instanceof Array ? value : [value]).map(function (v){ return v.toString(); });
				var isSet  = false;
                var i, l, v;

				for (i=0, l=el.options.length; i<l; ++i){
					v = el.options[i];
					if (~values.indexOf(v.value)){
						v.selected = true;
						isSet = true;
					}else{
						v.selected = false;
					}
				}

				if (!isSet){
					el.selectedIndex = -1;
				}
			}else{
				if (_.is.str(value) && data){
					value = _.str.replace(value, data);
				}else if (_.is.obj(value)){
					value = JSON.stringify(value);
				}
				
				if (type === 'html'){
					el.innerHTML = value;
				}else{
					el.value = value;
				}
			}

			// Set the value of the element "helper", but skip the loop that it can force
			if (!el.__busy__){
				el.__busy__ = true;
				_.apply(el.set, [value], {'ctx':el});
				_.dom.trigger(el, 'change-value', {'value':value});
				el.__busy__ = false;
			}
		}
	};

	this.values = function (el, key, value, args){
		if (key === true){
			key  = null;
			args = {'all':true};
		}

		if (_.is.fn(key)){
			args  = {'format':key};
			key   = undefined;
			value = undefined;
		}
		if (_.is.fn(args)){
			args = {'format':args};
		}
		args        = args || {};
		args.format = args.format || null;
		args.all    = args.all || false;

		var inputs 	 = _.dom.get.all('input,textarea,select,[contenteditable]', {'ctx':el});
		var values   = _.toSet(key, value);
		var isSet    = key === false || !!values;
		if (!isSet) values = {};

		for (var i=0, l=inputs.length; i<l; ++i){
			var input = inputs[i];
			var name  = (input.getAttribute('name') || '');
			var alt   = (input.getAttribute('alt-name') || '');	// for choice fields (eg.: checkbox, radio), when using similar <form> on the same page with different input names, but needs to have the same name in the end

			name = alt || name;

			if (!name) continue;

			var type = input.hasAttribute('contenteditable') ? 'html' : input.tagName.toLowerCase();
			type = (type === 'input') ? (input.type || 'text') : type;

			var isToggle = type === 'checkbox' || type === 'radio';

			if (isSet){
				// TODO deal with alt-name for setting a input

				var value = key === false ? '' : _.get(values, name);

				// if (isToggle && _.is.arr(value)){

				// }
				// if ( && ){

				// }
				// _js(name, value);
				// var value = key === false ? '' : values[name];

				// deal with array of checkboxes/radio


				// TODO deal with all the types

				_.dom.value(input, value);
			}else{
				// make sure the toggle field exists in the list
				if (args.all && isToggle){
					var current = _.get(values, name);
					if (current === undefined){
						_.set(values, name);
					}
				}

				if (
					(type === 'hidden' && input.checked)	// skip hidden that are checked
					|| (isToggle && !input.checked)			// skip toggle that aren't checked
				) continue;

				var value = _.dom.value(input);
				value = _.apply(args.format, [value, input, type]);
				
				_.is.valid(value) && _.set(values, name, value);
			}
		}

		return values;
	};

	this.scroll = function (el, args){
		el = _.dom.get(el || $win, {'tag':true});

		if (_.is.str(args)){
			args = {'key':args};
		}else if (args === true){
			args = {'parent':true};
		}

		args        = args || {};
		args.key    = args.key || null;
		args.parent = args.parent || false;

		// find the nearest scroll parent
		el = args.parent ? _.dom.scrollParent(el) : el;
		
		var root = _.is.el(el, ':root');
		var doc  = $html;
		var x 	 = root ? $win.pageXOffset : el.scrollLeft;
		var y 	 = root ? $win.pageYOffset : el.scrollTop;
		var w 	 = root ? $html.scrollWidth : el.scrollWidth;
		var h 	 = root ? $html.scrollHeight : el.scrollHeight;
		var cw 	 = root ? Math.max(doc.clientWidth, $win.innerWidth) : el.offsetWidth;
		var ch 	 = root ? Math.max(doc.clientHeight, $win.innerHeight) : el.offsetHeight;
		var mx   = w - cw - (root ? 0 : 1);
		var my 	 = h - ch - (root ? 0 : 1);

		var data = {
			'target'      : el,
			'x'           : x,
			'y'           : y,
			'top'         : y,
			'right'       : x + cw,
			'bottom'      : y + ch,
			'left'        : x,
			'width'       : w,
			'height'      : h,
			'clientWidth' : cw,
			'clientHeight': ch,
			'max'		  : {
				'x' 	  : mx,
				'y' 	  : my,
			},
			'ratio'		  : {
				'x'		  : _.math.clamp(Math.round(x) / mx) || 0,
				'y'		  : _.math.clamp(Math.round(y) / my) || 0,
			},
			'has' 		  : {
				'x'		  : mx > 0,
				'y'		  : my > 0,
			},
			'is'		  : {
				'start'	  : x === 0 && y === 0,
				'startX'  : x === 0,
				'startY'  : y === 0,
				'end'	  : (x >= mx || w <= cw) && (y >= my || h <= ch),
				'endX'	  : x >= mx || w <= cw,
				'endY'	  : y >= my || h <= ch
			}
		};

		return args.key ? data[args.key] : data;
	};

	// [ ] Be able to use the "margin" bounds for scrollIntoView for Elements
	// [ ] Cancel the "autoScroll" if the user used his mouse
	// [ ] Do not start an scroll animation if already at the position
	this.scrollTo = function (el, args, callback){
		if (_.is.arr(args)){
			args = {'x':args[0], 'y':args[1]};
		}else if (_.is.nbr(args)){
			args = {'y':args};
		}else if (_.is.obj(el, true)){
			callback = args;
			args     = el;
			el       = window;
		}

		args                   = args || {};
		args.x                 = 'x' in args ? args.x : null;                                  // if x = true, then it's the el LEFT position
		args.y                 = 'y' in args ? args.y : null;                                  // if y = true, then it's the el TOP position
		args.ratio             = 'ratio' in args ? args.ratio : 0;                         // when it's scrollIntoView kind of thing, ratio:false will try to get to the nearest 
		args.offset			   = args.offset || null;
		args.offsetX           = args.offsetX || 0;
		args.offsetY           = args.offsetY || 0;
		args.delay             = "delay" in args ? args.delay : 0;
		args.duration          = "duration" in args ? args.duration : 0;
		args.easing            = args.easing || null;                                          // TODO
		args.parent            = args.parent || false;                                         // If the current element isnt' a scrollable parent, go to the closest one
		// args.autoScroll		   = 'autoScroll' in 
		// history.scrollRestoration
		
		args.ctx               = args.ctx || null;
		args.callback          = args.callback || callback;
		args.scrollRestoration = 'scrollRestoration' in args ? args.scrollRestoration : true;
	
		// scroll restoration skipping (when the page is loading)
		!args.scrollRestoration && (history.scrollRestoration = 'manual');

		// Find the parent to scroll
		el = el ? el : window;
		el = el === window ? el : _.dom.get(el);
		if (!el) return;

		var x        = args.x;
		var y        = args.y;
		var isDouble = false;

		// it's targeting the current el, so it's a "scroll-into-view"
		if (x === true || y === true){
			var child   = el;
			var parent  = el = _.dom.scrollParent(el);
			var pBounds = _.dom.bounds(parent);
			var pScroll = _.dom.scroll(parent);
			var cBounds = _.dom.bounds(child, {'parent':parent});

			var h = pBounds.pbox.height - cBounds.height;
			var w = pBounds.pbox.width - cBounds.width;
			var x = null;
			var y = null;
			var r = args.ratio || 0;

			// try to show the nearest position
			if (args.ratio === false){
				if (cBounds.top - pScroll.top < 0) 			y = cBounds.top;
				else if (cBounds.top - pScroll.top > h)		y = cBounds.top - h;
				if (cBounds.left - pScroll.left < 0) 		x = cBounds.left;
				else if (cBounds.left - pScroll.left > w)	x = cBounds.left - w;
			}else{
				x = cBounds.left - (r * w);
				y = cBounds.top - (r * h);
			}
			
			x = args.x === true ? x : args.x;
			y = args.y === true ? y : args.y;

			// Will check if the scroll position has changed (when _done() is called)
			isDouble = function (){
				var bounds = _.dom.bounds(child, {'parent':parent});
				return (bounds.y|0) === (cBounds.y|0) && (bounds.left|0) === (cBounds.left|0) ? false : child;
			};
		}else if (args.parent){
			el = args.parent === true ? el : _.dom.get(args.parent);
			el = _.dom.scrollParent(el);
		}
		
		var isRoot   = _.is.el(el, ':root');
		var current  = _.dom.scroll(el);
		var from     = {'x':current.x, 'y':current.y};
		var to       = {'x':x, 'y':y};
		var key      = '$scrollTo';

		function _calc (v, from, max){
			if (_.is.str(v, /^\+\=/)){
				v = from + (+v.replace('+=', '') || 0);
			}else if (_.is.str(v, /^\-\=/)){
				v = from - (+v.replace('-=', '') || 0);
			}else if (_.is(v)){
				v = _.calculate(v, max);	
			}
			return v;
		}
		function _scroll (x, y){
			if (from.x === to.x) x = null;
			if (from.y === to.y) y = null;
			
			if (isRoot){
				if (!_.is.nbr(x)) x = window.pageXOffset;
				if (!_.is.nbr(y)) y = window.pageYOffset;

				window.scrollTo(x, y);
			}else{
				if (_.is.nbr(x)) el.scrollLeft = x;
				if (_.is.nbr(y)) el.scrollTop = y;
			}
		}
		function _tick (e){
			var x = from.x + ((to.x - from.x) * e.ratio);
			var y = from.y + ((to.y - from.y) * e.ratio);
			_scroll(x, y);
			e.isEnd && _done();
		}
		function _done (){
			// clear the animation
			_.cache(el, key, null);

			var double = isDouble && isDouble();
			if (double){
				_.dom.scrollTo(double, args);
			}else{
				_.apply.ctx(args.ctx, args.callback);
			}
		}

		// calculate the percent x/y OR the transition
		if (_.is.str(to.x) || _.is.str(to.y) || args.duration){
			to.x = _calc(to.x, from.x, current.max.x);
			to.y = _calc(to.y, from.y, current.max.y);
		}

		var offsetX = args.offsetX || 0;
		var offsetY = args.offsetY || 0;	
		
		if (_.is.fn(args.offset)){
			// TODO
		}else if (_.is.either(args.offset, 'str,el')){
			var offset = _.dom.get(args.offset);
			var bounds = _.dom.bounds(offset);
			offsetX -= bounds.bbox.width;
			offsetY -= bounds.bbox.height;
		}else if (_.is.nbr(args.offset)){
			offsetX += (+args.offset);
			offsetY += (+args.offset);
		}

		if (_.is(to.x)) to.x += offsetX;
		if (_.is(to.y)) to.y += offsetY;

		var cache = _.cache(el);
		_.cancel(cache[key]); 	 // stop the previous scroll animation

		cache[key] = _.fn.tick({
			'delay'	  : args.delay,
			'duration': args.duration,
			'easing'  : args.easing
		}, _tick);

		return cache[key];
	};

	this.reflow = function (els, redraw){
		_.dom.els(els, function (el){
			redraw && (el.style.display = 'none');
			el.offsetHeight; 
			redraw && (el.style.display = '');
		});
	};

	this.bounds = function (el, args){
		if (!(el instanceof Selection || el instanceof Range || el === $win)){
			el = _.dom.get(el);
		}

		if (_.is.bool(args)){
			args = {'parent':args};
		}

		args         = args || {};
		args.bbox 	 = 'bbox' in args ? args.bbox : false;	// svg getBBox()
		args.offsetX = args.offsetX || 0;
		args.offsetY = args.offsetY || 0;
		args.offset  = args.offset || false;	// find the offset/relative parent, and the x/y will be according to that element
		args.parent  = args.parent || false;	// if parent=true, find the closest scrollable parent
		args.reflow  = args.reflow || false;	// force reflow before getting the coordinates

		if (el !== $win && _.is.el(el, ':root')){
			el = $doc.body;
		}

		var bounds = {
			'target'      : el,
			'parent'      : null,
			'offset'	  : null,
			'visible'     : _.dom.visible(el),
			'fit'		  : null,
			'fitX' 		  : null,
			'fitY' 		  : null,
			'x'           : 0,
			'y'           : 0,
			'w'			  : 0,
			'h'			  : 0,
			'width'       : 0,
			'height'      : 0,
			'top'         : 0,
			'right'       : 0,
			'bottom'      : 0,
			'left'        : 0,
			'center'	  : {'x':0, 'y':0},
			'padding'     : [0,0,0,0],
			'border'      : [0,0,0,0],
			'margin'      : [0,0,0,0],
			'scale'       : 0,
			'vbox'        : null, // view box
			'rbox'		  : null, // relative scroll view box (relative to the parent with scroll position)
			'cbox'		  : null, // content box
			'pbox'        : null, // padding box
			'bbox'        : null, // border box
			'mbox'        : null, // margin box
			'sbox'		  : null, // inside (content) box (the scrollWidth/scrollHeight)
			'media'		  : null,
		};

		bounds.padding.horizontal = bounds.padding.vertical = 0;
		bounds.border.horizontal  = bounds.border.vertical  = 0;
		bounds.margin.horizontal  = bounds.margin.vertical  = 0;

		function _sides (s, p){
			var d 	= ['top','right','bottom','left'];
			var vls = [];
			var i=0, l=d.length, k, v;
	
			for (; i<l; ++i){
				k = p.replace('{direction}', d[i]);
				v = parseFloat(s[k] || 0);
				vls.push(v);
			}
	
			vls.vertical 	= vls[0] + vls[2];
			vls.horizontal 	= vls[1] + vls[3];
	
			return vls;
		};
	
		// scrollWidth/ scrollHeight
		var sw=0, sh=0;

		// this is the browser viewport width/height
		if (el === $win){
			bounds.width  = $win.innerWidth;
			bounds.height = $win.innerHeight;
			sw            = document.documentElement ? document.documentElement.scrollWidth : 0;
			sh            = document.documentElement ? document.documentElement.scrollHeight : 0;
		// find dimension of text node OR text selection
		}else if ((el && el.nodeType === 3) || el instanceof Selection || el instanceof Range){
			// TODO get selection in INPUT/TEXTAREA: https://erikmartinjordan.com/get-caret-position-textarea-pixels

			var range, rect, parent;

			if (el instanceof Selection){
				parent 	= el.anchorNode.parentElement;
				range 	= el.getRangeAt(0);
			}else if (el instanceof Range){
				parent 	= el.startContainer.parentElement;
				range 	= el;
			}else{
				parent = el.parentElement;
				range  = $doc.createRange();
				range.selectNodeContents(el);
			}

			args.reflow && _.dom.reflow(parent);
			
			rect = range.getBoundingClientRect();
			
			// the parent element will tell us of the textNode is visible
			bounds.visible = _.dom.visible(parent);
			bounds.top     = rect.top;
			bounds.left    = rect.left;
			bounds.width   = rect.width;
			bounds.height  = rect.height;
			sw             = rect.width;
			sh             = rect.height;
		}else if (el && bounds.visible){
			args.reflow && _.dom.reflow(el);
			
			var s     	   = $win.getComputedStyle(el);
			var b 	  	   = args.bbox && el.getBBox ? el.getBBox() : el.getBoundingClientRect();
			bounds.left    = b.x || b.left;
			bounds.top 	   = b.y || b.top;
			bounds.width   = b.width;
			bounds.height  = b.height;
			bounds.padding = _sides(s, 'padding-{direction}');
			bounds.border  = _sides(s, 'border-{direction}-width');
			bounds.margin  = _sides(s, 'margin-{direction}');
			sw             = el.scrollWidth;
			sh             = el.scrollHeight;
		}

		var x=0, y=0, h=0, w=0;
		if (el && bounds.visible){
			x = bounds.left;                              // this is the x with the border
			y = bounds.top;                               // this is the y with the border
			h = (el.clientHeight || bounds.height || 0);  // this is the inner height without the border
			w = (el.clientWidth || bounds.width || 0);    // this is the inner width without the border
			x += args.offsetX;
			y += args.offsetY;

			if (args.offset){
				var offset = args.offset === true ? _.dom.offsetParent(el) : _.dom.get(args.offset);
				if (offset && offset !== document.body){
					var ob = offset.getBoundingClientRect();
					x -= ob.left;
					y -= ob.top;
				}
				bounds.parent = offset;
			}

			var parent = $win;
			if (args.parent && _.is.node(el)){
				parent = args.parent === true ? _.dom.scrollParent(el) : args.parent;
				parent = _.dom.get(parent);
				parent = parent === $html ? $win : parent;
			}

			var px = 0, py = 0;
			if (parent && parent !== $win){
				args.reflow && _.dom.reflow(parent);
				
				var pb = parent.getBoundingClientRect();
				px = parent.scrollLeft - pb.left;
				py = parent.scrollTop - pb.top;				
			}else if (el !== $win){
				px = ($win.scrollX || $win.pageXOffset || 0);
				py = ($win.scrollY || $win.pageYOffset || 0);
			}
			
			bounds.parent = parent;

			x += px;
			y += py;
		}

		var cbox = _.toBounds([x, y, w, h], {'padding':bounds.padding, 'offsetX':bounds.border[3], 'offsetY':bounds.border[0]});
		var vbox = _.toBounds([bounds.left, bounds.top, bounds.width, bounds.height]);

		bounds.x       = cbox.x;
		bounds.y       = cbox.y;
		bounds.w   	   = cbox.width;
		bounds.h  	   = cbox.height;
		bounds.width   = cbox.width;
		bounds.height  = cbox.height;
		bounds.top     = cbox.top;
		bounds.right   = cbox.right;
		bounds.bottom  = cbox.bottom;
		bounds.left    = cbox.left;
		bounds.center  = cbox.center;
		bounds.pbox    = _.toBounds(cbox, {'margin':bounds.padding});
		bounds.bbox    = _.toBounds(bounds.pbox, {'margin':bounds.border});
		bounds.mbox    = _.toBounds(bounds.bbox, {'margin':bounds.margin});
		bounds.vbox	   = vbox;
		bounds.rbox    = _.toBounds([x, y, vbox.width, vbox.height]);
		bounds.sbox	   = _.toBounds([x, y, sw, sh]);

		// TODO try getting that info for background-image too
		// if it's a media, it could use "object-fit", so we try getting the image position 
		var tag = el && el instanceof HTMLElement && el.tagName.toLowerCase() === 'video';
		if (tag === 'img' || tag === 'video'){
			var isVid = tag === 'video';
			var style = window.getComputedStyle(el);
			var fit   = style.objectFit;
			var pos   = style.objectPosition.split(' ').map(function (v){ return parseFloat(v) / 100; });
			var x 	  = vbox.x;
			var y 	  = vbox.y;
			var w 	  = vbox.width;
			var h 	  = vbox.height;
			var ww    = isVid ? el.videoWidth : el.naturalWidth;
			var hh    = isVid ? el.videoHeight : el.naturalHeight;
			var rw    = w / ww;
			var rh    = h / hh;
			var r     = null;
			var xx    = x;
			var yy    = y;

			if (fit === 'cover'){
				r = Math.max(rw, rh); 
			}else if (fit === 'contain'){
				r = Math.min(rw, rh); 
			}else if (fit == 'fill'){
				ww = w;
				hh = h;
			}else if (fit === 'scale-down' && (ww > w || hh > h)){
				r = Math.max(rw, rh); 
			}

			// get the real size of the image
			if (r !== null){
				ww *= r;
				hh *= r;
				xx = x + ((w - ww) * pos[0]);
				yy = y + ((h - hh) * pos[1]);
			}

			bounds.media = _.math.toBounds([xx, yy, ww, hh]);
			bounds.fit   = fit;
			bounds.fitX  = pos[0];
			bounds.fitY  = pos[1];
		}

		if (el === $win){
			bounds.scale = $win.visualViewport ? visualViewport.scale : $doc.documentElement.clientWidth / $win.innerWidth;
			bounds.scale = bounds.scale <= 1.01 ? 1 : bounds.scale; // @info issue with some iOS where the zoom isn't 1 when at the normal scale
		}else if (el){
			bounds.scale = (Math.round(bounds.vbox.width) / el.offsetWidth) || 1;
		}

		return bounds;
	};

	function _select (node, offset, range){
		if (!range){
			range 		 = new Range();
			offset.index = 0;
		}	
		
		if (node.nodeType === Node.TEXT_NODE){
			var length  = node.textContent.length;
			var index   = offset.index;
			var next    = offset.index + length;
			var isStart = offset.start >= index && offset.start <= next;
			var isEnd 	= offset.end >= index && offset.end <= next;

			// if (isStart || isEnd){
			// 	_js({node, index, next, isStart, isEnd});
			// }

			if (isStart){
				range.setStart(node, offset.start - index);
			}

			if (isEnd){
				range.setEnd(node, offset.end - index);
				next = null;
			}
			
			offset.index = next;
		}else{
			var i, l;
			for (i = 0, l=node.childNodes.length; i<l; i++){
				range = _select(node.childNodes[i], offset, range);

				if (offset.index === null){
					break;
				}
			}
		}

		return range;
	}

	this.selection = function (el, args){
		el = _.dom.get(el || 'body');
		
		if (_.is.nbr(args)){
			args = {'start':args};
		}else if (_.is.arr(args)){
			args = {'start':args[0], 'end':args[1]};
		}

		args        = args || {};
		args.parent = args.parent || '';                    // closest tag
		args.start  = 'start' in args ? args.start : null;  // offset start
		args.end    = 'end' in args ? args.end : null;      // offset end
		
		// find AND select parent tag of current selection
		if (args.parent){
			var selection = $win.getSelection();
			var target 	  = _.dom.closest(selection.anchorNode, args.tag);
			
			if (target){
				var range = new Range();
				selection.removeAllRanges();
				range.selectNode(target);
				selection.addRange(range);
			}
		}

		if ('offset' in args){
			args.start = args.offset;
		}
		if ('length' in args){
			args.end = args.start + args.length;
		}

		var tag     = _.dom.tag(el);
		var isInput = tag === 'input' || tag === 'textarea';
		var start   = 0;
		var end     = 0;
		var text    = null;
		var sel     = null;
		var range   = null;
		var bounds  = null;

		// setting start/end
		if (_.is.nbr(args.start)){
			start = args.start;
			end   = _.is.nbr(args.end) ? args.end : start;

			if (isInput){
				el.selectionStart = start;
				el.selectionEnd   = end;
			}else{
				// @source Set Caret position https://stackoverflow.com/questions/4811822/get-a-ranges-start-and-end-offsets-relative-to-its-parent-container/4812022#4812022
				var selection = $win.getSelection();
				var range     = _select(el, {'start':start, 'end':end});
			
				if (range) {
					(start == end) && range.collapse(false);
					selection.removeAllRanges();
					selection.addRange(range);
				}

				return {
					selection: selection,
					range    : range,
				};
			}

			return;
		}
				
		// get input selection
		if (isInput){
			start = el.selectionStart;
			end   = el.selectionEnd;
			text  = el.value.slice(start, end);
		// get selection in element
		}else{
			sel = $win.getSelection();

			if (sel.rangeCount > 0){
				range = sel.getRangeAt(0);

				var pre = range.cloneRange();

				pre.selectNodeContents(el);
				pre.setEnd(range.endContainer, range.endOffset);

				text   = range.toString();
				end    = pre.toString().length;
				start  = end - text.length;
				bounds = range.getBoundingClientRect();
			}else{
				el = null;
			}
		}

		return {
			'type'     : start === end ? 'caret': 'range',
			'node'     : el,
			'start'    : start,
			'end'      : end,
			'text'     : text,
			'selection': sel,
			'range'    : range,
			'bounds'   : bounds,
		}
	};

	// dom: content ------------------------------------------------------------
	function _nodes (items, args){
		if (!items) return [];

		if (_.is.str(items)){
			items = {'tag':items};
		}
		items = items instanceof Array ? items : [items];

		if (_.is.fn(args) || _.is.arr(args)){
			args = {'callback':args};
		}

		args          = args || {};
		args.element  = args.element || null;
		args.data     = args.data || {};
		args.alias    = args.alias || '';
		args.callback = args.callback || null;  // 
		args.ctx      = args.ctx || null;
		
		var pre  = args.callback;
		var post = null;
		if (_.is.arr(pre)){
			post = pre[1];
			pre  = pre[0];
		}

		function _children (parent, items, node, alias, depth){
			items = _arr(items);
			
			var nodes    = node && node.childNodes ? node.childNodes : [];  // live child nodes
			var siblings = _.toArray(nodes);                      		// cached child nodes
			var index     = 0;
			var children = [];

			// need to validate if it has only 1 child
			if (items.length <= 1){
				parent.hasOnlyChild = true;
			}

			var i, l, n;
			for (i=0,l=items.length;i<l;++i){
				n = _node(
					items[i], 		// item
					nodes[index], 	// node
					parent, 		// parent item
					node, 			// parent node
					siblings, 		// siblings
					index, 			// index
					alias, 			// alias
					depth || 0,		// depth
				);

				if (n !== undefined){
					children.push(n);
					index++;
				}
			}

			return children;
		}
		function _arr (list){
			if (!_.is(list)){
				list = [];
			}else if (!(list instanceof Array)){
				list = [list];
			}

			var arr = [];
			_.each(list, {'trim':false}, function (v){
				if (_.is.fn(v)){
					v = _.apply.ctx(args.ctx, v, [args.alias, args.data]);
				}
				if (v in args.data){
					v = args.data[v];
				}
				if (v instanceof Array){
					arr = arr.concat(v);
				}else if (_.is(v)){
					arr.push(v);
				}
			});

			return arr;
		}
		function _node (item, node, parent, parentNode, siblings, index, alias, depth){
			var a = {
				'item'		: item,
				'node'      : node,
				'parent'    : parent,
				'parentNode': parentNode,
				'siblings'  : siblings,
				'index'     : index,
				'depth'     : depth,
				'alias'     : alias,
			};

			if (!_.is(item)){
				return;
			}else if (_.is.node(item)){
				return _.apply.ctx(args.ctx, pre, [item, node, a]);
			}else if (!_.is.obj(item, true)){
				var value = item.toString();
				value = _.str.replace(value, args.data);

				// remove the "element" attribute since it's going to be inside a 
				if (_.is.el(value)){
					value.removeAttribute('element');
				}

				return _.apply.ctx(args.ctx, pre, [value, node, a]);
			}

			var el = {
				'tag'    		 : item.tag in args.data ? args.data[item.tag] : item.tag || 'div',
				'key'    		 : _.is(item.key) ? item.key : null,
				'node'     		 : node,
				'index'  		 : index,
				'depth'  		 : depth,
				'ctx'			 : item.ctx || null,
				// props
				'props'   		 : item.props || item.prop || {},
				'attrs'   		 : item.attrs || item.attr || {},
				'style'   		 : item.style || {},
				'class'   		 : item.class || item.classnames || item.classname || [],
				'data'    		 : item.data || {}, // might remove the "data"
				'events'  		 : item.events || item.event || {},
				'html'			 : item.html || item.children || [],
				// events
				'onMount'  		 : item.onMount || null,
				'onMounted'		 : item.onMounted || null,
				// meta
				'hasOnlyChild'	 : false,
				'isDebug' 		 : !!item.debug,
			};

			el.html         = _arr(el.html);
			el.hasOnlyChild = el.html.length <= 1;

			if ('alias' in item){
				alias = a.alias = item.alias.toString();
			}
			if (_.is.str(el.class)){
				el.class = el.class.split(' ');
			}

			// decode the tag (with css, attrs, style, html)
			//eg.: div#id.classname.classname2[alt=image,title=title]{border:1px solid black}=the content
			if (_.is.str(el.tag) && !el.tag.match(/^[a-z][a-z0-9_-]+$/)){
				_.str.parse(el.tag, 'selector', el);
			}

			// the callback might create the element (if it wasn't created before)
			var response = _.apply.ctx(args.ctx, pre, [el, node, a], {'fallback':null});
			if (response !== null){
				el.node = node = response;
			}

			el.html = _children(el, el.html, node, alias, depth+1);

			_.apply.ctx(args.ctx, post, [el, node, a]);

			return el;
		}

		items = _children({}, items, args.element, args.alias);

		return items;
	};
	
	/**
	 * Either return the innerHtml/outerHTML of the element OR set it's HTML.
	 * 
	 * @example
	 * // TODO
	 * 
	 * @param {HTMLElement[]} 		els 			one or many HTMLElements
	 * @param {string|object|true} 	html 			[true = return outerHTML] for getting. Or string/object to set the innerHTML
	 * @param {object} 				[args] 			
	 * @param {*}					args.ctx		Context used for the {@link _.dom.update} function when updating the node
	 * @param {string}				args.alias		Alias used for {@link _.dom.update} function when updating the node
	 * @param {object}				args.data		Data used for replacing variables found in the object html
	 * @param {boolean}				args.cache		Cache the HTML value, so we don't re-set it if nothing has changed
	 * @param {boolean}				args.preload	Preload the images before setting the HTML
	 * @returns {string}
	 */
	this.html = function (els, html, args){
		els = _.dom.get(els, true);
		if (!els.length) return '';
		
		if (html === true){
			return els[0].outerHTML;
		}else if (html !== '' && !_.is(html)){
			return els[0].innerHTML;
		}
		
		args         = args || {};
		args.ctx     = args.ctx || null;
		args.alias   = args.alias || '';
		args.data    = args.data || {};                       // used to "replace" or function
		args.cache   = 'cache' in args ? args.cache : false;
		args.preload = args.preload || false;

		if (html in args.data){
			html = args.data[html];
			html = _.is.str(html) ? html : [html];
		}

		if (args.preload){
			// TODO
			// var frag = $doc.createElement('div');
			// _update(frag, html);

			// _.els.onMediaLoad(frag, function (medium){
			// 	_.dom.add(frag.childNodes, 'html', el);
			// 	_.apply(args.preload, [medium], args.context);
			// });

			// return;
		}

		function _html (el, html, a){
			if (a === true){
				a = {'text':true};
			}

			a         = a || {};
			a.alias   = a.alias || args.alias || '';
			a.text    = a.text || false;
			a.refresh = a.refresh || false;
	
			var old = args.cache ? _.cache(el, DOM.CACHE.HTML) : null;
			
			// normal node / els
			if (_.is.node(html, true)){
				el.innerHTML = '';
				_.dom.add(html, el);
			}else{
				html = _.is(html) ? html.toString() : '';
	
				if (old !== html || a.refresh){	
					// el[a.text?'textContent':'innerHTML'] = _.toAlias(html, a.alias);
					el[a.text?'textContent':'innerHTML'] = html;
				}
			}
	
			args.cache && _.cache(el, DOM.CACHE.HTML, html);
		};
		function _find (key, nodes){
			if (!key) return;
	
			var i, l, node;
			for (i=0,l=nodes.length;i<l;++i){
				if (nodes[i].$key == key){
					node = nodes[i];
					break;
				}
			}
	
			return node || null;
		};
		function _clean (el, count){
			var oc = el.childNodes.length;
			if (oc > count){
				var c;
				while ((c = el.childNodes[count])){
					// add to removed
					c.parentNode.removeChild(c);
				}
			}
		};
		function _before (item, node, data){
			var $node = _find(item.key, data.siblings);
			var action= null;
			
			if ($node && $node !== node){
				if (node && node.parentNode){
					var parent = node.parentNode;
					parent.insertBefore($node, parent.childNodes[item.index]);
				}
				node = $node;
			}else if (node && node.$key && node.$key !== item.key){
				node.parentNode.removeChild(node);
				node = null;
			}else if (!_.is(item.key)){
				$node = node;
			}
			
			// if (node && node.$index && data.index !== node.$index){
			// 	action = 'move';
			// }

			var type  = _.is.node(item) ? ':node' : (_.is.str(item) ? ':text' : item.tag);
			var $type = $node && $node.nodeType ? ($node.nodeType === 1 ? $node.tagName.toLowerCase() : ':text') : null;
			var wrap  = false;

			// @fix if there's only 1 child for this parent, and the item is a string, se it as HTML
			if (type === ':text' && data.parent.hasOnlyChild){
				data.parent.clean = false;
				_html(data.parentNode, item, {'refresh':true});
				return false;
			}
	
			// if it's HTML or has en encoded character
			if (type === ':text' && item.trim().match(/(\<[a-z]+)|(\&[a-z]+\;)/i)){
				type = 'span';
				wrap = true;
			}

			// create node -----------------------------------------------------
			if (!$type || ($type && $type !== type)){
				if (type === ':node'){
					node = item;
				}else if (type === ':text'){	
					node = $doc.createTextNode('');
				}else if (_.is.el(type)){
					node = type;
					type = ':node';
				}else{
					// TODO deal with SVG elements
					node = $doc.createElement(type);
				}
			}
			// update node -----------------------------------------------------
			if (type === ':text'){
				_html(node, item, true);
			}else if (type !== ':node'){
				var a = _.is.obj(item) ? item : {};
				a.ctx = a.ctx || args.ctx;
				_.dom.update(node, a, args.alias);
				
				// console.log('->', {node, item});

				// the content has raw HTML, wrap it in an <span>
				if (wrap){
					node.setAttribute('html', 'raw');
					_html(node, item, {'alias':item.alias});
				}
			}

			// insert/move node ------------------------------------------------
			if (data.parentNode && ($node !== node || !node.parentNode)){
				// replace
				if ($node && $node.parentNode){
					$node.parentNode.insertBefore(node, $node.nextSibling);
					$node.parentNode.removeChild($node);
				// append
				}else{
					try{
						var parent = data.parentNode;
						if (parent.childNodes[data.index]){
							parent.insertBefore(node, parent.childNodes[data.index]);
						}else{
							parent.appendChild(node);
						}
					}catch (e){
						// @info seems like IE11 doens't like to append EmptyTextNode
						console.log('[NodeAppend Error]', e); 
					}
				}
			}

			// caching of the key
			node.$key   = item.key;
			node.$index = item.index;
			if (node.setAttribute && _.is(item.key)){
				node.setAttribute('key', item.key);
			}

			return node;
		};
		function _after (item, node, data){
			// the children was set with innerHTML
			if (item.clean === false || _.is.el(node.tag) || item.html.length >= node.childNodes.length) return;
			_clean(node, item.html.length);

			// TODO _.apply(node.onMounted, [el, node], node.context);
		};
		function _set (el){
			if (_.is.obj(html, true) || html instanceof Array){
				var frag   = el.childNodes.length === 0;
				var parent = frag ? $doc.createDocumentFragment() : el;
				var nodes  = _nodes(html, {
					'alias'   : args.alias,
					'data'    : args.data,
					'element' : parent,
					'callback': [_before, _after],
				});

				// only 1 item, that is set by innerHTML
				if (nodes.length === 1 && nodes[0] === false){
					nodes = false;
				}

				frag && el.appendChild(parent);
				nodes && _clean(el, nodes.length);
			}else{
				_html(el, html);
			}
			
			_.cache(el, DOM.CACHE.HTML, html);

			_.dom.trigger(el, 'change-html', {
				'html' : html,
			});
		}

		_.dom.els(els, _set)

		return true;
	};

	// dom: style --------------------------------------------------------------
	this.style = function (els, key, value){
		var set = _.toSet(key, value);
		els = _.dom.get(els, true);

		if (set){
			var hasChanged = false;

			_.dom.els(els, function (el){ 
				var cache 	  = value === true ? {} : _.cache(el, DOM.CACHE.STYLE) || {};
				var transform = null;
				var i, v;
				for (i in set){
					v = set[i];
					if (cache[i] === v) continue;
					
					// deal with transform
					if (i === 'transform'){
						_.cache(el, DOM.CACHE.TRANSFORM, null);
					}else if (~DOM.CACHE.STYLE.TRANSFORM_VALUES.indexOf(i)){
						transform    = transform || _.cache(el, DOM.CACHE.TRANSFORM) || {};
						transform[i] = v;
						delete(cache.transform);
						continue;
					}

					cache[i] 	= v;
					hasChanged 	= true;
					
					var s = _.toStyle(i, v, true);

					if (s.var){
						el.style.setProperty(s.var, s.value);
					}else{
						el.style[s.key] = s.value;
					} 
				}

				if (transform && !('transform' in set)){
					_.dom.transform(el, transform);
				}

				// remove the attribute, keep things clean
				!el.getAttribute('style') && el.removeAttribute('style');

				_.cache(el, DOM.CACHE.STYLE, cache);
			}, false);

			return hasChanged;
		}else if (els[0]){
			var style     = els[0].style ? $win.getComputedStyle(els[0]) : {};
			var transform = _.cache(els, DOM.CACHE.TRANSFORM) || {};
			var isVar 	  = _.is.fn(style.getPropertyValue) && _.is.str(key) && key.indexOf('--') === 0;
			
			if (isVar){
				return style.getPropertyValue(key).trim();
			}else if (key in transform){
				return transform[key];
			}else if (key in style){
				return style[key];
			}else if (_.is.def(key)){
				return null;
			}else{
				var values = {};
				for (var i in style){
					if (!isNaN(i)) continue;
					values[i] = style[i];
				}
				for (i in transform){
					values[i] = transform[i];
				}
				return values;
			}
		}
		
		return null;
	};

	this.transform = function (els, key, value){
		var set = _.toSet(key, value);
		els = _.dom.get(els, true);

		var values = {
			'translateX': 0,
			'translateY': 0,
			'translateZ': 0,
			'scaleX'    : 1,
			'scaleY'    : 1,
			'scaleZ'    : 1,
			'rotate'	: 0,
			'rotateX'   : 0,
			'rotateY'   : 0,
			'rotateZ'   : 0,
			'skewX'     : 0,
			'skewY'     : 0
		};

		function _nbr (nbr, unit){
			unit = unit || 'px';
			nbr  = nbr || 0;
			nbr  = typeof nbr === 'number' && nbr ? nbr + unit : nbr;
			return nbr;
		}

		function _transform (el, t){
			var s = [];

			if (t.centerX !== undefined || t.centerY !== undefined){
				var x = _nbr(t.centerX);
				var y = _nbr(t.centerY);
				el.style.transformOrigin = x + ' ' + y;
			}
			if (t.perspectiveX !== undefined){
				var x = _nbr(t.perspectiveX);
				var y = _nbr(t.perspectiveY);
				el.style.perspectiveOrigin = x + ' ' + y;
			}

			// style
			if (t.perspective !== undefined){
				var p = _nbr(t.perspective);
				s.push('perspective('+p+')');
			}
			if (t.translateX || t.translateY || t.translateZ){
				var x = _nbr(t.translateX);
				var y = _nbr(t.translateY);
				var z = _nbr(t.translateZ);
				if (z) 	s.push('translate3d('+x+','+y+','+z+')');
				else	s.push('translate('+x+','+y+')');
			}
			if (t.scaleX !== 1 || t.scaleY !== 1 || t.scaleZ !== 1){
				var x = t.scaleX !== 1 ? t.scaleX : 1;
				var y = t.scaleY !== 1 ? t.scaleY : 1;
				var z = t.scaleZ !== 1 ? t.scaleZ : 1;
				s.push('scale3d('+x+','+y+','+z+')');
			}
			if (t.rotateX){
				var r = _nbr(t.rotateX, 'deg');
				s.push('rotateX('+r+')');
			}
			if (t.rotateY){
				var r = _nbr(t.rotateY, 'deg');
				s.push('rotateY('+r+')');
			}
			if (t.rotateZ){
				var r = _nbr(t.rotateZ, 'deg');
				s.push('rotateZ('+r+')');
			}
			if (t.skewX || t.skewY){
				var x = _nbr(t.skewX, 'deg');
				var y = _nbr(t.skewY, 'deg');
				s.push('skew('+x+','+y+')');
			}

			el.style.transform = s.join(' ');
		};

		if (set){
			if (set.translate === ''){
				set.translateX = 0;
				set.translateY = 0;
			}else if (set.translate){
				set.translateX = set.translate;
				set.translateY = 0;
			}
	
			if (set.scale === ''){
				set.scaleX = 1;
				set.scaleY = 1;
			}else if (set.scale){
				set.scaleX = set.scale;
				set.scaleY = set.scale;
			}
	
			if (set.rotate !== undefined){
				set.rotateZ = set.rotate;
			}
			
			delete(set.translate);
			delete(set.scale);
			delete(set.rotate);

			_.dom.els(els, function (el){
				var cache = _.cache(els[0], DOM.CACHE.TRANSFORM) || _.copy(values);
				cache = _.extend(cache, set);
				_transform(el, cache);
				_.cache(els[0], DOM.CACHE.TRANSFORM, cache);
			}, false);
		}else if (els[0]){
			var cache = _.cache(els[0], DOM.CACHE.TRANSFORM) || {};
			return _.extend(values, cache);
		}else{
			return values;
		}
	};

	this.visible = function (el){
		if (_.is.el(el, ':root')){
			return true;
		}
		
		el = _.dom.get(el);
		if (!el) return false;

		// svg element is checked differently
		if (_.is.node(el, 'svg')){
			var b = el.getBBox();
			return b.width > 0 || b.height > 0;
		}

		// if a text node, move to the parent
		el = el.nodeType === 3 ? el.parentElement : el;
			
		return !!(el.offsetWidth || el.offsetHeight || (el.getClientRects && el.getClientRects().length));
	};

	/**
	 * Set/get the HTMLELement classnames. If the classnames is a string or array, it will replace all with this new value.
	 * If classnames is an object, you can pick which classname to add and remove.
	 * @alias utils.dom.classnames 
	 * 
	 * @example
	 * 
	 * // set classnames
	 * utils.dom.classnames(el, 'new-class');
	 * utils.dom.classnames(el, ['new-class-1', 'new-class-2']);
	 * utils.dom.classnames(el, {'new-class-1':true, 'new-class-2':false});
	 * 
	 * // get classnames
	 * utils.dom.classnames(el);
	 * 
	 * @param {HTMLELement[]} 		els 
	 * @param {string|array|object} classnames 
	 * @param {object} 				[args] 
	 * @param {string}				args.alias
	 * @param {string|number}		args.duration
	 * 
	 * @returns {array}
	 */
	this.classnames = function (els, classnames, args){
		if (_.is.str(args)){
			args = {'alias':args};
		}

		args          = args || {};
		args.alias    = args.alias || false;
		args.duration = _.toDuration(args.duration);	// maybe, be able to cancel other duration maybe?

		if (_.is.def(classnames)){
			classnames = _.is.obj(classnames, true) ? classnames : _.toArray(classnames, {'unique':true}).join(' ');
			classnames = _.toAlias(classnames, args.alias);

			_.dom.els(els, function (el){
				var old = el.className;
				var cls = classnames;

				// object classnames 
				if (_.is.obj(cls)){
					cls = (el.getAttribute('class') || '').split(' ');
					for (var i in classnames){
						var v = classnames[i];
						var ii= cls.indexOf(i);

						if (v && !~ii){
							cls.push(i);
						}else if (!v && !!~ii){
							cls.splice(ii, 1);
						}
					}
					cls = cls.join(' ');
				}
				
				if (cls) el.setAttribute('class', cls);
				else	 el.removeAttribute('class');

				if (args.duration) _.fn.wait(args.duration, function (){
				 	el.className = old;
				});
			});


		}else{
			var classnames = [];
			_.dom.els(els, function (el){
				var cls = _.toArray(el.getAttribute('class'), ' ');
				classnames = classnames.concat(cls);
			});
			return _.toArray(classnames, {'unique':true});
		}
	};

	this.hasClass = function (els, classname, args){	
		if (_.is.str(args)){
			args = {'alias':args};
		}

		args       = args || {};
		args.all   = args.all || false;
		args.alias = args.alias || null;

		classname = _.toAlias(classname, args.alias);
		
		var found = null;
		_.dom.els(els, function (el){
			var classnames = _.dom.classnames(el);
			var is 		   = ~classnames.indexOf(classname);

			if (!is && args.all){
				found = false;
				return FFTO.BREAK;
			}else if (is){
				found = true;
				return FFTO.BREAK;
			}
		});

		return !!found;
	};

	this.addClass = function (els, add, args){
		if (_.is.nbr(args)){
			args = {'duration':args};
		}else if (_.is.str(args)){
			args = {'alias':args};
		}

		args          = args || {};
		args.alias    = args.alias || false;
		args.duration = _.toDuration(args.duration);

		add = _.toArray(add, ' ');
		add = _.toAlias(add, args.alias);

		_.dom.els(els, function (el){
			var old        = el.getAttribute('class') || '';
			var classnames = _.dom.classnames(el).concat(add);
			_.dom.classnames(el, classnames);

			// TODO change this, intead of using "old", we need to remove the added classname, since in the meantime, other classnames can be added/removed, and the "old" variable isn't considering that

			if (args.duration){
				_.fn.wait(args.duration, function (){
					_.dom.classnames(el, old);
				});
			}
		});
	};

	this.removeClass = function (els, remove, args){
		if (_.is.nbr(args)){
			args = {'duration':args};
		}else if (_.is.str(args)){
			args = {'alias':args};
		}

		args          = args || {};
		args.alias    = args.alias || false;
		args.duration = _.toDuration(args.duration);

		var isRegExp = false;
		if (_.is.class(remove, RegExp)){
			isRegExp = true;
		}else{
			remove = _.toArray(remove, ' ');
			remove = _.toAlias(remove, args.alias);
		}

		_.dom.els(els, function (el){
			var all        = _.dom.classnames(el);
			var old 	   = all.join(' ');
			var classnames = [], c, i, l;
			for (i=0, l=all.length; i<l; ++i){
				c = all[i];

				if (isRegExp){
					(!c.match(remove)) && classnames.push(c);
				}else{
					(!~remove.indexOf(c)) && classnames.push(c);
				}
			}
			_.dom.classnames(el, classnames);

			if (args.duration){
				_.fn.wait(args.duration, function (){
					_.dom.classnames(el, old);
				});
			}
		});
	};

	this.toggleClass = function (els, toggle, args){
		if (_.is.nbr(args)){
			args = {'duration':args};
		}else if (_.is.str(args)){
			args = {'alias':args};
		}

		args          = args || {};
		args.alias    = args.alias || false;
		args.duration = _.toDuration(args.duration);

		toggle = _.toArray(toggle, ' ');
		toggle = _.toAlias(toggle, args.alias);

		_.dom.els(els, function (el){
			var old        = el.getAttribute('class') || '';
			var classnames = old.split(' ');

			for (var i in toggle){
				var cls = toggle[i];
				var idx = classnames.indexOf(cls);
				
				if (!~idx){
					classnames.push(cls);
				}else{
					classnames.splice(idx, 1);
				}
			}
			
			_.dom.classnames(el, classnames);

			if (args.duration){
				_.fn.wait(args.duration, function (){
					_.dom.classnames(el, old);
				});
			}
		});
	};

	function _vars (el, refresh){
		var keys = DOM.VARS.KEYS;

		function _add (style){
			if (!style) return;

			for (var i=0,l=style.length; i<l; ++i){
				var s = style[i];
				if (s.indexOf('--') === 0){
					keys 	= keys || {};
					keys[s] = true;
				}
			}
		}

		if (keys === null || refresh){
			for (var i=0,l=document.styleSheets.length; i<l; ++i){
				var sheet = document.styleSheets[i];

				// make sure to NOT parse the same sheet again
				if (~DOM.VARS.SHEETS.indexOf(sheet)) continue;
				DOM.VARS.SHEETS.push(sheet);

				for (var ii=0,ll=sheet.cssRules.length; ii<ll; ++ii){
					var rule = sheet.cssRules[ii];
					if (!rule || !rule.style) continue;
					_add(rule.style);
				}
			}
		}
		
		// check the elements in the page 			
		if (el){
			while (el){
				_add(el.style);
				el = el.parentNode;
			}
		}

		DOM.VARS.KEYS = keys;

		return keys;		
	}

	this.vars = this.var = function (els, key, value, args){
		if (_.is.obj(value)){
			args  = value;
			value = undefined;
		}

		var set = _.toSet(key, value);
		els = _.dom.get.all(els || document.body);
		
		if (set){
			var style = {};
			for (var i in set){
				var key = '--' + _.toSlug(i);
				style[key] = set[i];
			}
			_.dom.style(els, style);
		}else if (els[0]){
			args          = args || {};
			args.style	  = args.style || false;
			args.parse    = args.parse || false;
			args.single   = 'single' in args ? args.single : null;
			args.fallback = 'fallback' in args ? args.fallback : '';

			var el       = els[0];
			var style    = args.style ? args.style : (window.getComputedStyle ? (el.isConnected ? window.getComputedStyle(el) : el.style) : {});
			var vars     = {};
			var keys     = key ? _.toArray(key, {'return':'obj/key'}) : _vars(el);
			var isSingle = _.is.bool(args.single) ? args.single : _.is.str(key) && _.count(keys) === 1;
						
			var i, v = args.fallback;
			for (var key in keys){
				if (~key.indexOf('var(')){
					key = key.replace(/var\((.+)\)/, '$1');
				}
				if (!~key.indexOf('--')){
					key = '--'+_.toSlug(key);
				}

				var pair     = key.split(',');
				var fallback = (pair[1] || args.fallback);
				
				// option to have a fallback like "var(--value, 1em)"
				if (typeof fallback === 'string'){
					fallback = fallback.trim();
				}
								
				i = pair[0].trim();
				v = style.getPropertyValue(i).trim();
				v = v === '' && fallback ? fallback : v;
				
				if (v === '') continue;
				v = args.parse ? _.toValue(v) : v;
				i = _.toSlug(i, 'camel');
				
				vars[i] = v;			
			}

			return isSingle ? v : vars;
		}
	};

	this.toPx = function (nbr, args, el){
		if (!nbr){
			return 0;
		}else if (typeof nbr === 'number'){
			return nbr;
		}

		if (_.is.nbr(args, true)){
			args = {'size':parseFloat(args)};
		}else if (_.is.either(args, 'str,el')){
			args = {'element':args};
		}

		args         = args || {};
		args.size    = 'size' in args ? args.size : null;
		args.element = 'element' in args ? args.element : el;
		args.fallback= 'fallback' in args ? args.fallback : 0;

		//  Have multiple options to find the value (if nbr is an array)
		if (_.is.arr(nbr)){
			var fallback = args.fallback;
			args.fallback = null;

			for (var i=0, l=nbr.length; i<l; ++i){
				var v = $.toPx(nbr[i], args);
				if (v !== null) return v;
			}

			return fallback;
		}

		var el     = args.element ? _.dom.get(args.element) : null;
		var screen = _.dom.screen();
		var w 	   = el ? el.clientWidth : screen.width;
		var h 	   = el ? el.clientHeight : screen.height;
		var em 	   = el ? parseInt(window.getComputedStyle(el).fontSize, 10) : screen.rem;
		
		// default size for % calculation
		if (args.size === null){
			args.size = w;
		}

		// if the nbr is a CSS variable (eg.: --number);
		if (_.is.str(nbr)){
			var value = nbr; 

			el = el || document.documentElement;

			// the nbr has a CSS selector before the var
			if (~nbr.indexOf(':')){
				var pair = nbr.split(':');
				el  = _.dom.get(pair[0]) || el; 
				nbr = pair[1];
			}
			
			nbr = _.dom.var(el, nbr, {'fallback':value});
		}
		
		// decode the values with units
		nbr = nbr.toString().replace(RE.NUMBER_UNITS, function (m, n){
			var u = n.replace(/[0-9\.\-]/g, '').toLowerCase();
			var n = parseFloat(n);
    
			if(u === 'vh')			n = n/100 * screen.viewport.height;
			else if (u === 'vw')	n = n/100 * screen.viewport.width;
			else if (u === 'sh')	n = n/100 * screen.content.height;
			else if (u === 'sw')	n = n/100 * screen.content.width;
			else if (u === 'ch')	n = n/100 * screen.height;           // TODO not sure if still needed ??
			else if (u === 'cw')	n = n/100 * screen.width;            // TODO not sure if still needed ??
			else if (u === 'h')		n = n/100 * h;
			else if (u === 'w')		n = n/100 * w;
			else if (u === '%')		n = n/100 * args.size;
			else if (u === 'rem')	n = n * screen.rem;
			else if (u === 'em')	n = n * em;
			
			return n;
		});

		nbr = _.calculate(nbr);
        return _.is.nbr(nbr) ? nbr : args.fallback;
	};
	
	// dom: event --------------------------------------------------------------
	/**
	 * Add event listers to the elements. Return a function to remove all the events.
	 * Custom events created with {@link _.dom.event․custom} will be considered. Event delegation is supported.
	 * 
	 * @memberof utils.dom
	 * @function event
	 * 
	 * @example 
	 * utils.dom.event(document, 'click', function (){ console.log('click'); };
	 * 
	 * utils.dom.event(document, 'click', {'prevent':true, 'delegate':'blockquote'}, function (){ console.log('click'); };
	 * 
	 * utils.dom.event(document, {
     *     'mouseenter' : function (){ console.log('enter'); },
     *     'mouseleave' : function (){ console.log('leave'); },
     * }, 'blockquote');
	 * 
	 * @param {node[]}			els
	 * @param {string[]}		names
	 * @param {object}			[args] 			Object or Function for callback, or String for delegate
	 * @param {object}			args.ctx		Context to use when calling the callback
	 * @param {string}			args.alias		Alias string to update the delegate selectors
	 * @param {string}			args.delegate	String selector to find the delegated target
	 * @param {string}			args.namespace	Add a namespace to the event names (not sure it's needed)
	 * @param {boolean}			args.prevent	Will call preventDefault() when calling the callback
	 * @param {boolean}			args.stop		Will call stopPropagation() when calling the callback
	 * @param {boolean}			args.capture	The event should use capture phase (instead of bubble)
	 * @param {boolean}			args.passive	This is a passive event
	 * @param {number}			args.debounce	Debounce the event callback
	 * @param {number}			args.throttle	Throttle the event callback
	 * @param {object|function}	args.callback	Callback to call when the event is triggered. If object of functions, find the nearest delegate
	 * @param {function}		callback		TODO add description
	 * @param {object}			args2			TODO add description
	 * 
	 * @returns {function} Function to remove all those events
	 */
	this.on = this.event = function (els, names, args, callback, args2){
		if (_.is.fn(args2)){
			args2 = {'callback':args2};
		}

		args2          = args2 || {};
		args2.ctx      = args2.ctx || null;
		args2.alias    = args2.alias || '';
		args2.callback = args2.callback || null;

		if (_.is.empty(names)) return;

		if (_.is.fn(args)){
			callback = args;
			args     = {};
		}else if(_.is.str(args)){
			args = {'delegate':args};
		}

		args           = args || {};
		args.ctx       = args.ctx || args2.ctx;
		args.alias     = args.alias || args2.alias;
		args.delegate  = args.delegate || null;
		args.parent    = args.parent || null;                        // limit the actions where the "el" is not in a sub-children with the same "parent" selector
		args.namespace = args.namespace || '';                       // might not use this....
		args.prevent   = args.prevent || false;
		args.stop      = args.stop || false;
		args.once      = 'once' in args ? args.once : false;
		args.capture   = 'capture' in args ? args.capture : false;
		args.passive   = 'passive' in args ? args.passive : null;
		args.debounce  = 'debounce' in args ? args.debounce : null;
		args.throttle  = 'throttle' in args ? args.throttle : null;
		args.callback  = callback || args.callback || null;          // can be a function or an array of functions, will be called by the custom events

		// make sure it's elements
		els = _.is.str(els) ? _.dom.get.all(els) : els;
		
		// gotta wrap the callback for "once" to work properly
				
		var $callback = args2.callback || args.callback;
		var remove    = [];
		var called 	  = false;	// if "once" is true, used if the callback is added to many events 
		_.each(names, ' ', function (name, i, a){
			var namespace = args.namespace;
			var callback  = $callback;
			var delegate  = args.delegate;
			var bind      = null;

			if (a.type === 'object'){
				callback = name;
				name     = i;
			}

			// TODO not sure namespace is that necessary
			if (~name.indexOf('.')){
				var pair = name.split('.');
				namespace = pair[0];
				name      = pair[1];
			}

			if (!_.is.fn(callback)){
				return;
			}

			name     = name.toLowerCase();
			delegate = args.delegate = _.toAlias(delegate, args.alias);

			// custom event
			if (name in DOM.EVENT.CUSTOM){
				var custom       = DOM.EVENT.CUSTOM[name];
				var removeCustom = null;

				bind     = function (){};
				bind.on  = function (el){ 
					removeCustom = custom.on(el, args, function (params){
						if (args.once && called) return;
						params = params instanceof Array ? params : [params];
						_.apply.ctx(args.ctx, args.callback, params);
						called = true;
					}); // save the "remove()" function
				};
				bind.off = function (el){ 
					_.apply(removeCustom);
					_.apply(custom.off, [args]);
				};
			}else{
				var key = [name, namespace, delegate, args.ctx, callback, args.capture, args.passive, args.once];
				bind = _.cache(DOM.EVENT.BINDS, key);
			}

			if (!bind){
				var alt = DOM.EVENT.ALT_DELEGATE[name];
						
				bind = function (evt){
					// the event have been triggered already
					if (args.once && called){
						return;
					}

					var target   = delegate ? _.dom.closest(evt.target, delegate) : this; 	
					var related  = evt.relatedTarget;

					if (alt){
						// _js({name, target, related});
					}

					// skip the event target if it's in the same node
					if (alt && (
						related === target 
						|| (target === $win && related !== $win) 
						// || (target === $doc && related !== $doc)
						|| (target && target.contains && target.contains(related)) 
						|| (target && related && !related.parentElement) 
					)){
						target = null;
					}

					if (!target) return;
					if (args.prevent) 	evt.preventDefault();
					if (args.stop)		evt.stopPropagation();
		
					var p = evt.touches && evt.touches[0] ? evt.touches[0] : evt;
					var x = p.clientX;
					var y = p.clientY;
					var w = 0;
					var h = 0;
					var s = 1; // scale

					// if (e.type.match(/^touch/) && e.touches && e.touches[0]){
					// 	var x = e.touches[0].clientX;
					// 	var y = e.touches[0].clientY;
					// }else{
					// 	var x = e.clientX;
					// 	var y = e.clientY;
					// }

					if (target && target.getBoundingClientRect){
						var b = target.getBoundingClientRect();

						w = b.width;
						h = b.height;
						s = w / target.offsetWidth;
						x = p.pageX - b.left;
						y = p.pageY - b.top;

						if (x < 0) 		x = 0;
						else if (x > w) x = w;

						if (y < 0) 		y = 0;
						else if (y > h) y = h;
					}

					// TODO add some code for "startX", when using specific event like mousemove, pointermove, ...

					// getting the files from 
					var files = null;
					var paste = null;
					if (target.type === 'file'){
						files = evt.target.files;
					}else if (evt.dataTransfer){
						files = evt.dataTransfer.files;
					}else if (evt.type === 'paste'){
						var clipboard = evt.clipboardData;
						var items 	  = clipboard.items || [];
						files 		  = [];
						
						for (var i = 0; i < items.length; i++){
							files.push(items[i].getAsFile());
						}

						paste = clipboard.getData('text/html') || clipboard.getData('text') || '';
					}

					var e = {
						'type'     : name,
						'isCustom' : evt.isCustom,
						'original' : evt,
						'timestamp': new Date(),
						'target'   : target,
						'trigger'  : this,
						'ctx'	   : args.ctx || target,
						'data'	   : _.dom.data(target),
						'details'  : evt.details || {},
						'touches'  : evt.touches || null,
						'button'   : DOM.MOUSE_BUTTONS[evt.buttons] || null,
						// files
						'files'    : files ? _.arr(files) : null,
						'paste'	   : paste,
						// TODO these are for pointer events, not all types of events. gottat change that
						'point'    : {'x':x, 'y':y, 'scaleX':x/s, 'scaleY':y/s, 'ratioX':x/w, 'ratioY':y/h},
						'size'	   : {'width':w, 'height':h, 'scale':s},
						'page'	   : {'x':p.pageX, 'y':p.pageY},		// point in screen, with the scroll
						'client'   : {'x':p.clientX, 'y':p.clientY},	// point in screen, without the scroll
						'offset'   : {'x':p.offsetX, 'y':p.offsetY},
						// keyboard stuff
						'key'	   : {
							'value' : evt.key === undefined ? null : evt.key,
							'code'  : evt.keyCode === undefined ? null : evt.keyCode,
							'alt'	: evt.altKey,
							'ctrl'	: evt.ctrlKey,
							'shift'	: evt.shiftKey,
						},
						'cancel' : function (){
							evt.preventDefault(); 
							evt.stopPropagation();
							evt.stopImmediatePropagation();
						},
						'prevent' : function (){ 
							evt.preventDefault(); 
						},
						'stop' : function (immediate){ 
							evt.stopPropagation(); 
							immediate && evt.stopImmediatePropagation();
						},
					};

					// nearset delegate
					if (_.is.obj(callback)){
						// TODO
					}

					var response = _.apply.ctx(args.ctx || target, callback, [e]);
					if (response !== false){
						called = true;
					}
				};

				if (args.debounce){
					bind = _.fn.debounce(null, args.debounce, bind);
				}else if (args.throttle){
					bind = _.fn.throttle(null, args.throttle, bind);
				}

				bind.on = function (el){
					// TODO make sure the event isn't re-added if already there
					el.addEventListener(alt || name, bind, {
						'capture' : args.capture,
						'passive' : args.passive,
						'once'    : args.once,
					});
				};
				bind.off = function (el){
					el.removeEventListener(alt || name, bind, {
						'capture' : args.capture,
						'passive' : args.passive,
						'once'    : args.once,
					});
				};

				_.cache(DOM.EVENT.BINDS, key, bind);
			}
			
			_.$arr(els, function (el){
				if (!el || !el.addEventListener) return;
				bind.on(el);
				remove.push(function (){ bind.off(el); });
			});
		});

		function _remove (){
			for (var i in remove){ remove[i](); }
			remove = [];
		}

		_remove.items = remove;

		return _remove;
	};

	this.off = this.event.remove = function (els, names, args, callback){
		if (_.is.fn(args)){
			callback = args;
			args     = {};
		}else if(_.is.str(args)){
			args = {'delegate':args};
		}

		_.warn('Events remove isn\'t coded yet');

		_.each(names, ' ', function (name, i, a){
			// TODO
		});
	};

	this.event.decode = function (els, args, callbacks){
		if (callbacks === undefined){
			callbacks = args;
			args      = {};
		}

		args          = args || {};
		args.ctx      = args.ctx || null;
		args.alt      = args.alt || '';          // alternate name attribute (eg.: "name" and "x-name")
		args.prefix   = args.prefix || '';       // for delegates
		args.defaults = args.defaults || false;	 // add default events managements for "on-click, ..." events
		args.prop 	  = args.prop || null;		 // limit the events to a specific parent, so it's not in a sub-parent // TODO
		
		// decode the events
		var events = [], i, v, m;
		var prefix = args.prefix ? args.prefix + ' ' : '';
		var alt    = args.alt;

		function _delegate (txt, d){
			var d1 = d;
			var d2 = _.toSlug(d);
			var a  = txt.replace(/\$prefix/g, prefix).replace(/\$delegate/g, d1);
			var b  = txt.replace(/\$prefix/g, prefix).replace(/\$delegate/g, d2);
			if (a != b) return a + ',' + b;
			else		return a;
		}

		// decode all the callbacks
		for (i in callbacks){
			v = callbacks[i];
            if (!(m = i.match(RE.EVENT_NAME))) continue;

			var el       = null;
			var attr     = null;
			var delegate = null;
			var name     = null;

			if (m[0] === 'onResize'){
				el     = window;
				name   = 'resize';
            }else if (m[0] === 'onScroll'){
				el   = window;
				name = 'scroll';
			}else if (m[0] === 'onReady'){
				name = null;
				utils.dom.ready(args.ctx, v);
            }else if (m[0] === 'onLoad'){
				name = null;
				utils.dom.load(args.ctx, v);
				// TODO how should this work, is it necessary?
				// TODO should there be a "onReady" and "onNow" event
				// _.dom.load(item, v);
            }else{
				attr     = _.toSlug(m[1] || '');
				delegate = m[2] || ''; //_.toSlug(m[2] || '');
				name     = _.toSlug(m[3]);
				
				if (delegate === 'win' || delegate === 'window'){
					el       = window;
					delegate = null;
				}else if (delegate === 'doc' || delegate === 'document'){
					el       = document;
					delegate = null;
				}else if (delegate === 'body'){
					el       = document.body;
					delegate = null;
				}else if (delegate){
					var d = '';

					if (attr === 'tag')			d = '$prefix$delegate';
                    else if (attr === 'class')	d = '$prefix.$delegate';
                    else if (attr === 'name')	d = '$prefix[name="$delegate"]';
                    else if (attr === 'id')		d = '$prefix#$delegate';
					else if (attr === 'attr')	d = '$prefix[$delegate]';
                    else if (attr)				d = '$prefix['+attr+'="$delegate"]';
                    else						d = '$prefix[name="$delegate"]'+(alt?',$prefix['+alt+'="$delegate"]':'');

					delegate = _delegate(d, delegate);
				}
            }
			
			var aaa = {};
			if (_.is.obj(v)){
				aaa = _.extend({}, v);
			}else if (_.is.fn(v)){
				aaa = {'callback':v};
			}else{				
				continue;
			}

			aaa.ctx 	 = args.ctx;
			aaa.el       = el;
			aaa.name     = name;
			aaa.delegate = delegate;

			// capture events. eg: for scroll, it doesn't bubble (check this for other events: https://stackoverflow.com/questions/5574207/html-dom-which-events-do-not-bubble)
			if (v.delegate && name === 'scroll'){
				aaa.capture = true;
			}

			name && events.push(aaa);
		}
		// _js(events);

		// add default "on-click, on-change, on-..."
		if (args.defaults){
			// you can alter the prefix, instead of "on-" to something else, if args.defaults is a string
			var prefix = (_.is.str(args.defaults) ? args.defaults : 'on') + '-';
			
			// TODO should the other prefix be there?

			function _add (event){
				var attr = prefix + event;
				events.push({
					'name'    : event,
					'delegate': '['+attr+']',
					'callback': function (e){
						var prop = args.prop;
						if (prop){
							var el = e.target;
							while (el){
								if (prop in el && (el[prop] !== args.ctx)) return;
								el = el.parentElement;
							}
						}

						var action = e.target.getAttribute(attr);
						action = _.toAction(action, {
							'type'	  : '->',
							'filters' : '!',		  // eg. adding "!prevent" like so 'on-click="action !prevent"' will call e.prevent()
							'replace' : {
								'target': e.target,   // the target element, for example 'on-click="action($target)"'
								'event' : e,
							}
						});

						if (action.filters.prevent) e.prevent();
						if (action.filters.stop) 	e.stop();

						// target and Element or Window
						var ctx  = this;
						var name = action.name;
						if (action.type){
							name = action.type;

							if (action.name === 'window'){
								ctx = window;
							}else{
								var el = _.dom.get(action.name);
								ctx = el ? el[prop] : null;
							}
						}

						var callback = _.get(ctx, name);
						if (!callback && this.warn){
							this.warn('Callback for [{{attr}}="{{name}}"] doens\'t exists', {
								'attr' : attr,
								'name' : name,
							});
						}else{
							// TODO
						}
	
						var params = action.params.length ? action.params : [e];
						_.apply(callback, params, {'ctx':this});
					}
				});
			};

			// TODO, maybe more events should be added, if necessary
			_.$arr('click,change', _add);
		}
		
		// add the events to the elements
		var remove = [];
		_.dom.els(els, function (el){
			for (i in events){
				v  = events[i];
				el = v.el || el || document;
				
				var r = _.dom.event(el, v.name, v);

				// add the events to a list, so we can remove the events easily
				remove = remove.concat(r.items);
			}
		}, true);

		// TODO, add a way to only disable them. Something like on(), off(), remove/delete();

		function _remove (){
			for (var i in remove){ remove[i](); }
			remove = [];
		}

		// remove all added events
		return _remove;
	};

	this.event.custom = function (name, on, off){
		if (name in DOM.EVENT.CUSTOM){
			return _.error('Custom event "{name}" already exists', {'name':name});
		}
		DOM.EVENT.CUSTOM[name] = {'on':on, 'off':off};
	};

	this.trigger = function (els, names, data, args){
		args            = args || {};
		args.ctx 		= 'ctx' in args ? args.ctx : null;
		args.bubbles    = 'bubbles' in args ? args.bubbles : true;
		args.cancelable = args.cancelable || false;
		
		_.each(names, ' ', function (name){
			name = name.toLowerCase();
			name = DOM.EVENT.ALT_DELEGATE[name] || name;
				
			_.dom.els(els, function (el){
				var klass = DOM.EVENT.CLASSES[name] || 'CustomEvent';
				var event = null;

				if (_.is.fn($win[klass])){
					event = new $win[klass](name, args);
				}else{
					event = $doc.createEvent(klass);
					event = event.initCustomEvent ? event : $doc.createEvent('CustomEvent');
					event.initCustomEvent(name, args.bubbles, args.cancelable, args.data);
				}

				// add custom data
				event.ctx      = args.ctx;
				event.details  = data;
				event.isCustom = true;

				el.dispatchEvent(event);
			}, true);
		});
	};
    
	// dom: other ------------------------------------------------------------------------------------------------------
	this.ready = function (ctx, callback, priority){
		if (_.is.fn(ctx)){
			priority = callback;
			callback = ctx;
			ctx      = null;
		}

		function _is (){
			if (!DOM.IS_READY){
				if ($doc.readyState === 'complete' || ($doc.readyState !== "loading" && !$doc.documentElement.doScroll)){
					DOM.IS_READY = true;
				}
			}
			return DOM.IS_READY === true;
		}

		if (!_.is.fn(callback)){
			return _is();
		}

		callback = ctx ? callback.bind(ctx) : callback;
		priority = priority || 0;
		
		if (_is()){			
			callback();
		}else{
			var callbacks = DOM.ON_READY[priority] = DOM.ON_READY[priority] || [];
			callbacks.push(callback);

			if (DOM.IS_READY === false){
                DOM.IS_READY = 'loading';
                
                function _done (e){
					var list = DOM.ON_READY;

					DOM.IS_READY = true;     
					DOM.ON_READY = [];

					for (var i in list){ for (var ii in list[i]){
						list[i][ii]();
					}}                    
                }

				$doc.addEventListener('website-ready', _done);	// connected to the Web.ready() function
				$doc.addEventListener('DOMContentLoaded', _done);
				$win.addEventListener('DOMContentLoaded', _done);
				$win.addEventListener('load', _done);
			}
		}
    };

    this.load = function (ctx, callback, priority){
		if (_.is.fn(ctx)){
			priority = callback;
			callback = ctx;
			ctx      = null;
		}

		function _is (){
			if (!DOM.IS_LOADED){
				if ($doc.readyState === 'complete'){
					DOM.IS_LOADED = true;
				}
			}
			return DOM.IS_LOADED === true;
		}

		if (!_.is.fn(callback)){
			return _is();
		}

		callback = ctx ? callback.bind(ctx) : callback;
		priority = priority || 0;

		if (_is()){
			callback();
		}else{
			var callbacks = DOM.ON_LOAD[priority] = DOM.ON_LOAD[priority] || [];
			callbacks.push(callback);

			if (DOM.IS_LOADED === false){
                DOM.IS_LOADED = 'loading';
                
                function _done (){
					var list = DOM.ON_LOAD;

					DOM.IS_LOADED = true;
					DOM.ON_LOAD   = [];

					for (var i in list){ for (var ii in list[i]){
						list[i][ii]();
					}}                    
                }

				$win.addEventListener('load', _done);
			}
		}
	};

	this.screen = function (refresh){
		var w    = window.visualViewport ? window.visualViewport.width : $win.innerWidth;
		var h    = window.visualViewport ? window.visualViewport.height : $win.innerHeight;
		var body = $doc.body;

		if (!DOM.SCREEN.BODY){
			refresh = true;
		}
		DOM.SCREEN.BODY = body;

		if (DOM.SCREEN.WIDTH !== w || DOM.SCREEN.HEIGTH !== h || refresh){
			var dummy = DOM.DUMMY;
			var html  = $doc.documentElement;
			var body  = $doc.body || {'scrollWidth':0, 'scrollHeight':0, 'offsetWidth':0, 'offsetHeight':0};
			var style = $win.getComputedStyle(html);
			var sizes = DOM.SIZES = DOM.SIZES || {};

			if (!dummy){
				dummy       = DOM.DUMMY = $doc.createElement('div');
				dummy.style = 'position:fixed; width:100vw; height:100vh; opacity:0;';
				dummy.setAttribute('aria-hidden', 'true');
				dummy.setAttribute('dummy', 'viewport-size');
				$html.appendChild(dummy);
			}


			// screen width/height changes depending on what's on the screen (keyboard, adress bar, ...)
			sizes.width  = $win.innerWidth;
			sizes.height = $win.innerHeight;
			sizes.scale  = $win.visualViewport ? visualViewport.scale : html.clientWidth / w;

			// @info issue with some iOS where the zoom isn't 1 when at the normal scale
			if (sizes.scale <= 1.01){
				sizes.scale = 1;
			}

			// viewport the full screen
			sizes.viewport = {
				'width' : dummy.clientWidth,
				'height': dummy.clientHeight,
			};

			// visible inner space (removing the scrollbars, had the space taken by the address bar)
			dummy.style = 'position:fixed; width:100%; height:100%;';
			
			sizes.viewport.small = {
				'width' : dummy.clientWidth,
				'height': dummy.clientHeight,
			};

			// TODO add dynamic size
			// _v('--viewport-min-height', size.innerHeight, 'px', '100vh');
			// _v('--viewport-max-height', size.viewportHeight, 'px', '100vh');
			// _v('--viewport-dynamic-height', size.screenHeight, 'px', '100vh');
	
			sizes.viewport.offset = {
				'width' : sizes.viewport.width - sizes.viewport.small.width,
				'height': sizes.viewport.height - sizes.viewport.small.height,
			};

			// on mobile, when the keyboard is visible, the visible space if different
			sizes.viewport.visible = {
				'width' : window.visualViewport ? window.visualViewport.width : dummy.clientWidth,
				'height': window.visualViewport ? window.visualViewport.height : dummy.clientHeight,
			};

			// TODO review the sizes names, viewport = full, width/height = inner maybe?? deal with the scale/zoom

			// max content width/height
			sizes.content = {
				'width' : Math.max(html.clientWidth, body.scrollWidth, html.scrollWidth, body.offsetWidth, html.offsetWidth),
				'height': Math.max(html.clientHeight, body.scrollHeight, html.scrollHeight, body.offsetHeight, html.offsetHeight),
			};

			// max possible scroll positions
			sizes.scroll = {
				'width' : $html.scrollWidth - html.clientWidth,
				'height': $html.scrollHeight - html.clientHeight,
			};

			dummy.style.overflow = 'scroll';
			sizes.scroll.size = sizes.content.width - dummy.clientWidth;

			// rem
			sizes.rem = parseInt(style.fontSize, 10);
			
			// orientation
			sizes.orientation = h > w ? 'portrait' : 'landscape'; 
		}

		return DOM.SIZES;
	};

	this.css = function (args, text, inHead){
		if (text === undefined){
			text = args;
			args = {};
		}

		if (_.is.str(args)){
			args = {'name':args};
		}
		
		args         = args || {};
		args.name    = 'name' in args ? args.name : null;
		args.once    = 'once' in args ? args.once : true;
		args.data    = 'data' in args ? args.data : null;
		args.alias   = 'alias' in args ? args.alias : '';		
		args.filter  = args.filter || null;
		args.ctx     = args.ctx || null;

		// no duplicates
		if (args.once && args.name && args.name in DOM.CACHE.STYLE.ONCE_CSS){
			return;
		}

		var el = null;
		if (_.is.el(text)){
			el   = text;
			text = el.innerHTML;
		}

		// make sure the text is a string
		if (_.is.obj(text)){
			text = _.each.filter(text, function (v, i){
				return i + ' ' + (_.is.obj(v) ? _.toString(v, 'css') : '{ '+v+' }');
			}).join('\n');
		}

		title = '/* ' + _.str.pad(args.name + ' ', '-', 80) + ' */\n'
		
		text = text
			.replace(/\t|\n/g, ' ')
			.replace(/\s{2,}/g, ' ')
			.replace(/\}\s+/g, '}\n')
			.trim() + '\n\n';

		// parse the variables in the text
		if (args.data){
			// make sure the vars that have variables are parsed
			for (var i in args.data){
				args.data[i] = _.str.replace(args.data[i], args.data);
			}
			text = _.str.replace(text, args.data);
		}

		// possible filter of the text
		text = _.apply(args.filter, [text], {'ctx':args.ctx});

		// alias
		text = text.replace(/\\/g, '');
		text = _.toAlias(text, args.alias, true);
		
		// validate all the props/values and check for custom attributes
		text = text.replace(CONSTS.RE.STYLE_KEY_VAL, function (m, $1, $2){
			var key   = $1.trim();
			var value = $2.trim();
			if (key in DOM.CACHE.STYLE.CUSTOM){
				return _.apply(DOM.CACHE.STYLE.CUSTOM[key], [key, value]);
			}else{
				return _.toStyle(key, value);
			}
		});

		// fix short variable version
		// text = text.replace(/((?<!var\(\s*)--[a-z][a-z0-9_-]*)/, function (v, $1){
		// 	_js(v, $1);
		// 	return 'var(' + v[1] + ')';
		// });

		text = title + text;

		if (el){
			el.innerHTML = text;
		}else if (inHead !== false){
			text = $doc.createTextNode(text);

			var head = DOM.CACHE.STYLE.HEAD_CSS;
			if (!head){
				head = DOM.CACHE.STYLE.HEAD_CSS = _.dom.get('<style type="text/css" class="head-style"></style>');
				_.dom.add(head, 'prepend', 'head');
			}

			_.dom.add(text, head);
		}

		if (args.once && args.name){
			DOM.CACHE.STYLE.ONCE_CSS[args.name] = true;
		}

		return text;
	};

	/**
	 * Parse a <style> by replacing it's scope/alias in the content
	 * 
	 * @param {*} args 
	 * @param {*} args.selector 	CSS Selector
	 * @param {*} args.data 		
	 * @param {*} data				Object to use for vaiables
	 */
	this.css.parse = function (args, data){
		if (_.is.either(args, 'str,el')){
			args = {'selector':args};
		}

		args          = args || {};
		args.selector = args.selector || 'style[scope]';
		args.data 	  = data || args.data || {};

		_.dom.get.all('style[scope]', function (style){
			var scope = style.getAttribute('scope');
			
			_.dom.css({
				'alias': scope,
				'name' : _.toSlug(scope, 'words'),
				'data' : data,
			}, style);

			style.removeAttribute('scope');
        });
	};

	this.css.custom = function (name, callback){
		if (name in DOM.CACHE.STYLE.CUSTOM){
			return _.error('Custom css attribute "{name}" already exists', {'name':name});
		}

		DOM.CACHE.STYLE.CUSTOM[name] = function (name, value){
			var v = _.toValues(value, false);
			var s = _.apply(callback, v);

			if (_.is.obj(s)){
				return _.toString(s, {'pair':':', 'join':'; ', 'json':false});
			}else if (_.is.either(s, 'str,nbr')){
				return s.toString();
			}else{
				_.error('The Custom CSS attribute "{name}" didn\'t return a valid value', {'name':name});
				return '';
			}
		};
	};
});
FFTO.Utils.add('dom.event', function (DOM, CONSTS, RE, _, $win, $doc){
    this.custom('tap', function (el, args, callback){
		function _tap (e){
			if (e.type === 'keyup'){
				var input 	 = _.dom.is(e.target, 'button, [href], input, select, textarea');
				var tabindex = e.target.getAttribute('tabindex');
				if (e.key.value !== 'Enter' || input || tabindex === null || tabindex == -1){
					return;
				}
			}
			e.type = 'tap';
			callback(e);
		}
		return _.dom.on(el, 'click keyup', args, null, _tap);
	});

	this.custom('input-change', function (el, args, callback){
		args           = args || {};
		args.delay     = 'delay' in args ? args.delay : 0;				// normal input will have a short delay
		args.delayText = 'delayText' in args ? args.delayText : 700;	// text input will have a longer delay
		
		var timeout = null;

		function _focus (e){
			e.target._value = _.dom.value(e.target);
		}

		function _change (e){
			var target  = e.original.target;
			var isInput = _.is.input(target);  // <a> link returns a "change" event for some reason, when tabbing over it, after being in an input
			if (!isInput) return;

			var isText = _.is.el(target, ':text-input');			
			if (e.type === 'keyup' && !isText) return;

			var old   = target._value;
			var value = _.dom.value(target);
			var delay = e.type === 'keyup' && isText && value ? args.delayText : args.delay;			

			// changed
			if ((!isText && e.type === 'change') || old != value){
				e.type  = 'input-change';
				e.old   = old;
				e.value = value;

				clearTimeout(timeout);
				timeout = setTimeout(function (){
					// save the value, only after a little delay, since event can be listened by many ctx
					if (isText){
						target._value = value;
					}
					callback(e);
				}, delay);
			}
		}

		var change = _.dom.event(el, 'change change-value search keyup', args, null, _change);
		var focus  = _.dom.event(el, 'focusin', {'delegate':args.delegate}, null, _focus);

		return function (){
			change();
			focus();
		};
	});

	this.custom('hover', function (el, args, callback){
		var hovered = [];

		function _mouse (e){
			var enter = e.type === 'mouseenter'; 

			if (enter){
				hovered.push(e.target);
			}else{
				var i = hovered.indexOf(e.target);
				hovered.splice(i, 1);
			}

			e.type = enter ? 'hover-in' : 'hover-out';

			callback([e, enter]);
		};

		function _move (e){
			if (!hovered.length) return;

			var t = args.delegate ? _.dom.closest(e.original.target, args.delegate) : e.original.target;
			
			// you're in a targetted item, so forget about it
			if (_.dom.contains(el, t, true)) return;

			// hovered items that didn't get their "mouseleave", trigger them
			for (var i in hovered){
				var evt = _.copy(e, {
					'type'  : 'hover-out',
					'target': hovered[i],
				});
				callback([evt, false]);
			}
			
			hovered = [];
		}

		var hover = _.dom.event(el, 'mouseenter mouseleave', args, null, _mouse);
		var move  = _.dom.event(document, 'mousemove', null, null, _move);

		return function (){
			hover();
			move();
		}
	});

	this.custom('mouse', function (el, args, callback){
		function _mouse (e){
			e.isStart = e.type === 'mouseenter';
			e.isChange= e.type === 'mousemove';
			e.isEnd   = e.type === 'mouseleave';
			e.type    = 'mouse';
			// TODO maybe add a condition if "onclick", or "onshift / ctrl"
			// TODO add startX deltaX duration for velocity, ...
			callback(e);
		};
		return _.dom.event(el, 'mouseenter mousemove mouseleave', args, null, _mouse);
	});

	// a better version of "mouse" for both desktop and mobile. detect if the user is touching/holding click on the screen too
	this.custom('cursor', function (el, args, callback){
		var isMoving  = false;
		var isStart     = false;
		var isEnd       = false;
		var isDown      = false;
		var threshold   = args.threshold || 5;
		var x           = null;
		var y           = null;
		var xx 			= null;
		var yy 			= null;
		var ww          = null;
		var hh          = null;
		var timeoutMove = null;                 // for moving 
		var timeoutEnd  = null;                 // for moving 
		
		// discover tap
		var startX   = null;
		var startY   = null;
		var lastX    = 0;
		var lastY    = 0;
		var deltaX   = 0;
		var deltaY   = 0;
		var start    = 0;
		var hasMoved = false;
		var node 	 = null;

		function _start (e){
			var hasLeft = false;
			if (!isDown && e.type === 'mouseleave'){
				hasLeft = true;
			}

			if (!node){
				var b = _.dom.bounds(e.target);
				xx = b.vbox.x;
				yy = b.vbox.y;
				ww = b.vbox.width;
				hh = b.vbox.height;
			}

			node = e.target;

			if (e.type === 'mousemove'){
				return;
			}

			_cursor(e, hasLeft);
		}

		function _cursor (e, hasLeft){
			if (!node) return;

			var t       = e.type;
			var tt      = 'cursor-move';
			var wasDown = isDown;

			if (t === 'click' && hasMoved){
				hasMoved = false;
				e.prevent();
			}
			if (hasLeft){
				t = 'mouseleave';
			}

			// refresh the bounds
			if (t === 'mouseenter' || t === 'touchstart'){
				var b = _.dom.bounds(node);
				xx = b.vbox.x;
				yy = b.vbox.y;
				ww = b.vbox.width;
				hh = b.vbox.height;
				// _js('refresh', xx, ww);
			}

			// enter/leave
			if (t === 'mouseenter' || t === 'touchstart'){
				tt = 'cursor-enter';
			}else if (t === 'mouseleave' || t === 'touchend' || t === 'touchcancel'){
				tt = 'cursor-leave';
			}
			
			// move isStart, isEnd
			if (t === 'mousemove' || t === 'mouseenter' || t === 'touchstart' || t === 'touchmove'){
				isStart  = !isMoving;
				isEnd    = false;
				isMoving = true;
			}else if (t === 'mouseleave' || t === 'touchend' || t === 'touchcancel'){
				isStart  = false;
				isEnd    = isMoving;
				isMoving = false;
			};

			// cursor click
			if (t === 'mousedown' || t === 'touchstart'){
				hasMoved = false;
				isDown   = true;
				tt       = 'cursor-down';
			}else if (t === 'mouseup' || t === 'touchend' || t === 'touchcancel'){
				isDown = false;
				tt     = 'cursor-up';
			}

			// update the x/y position (if available)
			if (e.page.x !== undefined){
				x = e.page.x;
			}
			if (e.page.y !== undefined){
				y = e.page.y;
			}

			// start of click
			if (!wasDown && isDown){
				start    = _.now();
				startX   = x;
				startY   = y;
				lastX    = x;
				lastY    = y;
			}

			// is/was down
			if (isDown || wasDown){
				deltaX = x - startX;
				deltaY = y - startY;
			}else{
				deltaX = null;
				deltaY = null;
			}

			// is up
			var duration = null;
			if (wasDown && !isDown){
				duration = _.now() - start;

				// the user hasn't moved enough, so it's considered a click
				if (Math.abs(deltaX) <= threshold && Math.abs(deltaY) <= threshold){
					tt = 'cursor-click';
				}
				
				node = false;
			}

			if (hasLeft){
				node = false;
			}
			
			// Moving a bit (5px while the click is down), then we know the cursor has moved
			if (t === 'mousemove' && isDown && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)){
				hasMoved = true;
			}

			e.isStart  = isStart;
			e.isChange = !isStart && !isEnd;
			e.isEnd    = isEnd;
			e.isDown   = isDown;
			e.isMoving = isMoving;
			e.isMouse  = e.type.indexOf('mouse') === 0;
			e.x        = x;
			e.y        = y;
			e.w        = ww;
			e.h        = hh;
			e.ratioX   = (e.original.clientX - xx) / ww;
			e.ratioY   = (e.original.clientY - yy) / hh;
			e.startX   = isDown ? startX : null;
			e.startY   = isDown ? startY : null;
			e.deltaX   = deltaX;
			e.deltaY   = deltaY;
			e.moveX    = x - lastX;
			e.moveY    = y - lastY;
			e.duration = duration;
			e.hasMoved = hasMoved;
			e.type     = tt;
			
			lastX = x;
			lastY = y;

			callback(e);

			clearTimeout(timeoutMove);
			if (isMoving){
				timeoutMove = setTimeout(function (){
					isStart  = false;
					isEnd    = true;
					isMoving = false;

					e.type     = 'cursor-move';
					e.isStart  = false;
					e.isEnd    = true;
					e.isChange = false;

					callback(e);
				}, 100);
			}

			// isEnd
			clearTimeout(timeoutEnd);
			if (isEnd){
				timeoutEnd = setTimeout(function (){
					hasMoved = false;
				}, 400);
			}
		};

		var eMove  = null;
		var eStart = _.dom.event(el, 'mousedown mouseenter mouseleave touchstart mousemove', args, null, _start);
		var eMove  = _.dom.event(document, 'mousemove mouseup mouseleave touchmove touchend touchcancel click', null, null, _cursor);

		// function _listen (add){
		// 	if (add && !eMove){
		// 		eMove = 
		// 	}else if (!add && eMove){
		// 		eMove();
		// 		eMove = null;
		// 	}
		// }

		return function (){
			eStart();
			eMove();
		};


		// return _.dom.event(el, '\
		// 	mousedown mouseenter touchstart \
		// 	mousemove mouseup touchmove \
		// 	mouseleave touchend touchcancel \
		// 	click\
		// ', args, null, _cursor);
	});

	this.custom('click-drag', function (el, args, callback){
		args             = args || {};
		args.type        = args.type || null;
		args.click       = 'click' in args ? args.click : true;		// need to rethink that naming, feels like "click" would be to let the click event go-through, but it's to hijack the click event
		args.momentum    = args.momentum || false;
		args.orientation = args.orientation || null;
		args.threshold   = args.threshold || 5;
		args.cancel      = 'cancel' in args ? args.cancel : true;

		var target      = null;
		var startTime   = null;
		var startX      = 0;
		var startY      = 0;
		var previousX   = null;
		var previousY   = null;
		var lastX       = null;
		var lastY       = null;
		var bounds      = null;
		var orientation = null;
		var horizontal  = null;
		var vertical    = null;
		var isClicked   = false;
		var isDragging  = false;
		var isStart     = false;
		var tick        = null;

		function _valid (e){
			var type = e.type;
			if (args.type === 'mouse'){
				return type.indexOf('mouse') === 0;
			}else if (args.type === 'touch'){
				return type.indexOf('touch') === 0;
			}
			return true;
		}

		function _start (e){
			// Cancel the click if the user was dragging
			if (e.type === 'click'){
				isDragging && e.cancel();
				return;
			}

			if (!_valid(e)) return;

			_.cancel(tick);

			target      = e.target;
			startX      = lastX = previousX = e.client.x;
			startY      = lastY = previousY = e.client.y;
			startTime	= null;
			isStart     = null;
			isDragging  = false;
			isClicked   = true;
			orientation = null;
			horizontal  = null;
			vertical    = null;

			_listen(true);
		};

		function _move (e){
			if (!_valid(e) || !isClicked) return;
			var trigger = false;
			var isEnd 	= false;
			
			// end
			if (e.type === 'mouseup' || e.type === 'touchend' || e.type === 'touchcancel'){
				// trigger event for CLICKS
				if (isDragging || (!isDragging && args.click)){
					trigger = [true];
					isEnd   = true;
				}
				_listen(false);
			}else{
				var dx  = e.client.x - startX;
				var dy  = e.client.y - startY;
				var adx = Math.abs(dx);
				var ady = Math.abs(dy);

				// move delay
				if (!isDragging && (!args.threshold || (adx > args.threshold || ady > args.threshold))){
					isStart     = true;
					isDragging  = true;
					orientation = adx > ady ? 'horizontal' : 'vertical';
					startX      = lastX = e.client.x;
					startY      = lastY = e.client.y;
				}

				if (isDragging){
					trigger = [e.client.x, e.client.y];
				}
			}	

			if (trigger && (
				(args.click && !isDragging) 		// click event
				|| !args.orientation				// drag event (any direction)
				|| args.orientation === orientation	// drag event
			)){
				args.cancel && e.cancel();
				
				if (isEnd && args.momentum){
					var x        = lastX;
					var y        = lastY;
					// var duration = _.now() - startTime;
					// var multiply = startTime < 1;
					var distX   = x - previousX;
					var distY   = y - previousY;
					var damping = _.is.nbr(args.momentum) ? args.momentum : 0.85;
			
					// skip the if less than 10px move
					if (Math.abs(distX) < 10) distX = 0;
					if (Math.abs(distY) < 10) distY = 0;

					tick = _.fn.tick(function (e){
						x 		+= distX;
						y 		+= distY;
						distX 	*= damping;
						distY 	*= damping;
						if (Math.abs(distX) < 1) distX = 0;
						if (Math.abs(distY) < 1) distY = 0;

						if (!e.isStopped && (distX || distY)){
							_trigger.apply(null, [x, y]);
						// momentum is done
						}else{
							_trigger.apply(null, [true]);
							return false;
						}
					});
				}else{
					_trigger.apply(null, trigger);
				}
			}
		};

		function _trigger (x, y){
			if (isStart || bounds === null){
				bounds = _.dom.bounds(target);
			}

			var isEnd = x === true;

			x = !_.is.nbr(x) ? lastX : x;
			y = !_.is.nbr(y) ? lastY : y;

			var xx  = x - bounds.bbox.x;
			var yy  = y - bounds.bbox.y;
			var rrx = xx / bounds.bbox.width;
			var rry = yy / bounds.bbox.height;
			var rx  = _.math.clamp(rrx);
			var ry  = _.math.clamp(rry);

			var type = 'drag-move';
			if (!isDragging)   type = 'drag-click';
			else if (isStart)  type = 'drag-start';
			else if (isEnd)    type = 'drag-end';

			var now = _.now();

			startTime = isStart ? now : startTime;

			var e = {
				'type'       : type,
				'isStart'    : isStart,
				'isChange'   : !isStart && !isEnd,
				'isEnd'      : isEnd,
				'pageX'      : x,
				'pageY'      : y,
				'x'          : xx,
				'y'          : yy,
				'width'      : bounds.bbox.width,
				'height'     : bounds.bbox.height,
				'start'		 : startTime,
				'duration'	 : now - startTime,
				'startX'     : startX,
				'startY'     : startY,
				'deltaX'     : x - startX,
				'deltaY'     : x - startY,
				'diffX'      : lastX - x,		// TODO should be rename maybe, to lastDiffX or something like that
				'diffY'      : lastY - y,
				'ratioX'     : rx,
				'ratioY'     : ry,
				'ratioXX'    : rrx,                                      // ratio, but not restricted to 0-1 min-max limits
				'ratioYY'    : rry,                                      // ratio, but not restricted to 0-1 min-max limits
				'percentX'   : Math.round(rx * 1000000) / 10000 + '%',
				'percentY'   : Math.round(ry * 1000000) / 10000 + '%',
				'orientation': orientation,
			};

			callback(e);
			
			previousX = lastX; // needed for momentum
			previousY = lastY;
			lastX     = x;
			lastY     = y;
			isStart   = false;
		}

		// TODO cancel click....
		
		function _listen (add){
			if (add && !eMove){
				eMove = _.dom.event(document, 'mousemove mouseup touchmove touchend touchcancel', null, null, _move);
			}else if (!add){
				eMove();
				eMove = null;
			}
		}
		
		var eMove  = null;
		var eStart = _.dom.event(el, 'mousedown touchstart click', args, null, _start);

		return function (){
			eStart();
			eMove && eMove();
		};
	});

	this.custom('drag-drop', function (el, args, callback){
		function _dragDrop (e){
			e.prevent();

			e.isStart = e.type === 'dragenter';
			e.isChange= e.type === 'dragover';
			e.isEnd   = e.type === 'dragleave';
			e.isOver  = e.isStart || e.isChange;
			e.isDrop  = e.type === 'drop';
			e.type    = 'drag-drop';

			callback(e);
		};

		return _.dom.event(el, 'dragenter dragover dragleave drop', args, null, _dragDrop);
	});

	this.custom('click-outside', function (el, args, callback){
		function _click (e){
			// setTimeout(function (){
				// if a children node change the DOM elements, we need to check the "elementFromPoint" instead of e.original.target
				// When clicking on a button, it might not give a x/y, so revert to the e.original.target
				var target   = e.client.x || e.client.y ? document.elementFromPoint(e.client.x, e.client.y) : e.original.target;
				var isInside = _.dom.contains(el, target);

				if (!isInside){
					e.type = 'click-outside';
					callback([e]);
				}
			// }, 30);
		}

		return _.dom.event(document, 'click', args, null, _click);
	});

	// TODO only the IntersectionObserver won't work if the element wasn't visible (display:none) first
	this.custom('visible', function (el, args, callback){
		var o = new IntersectionObserver(function (items){
			_.$arr(items, function (item){ 
				if (!item.isIntersecting) return;
				callback({
					'type'  : 'visible',
					'ratio' : item.intersectionRatio,
					'target': item.target,
					'ctx'	: args.ctx,
				});

				// [ ] deal with "out of view"
			});			
		}, {
			'root'      : args.root || null,
			'rootMargin': args.margin || '0px',
			'threshold' : 'threshold' in args ? args.threshold : 0,
		});

		// TODO show alerts if trying to target a delegated item, .... it can't work

		el = _.is.el(el) ? el : document.body;
		o.observe(el);

		return function (){ 
			o.disconnect();
		};
	});

	this.custom('item-scroll', function (el, args, callback){
		// TODO Add a way to have event callback priority. 
		var isStart = {};
		var isEnd   = {};
		var data    = {};
		var lastX 	= null;
		var lastY   = null;
		var x       = null;
		var y       = null;

		function _scroll (e){
			var scroll  = _.dom.scroll(e.target);
			var trigger = lastX !== scroll.x || lastY !== scroll.y;

			lastX = scrollX;
			lastY = scrollY;

			trigger && callback([e]);
		}

		// _scroll = _.fn.throttle(args.ctx, 50, _scroll);
		
		_.dom.on(el, 'scroll', _scroll);
	});

	// TODO add page-change height

	this.custom('page-resize', function (el, args, callback){
		// TODO Add a way to have event callback priority. 

		function _change (e){
			e.isResize = e.type === 'resize';
			e.isLoad   = e.type !== 'resize';
			callback([e]);
		}
		_.dom.ready(function (){ _change({'type':'ready'}); });
		_.dom.load(function (){ _change({'type':'load'}); });
		_.dom.on(window, 'resize', _change);
		
		_change({'type':'now'});
	});

	this.custom('page-scroll', function (el, args, callback){
		function _change (e){
			callback([e]);
		}

		// add isStart, isEnd, ....

		_.dom.ready(function (){ _change({'type':'ready'}); });
		_.dom.load(function (){ _change({'type':'load'}); });
		_.dom.on(window, 'scroll', _change);
		_change({'type':'now'});
	});


	this.custom('page-change', function (el, args, callback){
		function _change (e){
			e.isScroll = e.type !== 'resize';
			e.isResize = e.type === 'resize';
			e.isLoad   = e.type !== 'resize' && e.type !== 'scroll';
			callback([e]);
		}

		// TODO be able to differentiate "isStart", "isChange" and "isEnd" for resize and scroll events

		// TODO deal with the scroll event ON PAGE LOAD.....

		_.dom.ready(function (){ _change({'type':'ready'}); });
		_.dom.load(function (){ _change({'type':'load'}); });
		_.dom.on(window, 'resize scroll', _change);
		_change({'type':'now'});

		// scroll is either BODY or Window
		// _.dom.on(window, 'load resize scroll', _change);

		// _.dom.on(window, 'load resize scroll', _change);
		// if (_.is.fn(args)){
		// 	callback = args;
		// 	args     = {};
		// }

		// args        = args || {};
		// args.now 	= 'now' in args ? args.now : true;
		// args.resize = 'resize' in args ? args.resize : true;
		// args.load   = 'load' in args ? args.load : true;
		// args.scroll = 'scroll' in args ? args.scroll : false;

		// callback = callback.bind(this);

		// args.now && callback();
		// args.load && this.on(Browser, 'load', callback);
		// args.resize && this.on(Browser, 'resize', callback);
		// args.scroll && this.on(Browser, 'scroll', callback);
	});

	// this.custom('media-load', function (el, args, callback){
	// 	_js(el, args, callback);
	// 	// _.media(el, {'ctx':this}, function (e){
    //     //     _js(1);
    //     //     this.refresh();
    //     // });
	// });
});
FFTO.Utils.add('dom.css', function (DOM, CONSTS, RE, _, $win, $doc){
    this.custom('cover', function (position, top, right, bottom, left){
		var inset = _.to4Values([top, right, bottom, left]);
		return {
			'--y1'	  : inset[0],
			'--x1' 	  : inset[1],
			'--y2'	  : inset[2],
			'--x2' 	  : inset[3],
			'position': position,
			'top'	  : 'var(--x1, 0px)',
			'left'	  : 'var(--y1, 0px)',
			'width'   : 'calc(100% - var(--x1, 0px) - var(--x1, 0px))',
			'height'  : 'calc(100% - var(--y1, 0px) - var(--y2, 0px))',
		};
	});
});
// [ ] Add $delay to loading the element, and $preload
// [ ] Add debug
// [ ] If destroy, add a way to remove all events
// [ ] Add mixins
// [ ] Add Element to the namespace: Class.Element (in "utils/100-element.js")

(function (_, $, $win){
    var CLASSES = $.Classes = $win.Classes = {};
    var PATHS   = CLASSES.$paths = {};

    // Helpers ---------------------------------------------------------------------------------------------------------
    function toLog (ctx, params, color){
        params = _.$arr(params);

        var str  = params[0];
        var data = params[1];
        if (_.is.str(str, '{{') && _.is.obj(data)){
            str    = _.str.replace(str, data);
            params = [str].concat(params.slice(2));
        }

        var id = ctx.id ? '#'+ctx.id : ctx.constructor.name;
    
        if (ctx.constructor.name === 'Function'){
            id = 'Class:' + ctx.name;
        }

        _._log({
            'file'  : false,
            'color' : color || 'green',
            'prefix': id,
        }, params);

        return ctx;
    };

    function toFilepath (v){
        return v.split('/').map(function (v){ return _.toSlug(v); }).join('/');
    };

    function toObjectPath (v){
        return v.split('/').map(function (v){ return _.toSlug(v, 'words'); });
    };

    function toClass (path, Definition, config){
        if (!_.is.either(path, 'str,bool')){
            Definition = path;
            path       = null;
        }

        config       = config || {};
        config.param = CLASSES;

        var Class  = _.toClass(config, Definition);
        var proto  = Class.prototype;
        var $class = Class;

        // uses ----------------------------------------------------------------
        var $uses = _.$arr(proto.$uses, toFilepath);

        for (var i in $uses){
            var use = $uses[i];
            if (PATHS[use]) continue;
            proto.error('Requires "{{ use }}" class to work properly', {'use':use});
            return;
        }

        // singleton -----------------------------------------------------------
        var $singleton = proto.$singleton = proto.$singleton || (path === true);
        
        if ($singleton){
            $class = new Class();
        }
        
		// When the class is created, call this immediately 
		if (proto.$onDefineClass){
			proto.$onDefineClass.apply(Class, [$class]);
		}

        // paths ---------------------------------------------------------------
        var $path     = ((_.is.str(path) ? path : proto.$path) || Class.name);
        var $public   = '$public' in proto ? proto.$public : true;
        var $shortcut = proto.$shortcut;
        var $utils    = proto.$utils;

        var path2   = toObjectPath($path);                                    // transform the path from dash case to words case
        var path1   = toFilepath($path);                                      // path in slug and / case
        
        // Set the full slug path and the object path for the new class
        _.set(PATHS, path1, $class);
        _.set(CLASSES, path2, $class);

        // add the class to the Window object
        if ($public){
            _.set($win, path2, $class);
        }

        // add a shortcut function to the Window object
        if ($shortcut){
            _.set($win, $shortcut, function (){ return $class.$new(arguments); });
        }

        // add shortcut function FFTO.Utils
        if ($utils){
            _.set(_, $utils, function (){ return $class.$new(arguments); });
        }

        // clean up ------------------------------------------------------------
        // remove things in case of extending that class
        delete(proto.$public);
        delete(proto.$path);
        delete(proto.$shortcut);
        delete(proto.$utils);

        return $class;
    };

    // Class -----------------------------------------------------------------------------------------------------------
    var ClassBase = {
        // init ----------------------------------------------------------------
        // methods -------------------------------------------------------------
        'args' : function (i, v){
            var set = _.toSet(i, v, {});
            for (var i in set){
                // use the setter if it's defined
                if (Object.getOwnPropertyDescriptor(this, i)){
                    this[i] = set[i];
                }else{
                    this.$[i] = set[i];
                }
            }
            return this;
        },
        'apply' : function (fn, args, fallback){
            fn = _.is.str(fn) ? this[fn] : fn;
            return _.apply.ctx(this, fn, args, fallback);        
        },
        'each' : function (){ 
            return _.each.ctx(this, arguments); 
        },
        'wait' : function (delay, callback){ 
            return _.fn.wait(delay, this, callback); 
        },   
        'log' : function (){ 
            return toLog(this, arguments, this.$log);   // log color if set as as "$log" property
        },
        'warn' : function (){ 
            return toLog(this, arguments, '#f58303');
        },
        'error' : function (){ 
            return toLog(this, arguments, 'red');
        },
        // get/set -------------------------------------------------------------
        '$get' : {
            'type'  : function (){ return this.constructor.name; },
            'types' : function (){ return this.constructor.types; },
        },
    };

    var Class = $.Class = $win.Class = function (path, Definition){ 
        return toClass(path, Definition, {'base':ClassBase}); 
    };

    // Module ----------------------------------------------------------------------------------------------------------
    // [ ] Add $style
    var ModuleBase = _.extend(true, {}, ClassBase, {
        '$states':{
            'ready' : false,
            'debug' : false,
        },
        '$onPostSetup':function (proto){
            // add auto getter/setter for states
            _.$arr(proto.$states, function (v, i){
                _.obj.prop(proto, i, 
                    function set (){ return this.$.states[i]; }, 
                    function get (vv){ this.state(i, vv); }
                );
            });
        },
        '$onFirstInit':function (){
            // default styles
            this.$style && _.dom.css({
                'name'  : '##' + this.type,
                'alias' : this.slug,
            }, this.$style);
        },
        // init ----------------------------------------------------------------
        'preInit':function (){
            var $proto     = this.constructor.prototype;
            var $static    = this.$static;
            var $singleton = $static.$singleton;
            var count      = $static.count = ($static.count || 0) + 1;
            var id         = $singleton ? $static.name : $static.name + '_' + count;

            // properties
            this.id       = id; 
            this.$.states = {};

            // set the states
            _.$arr($proto.$states, {'ctx':this}, function (v, i){
                this[i] = v;
            });
        },
        'postInit':function (){
            // ready state
            this.cache();
            this.render();
            this.ready = true;
        },
        'cache':function (){
            // empty
        },
        'render':function (){
            // empty
        },
        'refresh':function (){
            this.cache();
            this.render();
        },
        'destroy':function (){
            // empty
        },
        // methods ------------------------------------------------------------- 
        'state' : function (key, value, delayed){
            this.$.states = this.$.states || {};

            if (!arguments.length){
                return this.$.states;
            }

            // multiple states at the same time
            if (_.is.obj(key)){
                for (var i in key){
                    this.state(i, key[i]);
                }
                return this;
            }

            // check if the state has a linked auto setter function
            if (this.$states && _.is.fn(this.$states[key])){
                value = this.$states[key].apply(this);
            }
            
            var old = this.$.states[key];
            if (value !== undefined){
                this.$.states[key] = value;
    
                // special magic methods $onStateChange
                if (value !== old && this.$onStateChange){
                    this.$onStateChange(key, value, old);  
                }
    
                !delayed && (old = value);
            }
    
            return old;
        },
        'http' : function (url, data, args, callback){ 
            // check if there's currently an http call
            if (!arguments.length){
                return !!this.$.isFetching;
            } 

            // format the URL for wordpress AJAX call (if it's just normal text)
            if (_.theme('is_wp')){
                url = !~url.indexOf('/') ? '/wp-admin/admin-ajax.php?action=' + url : url;
            }    

            // [ ] maybe turn isFetching into a state

            this.$.isFetching = true;
            _.http(url, data, args, callback, this, function (){
                this.$.isFetching = false;
            });

            return this;
        },
        'tick' : function (args, callback, done){ 
            _.fn.tick(args, callback, done, this); 
            return this;
        },
        'animate' : function (args, callback, done){
            _.fn.animate(args, callback, done, this); 
            return this;
        },
        'css' : function (style){
            var name  = this.constructor.name;
            var alias = this.constructor.slug;
            _.dom.css({
                'name'  : 'Style: ' + name,
                'alias' : alias,
            }, style);
            return this;
        },
        '$$' : function (selector, args, callback){
            return _.$$(selector, args, callback, this, this.$static.slug);
        },
        'on' : function (els, names, args, callback){
            if (_.is.fn(names)){
                var events   = this.$.events = this.$.events || {};
                var callback = names;
                _.each(els, function (n){ 
                    events[n] = events[n] || [];
                    events[n].push(callback);
                });
                return this;
            }

            if (els === ':ready'){
                _.dom.ready(this, names);
            }else if (els === ':load'){
                _.dom.load(this, names);
            }else{
                _.dom.on(els, names, args, callback, {'ctx':this, 'alias':this.slug});
            }

            // [ ] add these to a list, so if we call destroy, we can remove all the events

            return this;
        },
        'trigger' : function (name, data){
            var events    = this.$.events || {};
            var callbacks = events[name] || [];
            
            for (var i in callbacks){
                var c = callbacks[i];
                if (!_.is.fn(c)) continue;
                c.call(this, data);
            }

            return this;
        },
        'when' : function (key, callback, ctx){
            // switch callback and ctx
            if (_.is.fn(ctx) && !_.is.fn(callback)){
                callback = [ctx, ctx = callback][0];
            }

            this.$.when = this.$.when || {};

            _.fn.when(key, callback, this.$.when, ctx || this);
        },
        // get/set -------------------------------------------------------------
        '$get' : {
            'id'  : function (){ return this.$.id; },
            'slug': function (){ return (this.$.slug || (this.$.slug = _.toSlug(this.type))); },
            // 'classnames': function (){ return this.$.classnames || []; },
        },
        '$set' : {
            'id'  : function (v){ this.$.id = v; },
            'slug': function (v){ this.$.slug = _.toSlug(v); },
            // 'classnames': function (v){ this.$.classnames = utils._each(v); },
        },
    });

    var Module = $.Class.Module = $win.Module = function (path, Definition){ 
        return toClass(path, Definition, {'base':ModuleBase});
    };

    // More ------------------------------------------------------------------------------------------------------------
    Class.add = function (name, callback){
        Class[name] = function (Definition){
            // var $class = _.toProto(Definition);
            // $class.name    = Definition.name;
            // $class.$extend = $class.$extend || CLASSES.Element;
            // var $module = toClass($class);
            // return $module;
        };
    };
}(FFTO.Utils, FFTO, window));


// [deprecated] Old version of the API code
FFTO.Api = (function (_, $$$){
    var API = $$$.API = {};
    var LOG = window._log;
    
    function $log (ctx, params, color){
        params = _.$arr(params);

        var str  = params[0];
        var data = params[1];
        if (_.is.str(str, '{{') && _.is.obj(data)){
            str    = _.str.replace(str, data);
            params = [str].concat(params.slice(2));
        }

        var id = ctx.id ? '#'+ctx.id : ctx.constructor.name;
    
        if (ctx.constructor.name === 'Function'){
            id = 'Class:' + ctx.name;
        }

        LOG({
            'file'  : false,
            'color' : color || 'green',
            'prefix': id,
        }, params);

        return ctx;
    };
    
    function $states ($class){
        var states = $class.prototype.$states;
				
        _.$arr(states, function (v, i){
            _.obj.prop($class.prototype, i, function (){
                // this.$.states = this.$.states || {};
                return this.$.states[i];
            }, function (vv){
                this.state(i, vv);
            });
            
            $class.$preInits.push(function (){ 
                this[i] = v; 
            });
        });

        $class.prototype.state = _state;
    };

    function $add (proto, name, callback){
        if (name in proto) return;
        proto[name] = callback;
    };

    // defaults --------------------------------------------------------------------------------------------------------
    // Only set the properties in "this.$"
    function _args (i, v){
        var set = _.toSet(i, v, {});
        for (var i in set){
            // _js(i, Object.getOwnPropertyDescriptor(this.__proto__, i));

            // use the setter if it's defined
            if (Object.getOwnPropertyDescriptor(this.__proto__, i)){
                this[i] = set[i];
            }else{
                this.$[i] = set[i];
            }
        }
        return this;
    };
    function _apply (callback, args, fallback){
        callback = _.is.str(callback) ? this[callback] : callback;
        return _.apply.ctx(this, callback, args, fallback);        
    };
    function _each (){ 
        return _.each.ctx(this, arguments); 
    };
    function _wait (delay, callback){ 
        return _.fn.wait(delay, this, callback); 
    };
    function _state (key, value, delayed){
        if (_.is.obj(key)){
            for (var i in key) this.state(i, key[i]);
            return this;
        }

        // make sure the states exists
        this.$.states = this.$.states || {};
            
        // check if the state has a linked auto setter function
        if (this.$states && _.is.fn(this.$states[key])){
            value = this.$states[key].apply(this);
        }
        
        var old = this.$.states[key];
        if (value !== undefined){
            this.$.states[key] = value;

            // update all the $targets states
            if (value !== old && this.$onStateChange){
                this.$onStateChange(key, value, old);       // special methods $onStateChange
            }

            !delayed && (old = value);
        }

        return old;
    };
    
    function _log (){ 
        return $log(this, arguments, this.$log);
    };
    function _warn (){ 
        return $log(this, arguments, '#f58303');
    };
    function _error (){ 
        return $log(this, arguments, 'red');
    };

    function _tick (args, callback, done){ 
        _.fn.tick(args, callback, done, this); 
        return this;
    };
    function _http (url, data, args, callback){ 
        // format the URL for wordpress AJAX call (if it's just normal text)
        if (_.theme('is_wp')){
            url = !~url.indexOf('/') ? '/wp-admin/admin-ajax.php?action=' + url : url;
        }    
        _.fn.http(url, data, args, callback, this); 
        return this;
    };
    function _css (style){
        var name  = this.constructor.name;
        var alias = this.constructor.slug;
        _.dom.css({
            'name'  : 'Style: ' + name,
            'alias' : alias,
        }, style);
        return this;
    };
    function _$$ (selector, args, callback){
        return _.$$(selector, args, callback, this, this.$static.slug);
    };
    function _refresh (){
        this.cache && this.cache();
        this.render && this.render();
    };

    function _on (els, names, args, callback){
        if (els === ':ready'){
            _.dom.ready(this, names);
        }else if (els === ':load'){
            _.dom.load(this, names);
        }else{
            _.dom.on(els, names, args, callback, {'ctx':this, 'alias':this.$static.$slug});
        }
        return this;
    };
    function _when (key, callback, ctx){
        // switch callback and ctx
        if (_.is.fn(ctx) && !_.is.fn(callback)){
            callback = [ctx, ctx = callback][0];
        }

        this.$.when = this.$.when || {};
        _.fn.when(key, callback, this.$.when, ctx || this);
    };

    // init ------------------------------------------------------------------------------------------------------------
    window.Api = function Api (singleton, definition, save){
        if (!_.is.bool(singleton)){
            save       = definition;
            definition = singleton;
            singleton  = false;
        }

        var $class     = _.toClassOld(definition, {'proto':'$states'});    // Class definition
        var $proto     = $class.prototype;
		var $singleton = $proto.$singleton || singleton;      // Is the returned object a Singleton OR the Class 
        
		var $path      = $proto.$path || $class.name;         // path to save in the window global object
		var $window    = $proto.$window;                      // should the class be saved on the window global object
		var $shortcut  = $proto.$shortcut;                    // shortcut function (instead of using "new Class()")
		var $utils     = $proto.$utils;                       // add a shortcut function to the FFTO.Utils global
        var $uses      = _.$arr($proto.$uses);
        var $return    = $class;

		// defaults ------------------------------------------------------------
        $add($proto, 'args', _args);
        $add($proto, 'apply', _apply);
        $add($proto, 'each', _each);
        $add($proto, 'wait', _wait);
        $add($proto, 'tick', _tick);
        $add($proto, 'http', _http);
        $add($proto, 'on', _on);
        $add($proto, 'when', _when);        
        $add($proto, 'css', _css);        
        $add($proto, '$$', _$$);
        
        $add($proto, 'log', _log);
        $add($proto, 'warn', _warn);
        $add($proto, 'error', _error);        
        $add($proto, 'refresh', _refresh);
		
        $add($class, 'log', _log);
        $add($class, 'warn', _warn);
        $add($class, 'error', _error);

        if (!('state' in $proto)) $states($class);
        
        // check for necessary api/class 
        for (var i in $uses){
            var use = $uses[i];
            !API[use] && $class.error('Requires "{{ use }}" class to work properly', {'use':use});
        }

        // post inits
        // $class.$postInits.push(function (){
        //     this.refresh && this.refresh();
        // });

        // $class.$preInits && $class.$preInits.push(function (){ this[i] = v; });
        // _js($class.$postInits);
        // $postInits

        // Singleton
        if ($singleton){
            $return = new $class();
        }		

		// When the class is created, call this immediately 
		if ($proto.$onDefineClass){
			$proto.$onDefineClass.apply($class, [$return]);
		}

		// TODO other functions.... fn.tick(), http(), ...

		// static --------------------------------------------------------------
		// $class.slug = $proto.slug = _.toSlug($class.name);

		// save shortcuts access -----------------------------------------------
		if (save !== false){
			delete($proto.$shortcut);
			delete($proto.$utils);

            // TODO change the path for API and Window

			// save the $class
			API[$class.name] = $return;								// add to API the new $class
			($window !== false) && _.set(window, $path, $return);	// save a shortcut to the window
			
			// shortcut function
			if ($shortcut){
				_.set(window, $shortcut, function (){ return $class.$new(arguments); });
			}

			// shortcut function linked to utils
			if ($utils){
				_.set(_, $utils, function (){ return $class.$new(arguments); });
			}
		}

		return $return;
    };

    // "instance of" (todo)

    return Api;
}(FFTO.Utils, FFTO));
// [ ] Add option to refresh the values (with css vars). With that, we need a prefix. Eg.: to carousel element, the vars should be prefixed with "--carousel", so for data "visible" should be "--carousel-visible"

Class(function DataTypes (_){
    this.$ = {
        'ctx'   : null,
        'el'    : null,
        'values': {},
    };

    // types -----------------------------------------------------------------------------------------------------------
    var $types = this.$static.$types = {
        'String' : function (){
            return function (v){
                return v === null || v === undefined ? '' : v.toString();
            };
        },
        'Number' : function (args, obj){
			args.min     = 'min' in args ? args.min : -Infinity;
			args.max     = 'max' in args ? args.max : Infinity;
			args.modulus = 'modulus' in args ? args.modulus : 0;

            return function (v){
                v = _.dom.toPx(v, null, obj.el) || 0;
                if (args.modulus) v = v % args.modulus;
                if (v < args.min) v = args.min;
                if (v > args.max) v = args.max;
                return v;
            };
        },
        'Boolean' : function (){
            return function (v){ return !!v; };
        },
        'Array' : function (args){
            args.separator = 'separator' in args ? args.separator : ',';
            return function (v){
                v = _.toArray(v, {'separator':args.separator, 'parse':true});
                return v;
            };
        },
        'Object' : function (args){
            args.defaults = 'defaults' in args ? args.defaults : null;
            return function (v){
                v = _.is.str(v) ? _.toJson(v) : v;
                v = _.is.obj(v) ? v : {};
                v = args.defaults ? _.extend(true, {}, args.default, v) : v;
                return v;
            };
        },
        'Function':function (args, obj){
            return function (v){
                // check if it's a string AND if it exists in the current context OR the window object
                v = _.is.str(v) ? obj.ctx && obj.ctx[v] || window[v] : v;
                return _.is.fn(v) ? v : _.fn.empty;
            }
		},
        'Value2' : function (args){
            return function (v){ 
                return _.to4Values(v, ':value', true); 
            };
        },
        'Value4' : function (args){
            return function (v){ 
                return _.to4Values(v, ':value'); 
            };
        },
        'Number2' : function (args){
            return function (v){ 
                // TODO need 0 by default
                return _.to4Values(v, ':number', true); 
            };
        },
        'Number4' : function (args){
            return function (v){ 
                return _.to4Values(v, ':number'); 
            };
        },
    };

    // init ------------------------------------------------------------------------------------------------------------
    this.init = function (types, args){
        this.args(args);
        
        function $get (v){ return v; };
        function $set (v){ return v; };

        // TODO have a way to change the "this" where all the get/set will be attached to

        this.each(types, function (v, i){
            // TODO add error for checking if the type couldn't be found

            var type   = (v.type || '');
            var getset = $types[type] ? $types[type](v, this) : {};
            var getter = getset.get ? getset.get : $get;
            var setter = getset.set ? getset.set : (typeof getset === 'function' ? getset : $set);
            
            _.obj.prop(this, i, function get (){
                return getter(this.values[i]);
            }, function set (vv){                
                // "nullable" option
                if (!_.is.valid(vv) && v.nullable){
                    this.values[i] = null;
                }else{
                    this.values[i] = setter(vv);
                }
            });

            // set the default
            this[i] = i in this.values ? this.values[i] : v.default;
        });

        // go through the values to set them (doing it separately helps with custom/new values)
        for (var i in this.values){
            this[i] = this.values[i];
        }
    };

    // methods ---------------------------------------------------------------------------------------------------------
    this.get = function (key){
        return key ? this.values[key] : this.values;
    };

    this.set = function (key, value){
        // TODO throw error if using reserved keys: get, set, values, ctx, el
        if (_.is.obj(key)){
            for (var i in key){
                this[i] = key[i];
            }
        }else{
            this[key] = value;
        }
        return this;
    };
});
Class(function Easing (_){
    // init --------------------------------------------------------------------
    this.$onDefineClass = function (self){
        // Add a shortcut to FFTO.Utils (instead of using "this.$utils")
        _.easing = function (){ return self.get.apply(self, arguments); }; 
        _.ease   = function (){ return self.set.apply(self, arguments); }; 
    };

    this.init = function (name, args){
        // TODO add new Easing functions
    };

    // private -----------------------------------------------------------------
    function toSteps (nbr){
        return function (t){ 
            return Math.floor(t * nbr) / nbr; 
        };
    }

    function toBezier (p1, p2, p3, p4){
        // defining the bezier functions in the polynomial form
        var Cx = 3 * p1;
        var Bx = 3 * (p3 - p1) - Cx;
        var Ax = 1 - Cx - Bx;

        var Cy = 3 * p2;
        var By = 3 * (p4 - p2) - Cy;
        var Ay = 1 - Cy - By;

        function _x(t) {
            return t * (Cx + t * (Bx + t * Ax));
        }
        function _y(t) {
            return t * (Cy + t * (By + t * Ay));
        }

        // using Newton's method to aproximate the parametric value of x for t
        function _xDer(t) {
            return Cx + t * (2*Bx + 3*Ax * t);
        }

        function _xFor(t) {
            var x=t, i=0, z;

            while (i < 5) { // making 5 iterations max
                z = _x(x) - t;

                if (Math.abs(z) < 1e-3) break; // if already got close enough

                x = x - z/_xDer(x);
                i++;
            }

            return x;
        }

        return function(t) {
            return _y(_xFor(t));
        };
    };

    function toBounce (bounces, threshold){
        // @source https://medium.com/hackernoon/the-bounce-factory-3498de1e5262#.5t0mzua5k
        threshold = threshold || 0.001; 

        function _energyToHeight (energy) {
            return energy; // h = E/mg, Eqn. 4
        }
    
        function _heightToEnergy (height) {
            return height; // E = mgh, Eqn. 4
        }
    
        function _bounceTime (height) {
            // 2 x the half bounce time measured from the peak
            return 2 * Math.sqrt(2 * height);  // Modified Eqn. 7
        }
    
        function _speed (energy) {
            // E = 1/2 m v^2, s = |sqrt(2E/m)|
            return Math.sqrt(2 * energy); // Eqn. 8
        }

        var height     = 1;
        var potential  = _heightToEnergy(height);
        var elasticity = Math.pow(threshold, 1 / bounces);  // Eqn. 10

        // The critical points are the points where the object contacts the "ground"
        // Since the object is initially suspended at 1 height, this either creates an
        // exception for the following code, or you can use the following trick of placing
        // a critical point behind 0 and representing the inital position as halfway though
        // that arc.
    
        var criticalPoints = [{
            time  : - _bounceTime(height) / 2,
            energy: potential,
        },{
            time  : _bounceTime(height) / 2,
            energy: potential * elasticity,
        }];
    
        potential *= elasticity;
        height     = _energyToHeight(potential);
        
        var time = criticalPoints[1].time;
        for (var i = 1; i < bounces; i++) {
            time      += _bounceTime(height);
            potential *= elasticity;           // Eqn. 2, remove energy after each bounce
    
            criticalPoints.push({
                time  : time,
                energy: potential,
            });
    
            height = _energyToHeight(potential);
        }
    
        var duration = time; // renaming to emphasize it's the total time now

        return function (t) {
            t = _.math.clamp(t, 0, 1);
    
            var tadj = t * duration;
    
            if (tadj === 0){
                return 0;
            }else if (tadj >= duration){
                return 1;
            }
    
            // Find the bounce point we are bouncing from, for very long animations (hours, days),
            // an binary search algorithm might be appropriate.
            var index;
            for (index = 0; index < criticalPoints.length; index++){
                if (criticalPoints[index].time > tadj){
                    break;
                }
            }
    
            var bouncept = criticalPoints[index - 1];
    
            // Bouncing from a bounce point effectively resets time as it is a discontinuity
            tadj -= bouncept.time; 
    
            var v0 = _speed(bouncept.energy);
    
            // Project position of object from bounce point to the current time
            var pos = v0 * tadj + -0.5 * tadj * tadj; // Eqn. 1 
    
            return 1 - pos;
        };
    };

    function toSpring (args){
        args            = args || {};
        args.halfcycles = 'halfcycles' in args ? args.halfcycles : 20;  // accepts integers > 1
        args.damping    = 'damping' in args ? args.damping : 0.1;       // must be between 0 and 1 excluding 1,
        args.position   = 'position' in args ? args.position : 0.5;     // typically in -1..1 inclusive
        args.velocity   = 'velocity' in args ? args.velocity : 0;       // at start, how fast in either direction

        // @source https://medium.com/hackernoon/the-spring-factory-4c3d988e7129
        function _computeOmega(A, B, k, zeta) {
            // Haven't quite figured out why yet, but to ensure same behavior of
            // k when argument of arctangent is negative, need to subtract pi
            // otherwise an extra halfcycle occurs. 
            //
            // It has someting to do with -atan(-x) = atan(x),
            // the range of atan being (-pi/2, pi/2) which is a difference of pi 
            //
            // The other way to look at it is that for every integer k there is a
            // solution and the 0 point for k is arbitrary, we just want it to be
            // equal to the thing that gives us the same number of halfcycles as k.
            if (A * B < 0 && k >= 1) {
                k--;
            }
        
            return (-Math.atan(A / B) + Math.PI * k) / (2 * Math.PI * Math.sqrt(1 - zeta * zeta));
        }
              
        // Resolve recursive definition of omega an B using bisection method
        function _numericallySolveOmegaAndB(args) {
            args = args || {};
        
            var zeta = args.zeta;
            var k    = args.k;
            var y0   = _.nvl(args.y0, 1);
            var v0   = args.v0 || 0;
        
            // See https://en.wikipedia.org/wiki/Damping#Under-damping_.280_.E2.89.A4_.CE.B6_.3C_1.29
            // B and omega are recursively defined in solution. Know omega in terms of B, will numerically
            // solve for B.
        
            function _errorfn (B, omega) {
                var omega_d = omega * Math.sqrt(1 - zeta * zeta);
                return B - ((zeta * omega * y0) + v0) / omega_d;
            }
        
            var A = y0;
            var B = zeta;  // initial guess that's pretty close
            var omega, error, direction;
        
            function step () {
                omega     = _computeOmega(A, B, k, zeta);
                error     = _errorfn(B, omega);
                direction = -Math.sign(error);
            }
        
            step();
        
            var tolerence = 1e-6;
            var lower, upper;
        
            var ct    = 0;
            var maxct = 1e3;
        
            if (direction > 0) {
                while (direction > 0) {
                    ct++;

                    if (ct > maxct) break;

                    lower  = B;
                    B     *= 2;
                    step();
                }
        
                upper = B;
            } else {
                upper = B;
        
                B *= -1;
        
                while (direction < 0) {
                    ct++;
        
                    if (ct > maxct) break;
        
                    lower  = B;
                    B     *= 2;
                    step();
                }
        
                lower = B;
            }
        
            while (Math.abs(error) > tolerence) {
                ct++;
        
                if (ct > maxct) {
                    break;
                }
        
                B = (upper + lower) / 2;
                step();
        
                if (direction > 0) {
                    lower = B;
                } else {
                    upper = B;
                }
            }
        
            return {
                omega: omega,
                B    : B,
            };
        }

        var zeta = args.damping;
        var k    = args.halfcycles;
        var y0   = _.nvl(args.position, 1);
        var v0   = args.velocity || 0;
        var A    = y0;
        var B, omega;
    
        // If v0 is 0, an analytical solution exists, otherwise,
        // we need to numerically solve it.
        if (Math.abs(v0) < 1e-6) {
            B     = zeta * y0 / Math.sqrt(1 - zeta * zeta);
            omega = _computeOmega(A, B, k, zeta);
            //console.log(A, B, Math.atan(A / B), Math.atan2(A, B))
        } else {
            var result = _numericallySolveOmegaAndB({
                zeta: zeta,
                k   : k,
                y0  : y0,
                v0  : v0,
            });
    
            B     = result.B;
            omega = result.omega;
        }
    
        omega *= 2 * Math.PI;
        var omega_d = omega * Math.sqrt(1 - zeta * zeta);
    
        return function(t) {
            var sinusoid = A * Math.cos(omega_d * t) + B * Math.sin(omega_d * t);
            return Math.exp(-t * zeta * omega) * sinusoid;
        };        
    };

    // static ------------------------------------------------------------------
    var $static = this.$static;

    this.$static.js             = {};
    this.$static.js.linear      = function(t) { return t };
    this.$static.js.ease        = toBezier(0.25, 0.1, 0.25, 1.0);
    this.$static.js.inEase      = toBezier(0.42, 0.0, 1.0, 1.0);
    this.$static.js.outEase     = toBezier(0.0, 0.0, 0.58, 1.0);
    this.$static.js.inOutEase   = toBezier(0.42, 0.0, 0.58, 1.0);

    this.$static.js.swing       = toBezier(0.02, 0.01, 0.47, 1);
    this.$static.js.square      = function(t){ return Math.sqrt(t); };
    this.$static.js.spring      = function(t){ return 1 - (Math.cos(t * 4.5 * Math.PI) * Math.exp(-t * 6)); };

    this.$static.js.inQuad 		= function(t) { return t * t };
    this.$static.js.outQuad 	= function(t) { return t * (2 - t) };
    this.$static.js.inOutQuad 	= function(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t };
    this.$static.js.inCubic 	= function(t) { return t * t * t };
    this.$static.js.outCubic 	= function(t) { return (--t) * t * t + 1 };
    this.$static.js.inOutCubic 	= function(t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 };
    this.$static.js.inQuart 	= function(t) { return t * t * t * t };
    this.$static.js.outQuart 	= function(t) { return 1 - (--t) * t * t * t };
    this.$static.js.inOutQuart 	= function(t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t };
    this.$static.js.inQuint 	= function(t) { return t * t * t * t * t };
    this.$static.js.outQuint 	= function(t) { return 1 + (--t) * t * t * t * t };
    this.$static.js.inOutQuint 	= function(t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t };
    this.$static.js.inSine 		= function(t) { return -1 * Math.cos(t / 1 * (Math.PI * 0.5)) + 1; };
    this.$static.js.outSine 	= function(t) { return Math.sin(t / 1 * (Math.PI * 0.5)); };
    this.$static.js.inOutSine 	= function(t) { return -1 / 2 * (Math.cos(Math.PI * t) - 1); };
    this.$static.js.inExpo 		= function(t) { return (t == 0) ? 0 : Math.pow(2, 10 * (t - 1)); };
    this.$static.js.outExpo 	= function(t) { return (t == 1) ? 1 : (-Math.pow(2, -10 * t) + 1); };
    this.$static.js.inOutExpo 	= function(t) {
        if (t == 0) return 0;
        if (t == 1) return 1;
        if ((t /= 1 / 2) < 1) return 1 / 2 * Math.pow(2, 10 * (t - 1));
        return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);
    };
    this.$static.js.inCirc 		= function(t) { return -1 * (Math.sqrt(1 - t * t) - 1); };
    this.$static.js.outCirc 	= function(t) { return Math.sqrt(1 - (t = t - 1) * t); };
    this.$static.js.inOutCirc 	= function(t) {
        if ((t /= 1 / 2) < 1) return -1 / 2 * (Math.sqrt(1 - t * t) - 1);
        return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    };
    this.$static.js.inBack 		= function(t, s) {
        if (s == undefined) s = 1.70158;
        return 1 * t * t * ((s + 1) * t - s);
    };
    this.$static.js.outBack 	= function(t, s) {
        if (s == undefined) s = 1.70158;
        return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);
    };
    this.$static.js.inOutBack 	= function(t, s) {
        if (s == undefined) s = 1.70158;
        if ((t /= 1 / 2) < 1) return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));
        return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
    };
    this.$static.js.inBounce 	= function(t) {
        return 1 - $static.js.outBounce(1 - t);
    };
    this.$static.js.outBounce 	= function(t) {
        if ((t /= 1) < (1 / 2.75))  return (7.5625 * t * t);
        else if (t < (2 / 2.75))    return (7.5625 * (t -= (1.5 / 2.75)) * t + .75);
        else if (t < (2.5 / 2.75))  return (7.5625 * (t -= (2.25 / 2.75)) * t + .9375);
        else                        return (7.5625 * (t -= (2.625 / 2.75)) * t + .984375);
    };
    this.$static.js.inOutBounce = function(t) {
        if (t < 1 / 2)  return $static.js.inBounce(t * 2) * 0.5;
        else            return $static.js.outBounce(t * 2 - 1) * 0.5 + 0.5;
    };
    this.$static.js.inElastic 	= function(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;
        if (t == 0) return 0;
        if (t == 1) return 1;
        if (!p) p = 0.3;
        if (a < 1) {
            a = 1;
            var s = p / 4;
        } else var s = p / (2 * Math.PI) * Math.asin(1 / a);
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
    };
    this.$static.js.outElastic 	= function(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;
        if (t == 0) return 0;
        if (t == 1) return 1;
        if (!p) p = 0.3;
        if (a < 1) {
            a = 1;
            var s = p / 4;
        } else var s = p / (2 * Math.PI) * Math.asin(1 / a);
        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
    };
    this.$static.js.inOutElastic = function(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;
        if (t == 0) return 0;
        if ((t /= 1 / 2) == 2) return 1;
        if (!p) p = (0.3 * 1.5);
        if (a < 1) {
            a = 1;
            var s = p / 4;
        } else var s = p / (2 * Math.PI) * Math.asin(1 / a);
        if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
    };

    this.$static.css 			= {};
    this.$static.css.swing 		= [0.02, 0.01, 0.47, 1];
    this.$static.css.ease       = [0.25, 0.1, 0.25, 1.0];
    this.$static.css.inEase     = [0.42, 0.0, 1.0, 1.0];
    this.$static.css.outEase    = [0.0, 0.0, 0.58, 1.0];
    this.$static.css.inOutEase  = [0.42, 0.0, 0.58, 1.0];

    this.$static.css.inQuad    	= [0.550, 0.085, 0.680, 0.530];
    this.$static.css.outQuad   	= [0.250, 0.460, 0.450, 0.940];
    this.$static.css.inOutQuad 	= [0.455, 0.030, 0.515, 0.955];
    this.$static.css.inCubic    = [0.550, 0.055, 0.675, 0.190];
    this.$static.css.outCubic   = [0.215, 0.610, 0.355, 1.000];
    this.$static.css.inOutCubic	= [0.645, 0.045, 0.355, 1.000];
    this.$static.css.inQuart    = [0.895, 0.030, 0.685, 0.220];
    this.$static.css.outQuart  	= [0.165, 0.840, 0.440, 1.000];
    this.$static.css.inOutQuart = [0.770, 0.000, 0.175, 1.000];
    this.$static.css.inQuint    = [0.755, 0.050, 0.855, 0.060];
    this.$static.css.outQuint	= [0.230, 1.000, 0.320, 1.000];
    this.$static.css.inOutQuint	= [0.860, 0.000, 0.070, 1.000];
    this.$static.css.inSine		= [0.470, 0.000, 0.745, 0.715];
    this.$static.css.outSine	= [0.390, 0.575, 0.565, 1.000];
    this.$static.css.inOutSine	= [0.445, 0.050, 0.550, 0.950];
    this.$static.css.inExpo		= [0.950, 0.050, 0.795, 0.035];
    this.$static.css.outExpo	= [0.190, 1.000, 0.220, 1.000];
    this.$static.css.inOutExpo	= [1.000, 0.000, 0.000, 1.000];
    this.$static.css.inCirc		= [0.600, 0.040, 0.980, 0.335];
    this.$static.css.outCirc	= [0.075, 0.820, 0.165, 1.000];
    this.$static.css.inOutCirc	= [0.785, 0.135, 0.150, 0.860];
    this.$static.css.inBack		= [0.600, -0.280, 0.735, 0.045];
    this.$static.css.outBack	= [0.175, 0.885, 0.320, 1.275];
    this.$static.css.inOutBack	= [0.680, -0.550, 0.265, 1.550];
    this.$static.css.inOutBounce= [0.3, -1, 0.7, 2];

    this.$static.get = function (key, isCss){
        // shortcut
        if (_.is.str(key, 'css:')){
            key   = key.replace('css:', '');
            key   = _.is.nbr(key, true) ? parseFloat(key) : key;
            isCss = true;
        }

        var easing = null;
        var key2   = key;
        
        // standerize the key to have the "in" and "out" as prefix
        if (_.is.str(key2)){
            var isIn  = false;
            var isOut = false;
            key2 = key2.replace(/^in|In|-in/, function (){ isIn = true; return '';});
            key2 = key2.replace(/^out|Out|-out/, function (){ isOut = true; return '';});
            key2 = (isIn?'in-':'') + (isOut?'out-':'') + key2;
            key2 = _.toSlug(key2, 'camel');  
        }

        if (isCss){
            easing = 'linear';
            if (key instanceof Array){
                easing = 'cubic-bezier('+key+')';
            }else if (key2 in this.css){
                easing = 'cubic-bezier('+this.css[key2]+')';
            }else if (_.is.nbr(key)){
                easing = 'steps('+(key|0)+', end)';
            }else if (_.is.str(key)){
                easing = key;
            }
        }else if (key instanceof Array){
            easing = toBezier.apply(null, key);
        }else if (key2 in this.js){
            easing = this.js[key2];
        }else if (_.is.nbr(key)){
            easing = toSteps(key);
        }else{
            easing = this.js.linear;
        }

        // TODO add "spring" and "bounce"
            
        // }else if (utils.is.str(easing) && easing.indexOf('cubic-bezier(') === 0){
        //     var bezier = utils.string.match(easing, RE.EASING_CUBIC_BEZIER, true) || [0,0,1,1];
        //     bezier = utils.toValues(bezier);
        //     easing = utils.easing.toBezier.apply(null, bezier);
        // }else if (utils.is.str(easing) && easing.indexOf('steps(') === 0){
        //     // @todo do the jumpterm (https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function)
        //     var steps = utils.string.match(easing, RE.EASING_STEPS, true) || 1;
        //     steps  = utils.toValues(steps);
        //     easing = function (r){ return Math.floor(r * steps[0]) / steps[0]; };
        // }else if (!utils.is.fn(easing)){
        //     easing = utils.easing.js.linear;
        // }

        return easing;
    };

    this.$static.set = function (key, value){
        var e = this.get(key);
        return e(value);
    };

    this.$static.names = function (isCss){
        var list = isCss ? this.css : this.js;
        return utils.each(list, '$id');
    };

    // method ------------------------------------------------------------------
    
});

/*
var easings = { 
    inQuad 		: function(t) { return t * t },
    outQuad 	: function(t) { return t * (2 - t) },
    inOutQuad 	: function(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
    inCubic 	: function(t) { return t * t * t },
    outCubic 	: function(t) { return (--t) * t * t + 1 },
    inOutCubic 	: function(t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
    inQuart 	: function(t) { return t * t * t * t },
    outQuart 	: function(t) { return 1 - (--t) * t * t * t },
    inOutQuart 	: function(t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
    inQuint 	: function(t) { return t * t * t * t * t },
    outQuint 	: function(t) { return 1 + (--t) * t * t * t * t },
    inOutQuint 	: function(t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t },
    inSine 		: function(t) { return -1 * Math.cos(t / 1 * (Math.PI * 0.5)) + 1; },
    outSine 	: function(t) { return Math.sin(t / 1 * (Math.PI * 0.5)); },
    inOutSine 	: function(t) { return -1 / 2 * (Math.cos(Math.PI * t) - 1); },
    inExpo 		: function(t) { return (t == 0) ? 0 : Math.pow(2, 10 * (t - 1)); },
    outExpo 	: function(t) { return (t == 1) ? 1 : (-Math.pow(2, -10 * t) + 1); },
};
*/
// [ ] need to deal with margin overflow for objects...
// [ ] Deal with classname change when using css transition/animation
// [ ] Deal with forced properties (like padding, margin, ...)
// [ ] pass attributes to calculate and animate
// [ ] inline values... might be buggy on calculate(), sometimes the end value is not there...
// [ ] Deal with custom animation function (animate would a function instead)
// [ ] be able to cancel ALL Transitions
// [ ] add an "attribute" in the HTML like (transition), so it's automatic. Maybe a new Web.Element(function ElementsTransition(){}). Something like transition-click="{class}", transition-hover="{class}"
// [x] when removing, ... save the parent it was with... and the position it was at, so when removing, it stay where it was...
// [ ] add different "props" animation depending on the state: moving, adding, removing. Add conditions like: props, removeProps, addProps....
// [x] Deal with delaying the transition process
// [x] make Delay works
// [ ] add a dummy block when removing an element OR moving it to another parent. Changing from 1 section to another for example
// [ ] if the item is hidden/remove/added/appears, deal with opacity and other type of entry/hide values
// [ ] option to have a dummy placeholder that will resize the content, then disseapear and be replaced with the element
// [ ] add easing
// [ ] add function animation
// [ ] Deal with scroll, when transition calculate changes the scroll position

/**
 * @class Transition
 */
Class(function Transition (_){
    this.$utils = 'dom.transition';

    // contants --------------------------------------------------------------------------------------------------------
    var PROPS = [
        'backgroundColor','color','boxShadow','opacity',
        'paddingTop','paddingRight','paddingBottom','paddingLeft',
        'marginTop','marginRight','marginBottom','marginLeft',
        'border','borderRadius',
    ];

    // properties ------------------------------------------------------------------------------------------------------
    this.$ = {
        'el'           : null,
        'ctx'          : false,
        'easing'       : false,
        'duration'     : 0,
        'time'         : 0,       // the string version fo the durations
        'delay'        : 0,
        'props'        : PROPS,
        
        'isClosed'     : false,     // state for <dialog> and <details>
        'isHidden'     : false,     // When the element is turned hidden (display:none/hidden/visibility:hidden)
        'isShown'      : false,     // When the element was hidden 
        'isAdded'      : false,     // Element is added to the Dom
        'isRemoved'    : false,     // Element is removed from the dom
        'hasChanged'   : false,
        'hasSaved'     : false,
        'hasCalculated': false,
    };

    this.style       = {'from':null, 'to':null};
    this.bounds      = {'from':{}, 'to':{}};
    this.update      = {'from':{}, 'to':{}, 'clean':{}, 'inline':{}};
    this.parent      = null;
    this.index       = null;
    this.onCalculate = null;
    this.onAnimate   = null;
    this.onDone      = null;
    this.timeout     = {};

    // init ------------------------------------------------------------------------------------------------------------
    this.init = function (selector, args, duration, calculate){
        if (_.is.fn(duration)){
            calculate = duration;
            duration  = null;
        }

        if (_.is.nbr(args)){
			args = {'duration':args};
        }else if (_.is.either(args, 'str,arr')){
            args = {'props':args};
		}else if (_.is.fn(args)){
			args = {'calculate':args};
		}

		args             = args || {};
        args.animate     = 'animate' in args ? args.animate : true;

        if (_.is.bool(calculate)){
            args.animate = calculate;
        }

		this.el          = selector;
		this.easing      = args.easing || null;
		this.duration    = 'duration' in args ? args.duration : (_.is.either(duration,'str,nbr') ? duration : 300);
		this.delay       = 'delay' in args ? args.delay : 0;
        this.props       = 'props' in args ? args.props : this.props;

		this.ctx         = args.ctx || this.el;
		this.onCalculate = args.change || args.calculate || calculate || null;
		this.onAnimate   = args.animate || null;
		this.onDone      = args.done || null;
        this.isAdded     = args.isAdded || false;
        
        if (args.animate && this.onCalculate){
            this.save();
            this.calculate();
            this.animate();        
        }
    };

    // private ---------------------------------------------------------------------------------------------------------
    this._apply = function (callback, params, fallback){
        return _.apply.ctx(this.ctx, callback, params, {'fallback':fallback});
    };

    this._style = function (style){
        if (style){
            _.dom.style(this.el, style, true);
        }else{
            return _.dom.style(this.el);
        }
    };

    this._bounds = function (){
        return _.dom.bounds(this.el);
    };

    this._clean = function (){
        _.cancel(this.timeout.animate);
        _.cancel(this.timeout.clean);

        // clean stuff
        this._style(this.update.clean);
        this._style(this.update.inline);

        // remove transition attrs
        _.dom.attrs(this.el, 'transitioning', false);

        // reset the proper states/styles
        if (this.isClosed){
            this.el.open = false;
        }

        // TODO can't set display=none, if it's not set as an inline style
        if (this.isHidden){
            // this.el.style.display = 'none';
        }
        if (this.isRemoved){
            _.dom.remove(this.el);
        }

        // reset 
        this.hasSaved      = false;
        this.hasCalculated = false;
    };

    // static ----------------------------------------------------------------------------------------------------------
    this.$static.toProps = function (v){
        v = v instanceof Array ? v : _.each(v);
        
        if (~v.indexOf('*')){
            v = v.concat(PROPS);
        }
        if (~v.indexOf(':size')){
			v.push('width','height');
		}
		if (~v.indexOf(':move')){
			v.push('dx','dy');
		}
        
        return v;
    };

    // get/set ---------------------------------------------------------------------------------------------------------
    this.$set.el = function (v){
        this.$.el = _.dom.get(v);
    };
    
    this.$set.duration = function (v){
        this.$.duration = _.toDuration(v);
        this.$.time     = _.nbr.toDuration(this.$.duration);
    };

    this.$set.time = function (){
        // nothing
    };

    this.$set.delay = function (v){
        this.$.delay = _.toDuration(v);
    };

    this.$set.props = function (v){
        this.$.props = this.$static.toProps(v);
    };

    // methods ---------------------------------------------------------------------------------------------------------
    this.save = function (){
        this.parent      = this.el.parentNode;
        this.index       = _.dom.index(this.el);
        
        // temporarily remove the newly added element
        this.isAdded && _.dom.remove(this.el);

        this.style.from  = this._style();
        this.bounds.from = this._bounds();

        // re-add the element if it's been removed
        this.isAdded && _.dom.add(this.el, this.index, this.parent);

        this.stop();

        this.hasSaved      = true;
        this.hasCalculated = false;

        return this;
    };
    
    this.calculate = function (args, inverse){
        if (!this.hasSaved) this.save();

        if (_.is.fn(args)){
            args = {'callback':args};
        }

        args          = args || {};
        args.callback = args.callback || this.onCalculate;
        var props     = args.props ? this.$static.toProps(args.props) : this.props;
        
        // start ---------------------------------------------------------------
        this.el.style.transition = 'none'; // stop any transition
        
        var inlineFrom = this.el.style.cssText.split('; ');
        props = this._apply(args.callback, [this.el, this], props); // do the calculation (if set)
        var inlineTo   = this.el.style.cssText.split('; ');

        // no duration = go the to end of the transition right away
        if (!this.duration) return;

        // get the new to info
        this.style.to  = this._style();
        this.bounds.to = this._bounds();

        var style  = this.style;
        var update = this.update;

        // Opacity change
        var isRemoved  = !this.el.isConnected;
        var wasVisible = style.from.display !== 'none' && style.from.visibility !== 'hidden' && !this.isAdded;
        var isVisible  = style.to.display !== 'none' && style.to.visibility !== 'hidden' && !isRemoved;
        if (wasVisible !== isVisible){
            isVisible && (style.from.opacity = 0);
            wasVisible && (style.to.opacity = 0);
        }
        
        // inline styles -------------------------------------------------------
        var from = _.each(inlineFrom, function (v){
            v = v.split(': ');
            return {
                '$id'   : v[0],
                '$value': v[1],
            };
        });
                
        _.each(inlineTo, function (v, i){
            v = v.split(': ');
            i = v[0];
            v = v[1];

            if (from[i] == v || i === 'transition') return null;

            i = _.toSlug(i, 'camel');

            update.inline[i] = v;
        });

        // style changes -------------------------------------------------------
        var from = style.from;
        var to   = style.to;

        var i, f, t;
        for (i in from){
            if (!~props.indexOf(i)) continue;

            f = from[i];
            t = to[i];

            if (f !== t){
                update.from[i]  = f;
                update.to[i]    = t;
                update.clean[i] = '';
            }
        }

        // bounds change -------------------------------------------------------
        var from = this.bounds.from.bbox;
        var to   = this.bounds.to.bbox;

        if (from.width !== to.width && ~props.indexOf('width')){
            update.from.width    = from.width;
            update.to.width      = to.width;
            update.from.overflow = 'hidden';
        }
        if (from.height !== to.height && ~props.indexOf('height')){
            update.from.height   = from.height;
            update.to.height     = to.height;
            update.from.overflow = 'hidden';
        }

        // transalte x/y
        var dx = 0;
        var dy = 0;
        var t  = style.to.transform !== 'none' ? style.to.transform + ' ' : '';
        if (from.x !== to.x && ~props.indexOf('dx')){
            dx = from.x - to.x + 'px';
        }
        if (from.y !== to.y && ~props.indexOf('dy')){
            dy = from.y - to.y + 'px';
        }
        if (dx || dy){
            update.from.transform  = t + 'translate('+[dx,dy]+')';
            update.to.transform    = t + 'translate(0,0)';
            update.clean.transform = update.clean.transform ? update.clean.transform : t;  // deal with inline transform
        }
                
        // save the clean function if another transition interrupt this current one
		this.el.$transition = this._clean.bind(this);

        // TODO check if there's difference, if none, set the duration to 0

        // calculate last properties -------------------------------------------
        var props = [];
            
        // find the prop keys to transition
        for (var i in update.from){
            i = _.toSlug(i);
            props.push(i);
        }

        this.hasChanged = props.length > 0;

        update.to['transitionProperty']       = props.join(', ');
        update.to['transitionDuration']       = this.$.time;
        update.to['transitionTimingFunction'] = _.easing(this.easing, true);
        update.clean['overflow']        = '';
        update.clean['display']         = '';
        update.clean['transition']      = '';
 
        // step done
        this.hasCalculated = true;

        // inverse
        (inverse !== false) && this.inverse();

        return this;
    };

    this.inverse = function (){
        if (!this.hasChanged) return;

        // set the from style
        this._style(this.update.from);

        // make sure the element is visible (and in the DOM)
        var tag = _.dom.tag(this.el);
        if (tag === 'details' || tag === 'dialog'){
            this.isClosed = !this.el.open;
            this.el.open  = true;
        }
        if (!this.el.isConnected){
            this.isRemoved = true;
            _.dom.add(this.el, this.index, this.parent); // re-add the item in the DOM
        }
        if (!_.dom.visible(this.el)){
            this.isHidden = true;
            this.el.style.display = this.style.from.display || this.style.to.display || 'block';
        }
        
        _.dom.attrs(this.el, 'transitioning', true);

        // reflow
        this.el.offsetHeight; 
    };

    this.animate = function (args){
        var self = this;

        if (!this.hasSaved)      this.save();
        if (!this.hasCalculated) this.calculate();
        if (!this.hasChanged)    return this._clean();

        if (_.is.fn(args)){
            this.onAnimate = args;
        }

        function _done (){
            self._apply(self.onDone, [self.el]);
            self._clean();
        }

        if (_.is.fn(this.onAnimate)){
            this.timeout.animate = this.apply(self.onAnimate, [this.el, this.update, _done]);
        }else{
            this.timeout.animate = _.fn.wait(this.delay || true, function (){
                self._style(self.update.to);
            });
            this.timeout.clean = setTimeout(_done, this.delay + this.duration);
        }

        return this;
    };

    this.done = function (callback){
        if (_.is.fn(callback)){
            this.onDone = callback;
        }
        return this;
    };

    this.stop = function (){
        // cancel transition
        if (this.el.$transition){
            this.el.$transition();

            // TODO maybe use _.cancel()

            delete(this.el.$transition);
        }
        return this;
    };
});

/**
 * @class TransitionGroup
 */
Class(function TransitionGroup (_){
    this.$utils = 'dom.transitionGroup';

    // properties ------------------------------------------------------------------------------------------------------
    this.$ = {
        'els'          : null,
        'delegate'     : null,
        'ctx'          : false,
        'easing'       : false,
        'duration'     : 0,
        'props'        : null,

        // 'delay'        : 0,
        // 'isClosed'     : false,
        // 'isHidden'     : false,
        // 'isRemoved'    : false,

        'hasSaved'     : false,
        'hasCalculated': false,
    };

    this.nodes       = [];
    this.transitions = null;
    this.onCalculate = null;
    this.onAnimate   = null;
    this.onDone      = null;
    this.timeout     = {};

    // init ------------------------------------------------------------------------------------------------------------
    this.init = function (els, args, calculate){
        if (_.is.either(args, 'str,nbr')){
			args = {'duration':args};
		}else if (_.is.fn(args)){
			args = {'calculate':args};
		}

		args             = args  || {};
		args.animate     = 'animate' in args ? args.animate : true;
        
        if (_.is.bool(calculate)){
            args.animate = calculate;
        }
        
        this.els         = els;
		this.ctx         = args.ctx || null;
        this.delegate    = args.delegate || null;
		this.onCalculate = args.calculate || calculate || null;
		this.onAnimate   = args.animate || null;
		this.onDone      = args.done || null;
        this.props       = args.props;

        if (args.animate && this.onCalculate){            
            this.save();
            this.calculate();
            this.animate();        
        }
    };

    // private ---------------------------------------------------------------------------------------------------------
    this._apply = function (callback, params){
        return _.apply.ctx(this.ctx, callback, params);
    };

    this._fetch = function (start){
        // get the elements
        var nodes       = start ? [] : this.nodes;
        var transitions = start ? [] : this.transitions;
        var all         = [];

        // find the elements
        this.each(this.els, function (el){
            var els = this.delegate ? _.dom.get.all(this.delegate, {'ctx':el}) : [el]; 
            all = all.concat(els);
        });

        // find the added
        var added = [];
        this.each(all, function (el){
            if (!!~nodes.indexOf(el)) return;
            added.push(el);
            // add the transition
            var t = new Transition(el, {'isAdded':!start}).save();
            transitions.push(t);
        });

        this.nodes       = nodes.concat(added);
        this.transitions = transitions;
    };

    // get/set ---------------------------------------------------------------------------------------------------------
    this.$set.els = function (v){
        this.$.els = _.dom.get.all(v);
    };

    // method ----------------------------------------------------------------------------------------------------------
    this.save = function (){
        this.hasSaved      = true;
        this.hasCalculated = false;
        
        // this._fetch(true); // save things
    };

    this.calculate = function (callback){
        if (!this.hasSaved) this.save();
        this.hasCalculated = true;

        if (_.is.fn(callback)) this.onCalculate = callback;
        
        this._fetch(true); // fetch and save transition

        // // save the current state
        // this.each(this.transitions, function (t){
        //     t.save();
        // });

        // do the main calculate
        this._apply(this.onCalculate, [this.nodes, this]);

        // refetch, to check if there's new nodes
        this._fetch();

        // calculate each nodes
        this.each(this.nodes, function (el){
            this._apply(this.onCalculateEach, [el, this]);
        });

        // calculate the transition
        this.each(this.transitions, function (t){
            t.calculate({
                'props' : this.props,
            }, false);
        });        
        
        // inverse everything, but only after eveything is calculated
        this.each(this.transitions, function (t){
            t.inverse();
        });
    };

    this.animate = function (args){
        var self = this;

        if (!this.hasSaved)      this.save();
        if (!this.hasCalculated) this.calculate();

        // animate
        this.each(this.transitions, function (t){
            t.animate();
        });

        // TODO done
    };

    this.done = function (callback){
        if (_.is.fn(callback)){
            this.onDone = callback;
        }
        return this;
    };

    this.stop = function (){
        this.each(this.transitions, function (v){
            v.stop();
        });
        return this;
    };
});
Class(function Query (_){
    this.$extend   = Array;
    this.$shortcut = '$$';  // TODO add also $query()
    this.$utils    = '$$';
    this.$version  = 3;

    this.$ = {
        'ctx'  : null,
        'alias': '',
    };

    // init --------------------------------------------------------------------
    this.init = function (selector, args, callback, ctx, alias){
        // Default alias
        if (_.is.str(args)){
            args = {'alias':args};
        }else if (_.is.fn(args)){
            callback = args;
            args     = {};
        }

        args       = args || {};
        this.ctx   = args.ctx || ctx || null;
        this.alias = args.alias || alias || '';
        
        this.add(false, selector, callback);

        // save the query to the element 
        // if (_.is.el(selector)){
        //     this.save();
        // }
    };

    this.$onStateChange = function (i, v, o){
        i = _.toSlug(i);
        this.els(function (el){
            if (v === false){
                el.removeAttribute(i);
            }else{
                el.setAttribute(i, v);
            }
        });
    };

    // private -----------------------------------------------------------------
    this._selector = function (selector, args){
        return _.toAlias(selector, this.alias, args);
    };

    this._create = function (items, args){
        items = items === undefined ? this : items;
        args  = args || {};

        if (_.is.fn(items)){
            var callback = items;
            var items    = this;
            var all      = [];
            
            _.$arr(items, {'ctx':this}, function (el, i){
                var r = callback.apply(this, [el, i]);
                if (r instanceof Array) all = all.concat(r);
                else if (r)             all.push(r);
            });

            items = all;
        }else{
            items = _.$arr(items);
        }

        return new this.$static(items, {
            'ctx'  : 'ctx' in args ? args.ctx: this.ctx,
            'alias': 'alias' in args ? args.alias: this.alias,
        });
    };
    
    this._el = function (node, strict){
        return strict === false || _.is.el(node);
    };

    this._is = function (el, selector, isStrict){
        if (selector instanceof this.$static){
            selector = selector[0];
        }
        return (!selector && !isStrict) || (selector && _.dom.is(el, selector)) ? el : undefined;
    };    

    this._set = function (callback, key, value, params, onlyElements){
        var set = _.toSet(key, value);
        var el  = null;

        if (set){
            return this.each({'onlyElements':onlyElements}, function (el){ 
                callback.apply(this, [el, set].concat(params)); 
            });
        }else if (el = this[0]){
            if (this._el(el, onlyElements)){
                return callback.apply(this, [el, key, undefined].concat(params)); 
            }
            return null;
        }else{
            return key !== undefined || value !== undefined ? undefined : {};
        }
    };

    this._call = function (callback, setValues, params, fallback){
        params   = params || [];
        fallback = fallback !== undefined ? fallback : null;

        var el = null;
        if (setValues){
            return this.each(function (el){ 
                callback.apply(this, [el].concat(params)); 
            });
        }else if (el = this[0]){
            if (this._el(el)){
                return callback.apply(this, [el].concat(params));
            }
            return fallback;
        }else{
            return fallback;
        }
    };
    
    this._frag = function (els, isClone, list){
        var frag = document.createDocumentFragment();
        var i=0, l=els.length, el;
        
        for(;i<l;++i){
            el = isClone ? els[i].cloneNode(true) : els[i];
            frag.appendChild(el);
            (list instanceof Array) && list.push(el);
        }

        return frag;
    }

    this._clone = function (selector, callback){
        var source = _.dom.get.all(selector);
        var self   = this;
        var els;

        this.each(function (el, i, a){
            els = self._frag(source, !a.isFirst);

            // add at a specific position (eg: replace, after, append, prepend, ...)
            if (_.is.str(callback)){
                _.dom.add(els, callback, el);
            }else{
                callback.apply(this, [el, els]);
            }
        });

        return this;
    }; 

    this._cloneTo = function (selector, callback){
        var targets = _.dom.get.all(selector);
        var clones  = [];

        var i=0, l=targets.length, el, els;
        for(;i<l;++i){
            els = this._frag(this, i !== l-1, clones);
            el  = targets[i];

            // add at a specific position (eg: replace, after, append, prepend, ...)
            if (_.is.str(callback)){
                _.dom.add(els, callback, el);
            }else{
                callback.apply(this, [els, el]);
            }
        }

        return this._create(clones);
	};

    // loops -----------------------------------------------------------------------------------------------------------
    this.each = function (callback, args){
        this.map(callback, args);
        return this;
    };

    this.els = function (callback, args){
        args              = args || {};
        args.onlyElements = true;
        this.map(callback, args);
        return this;
    };

    this.map = function (callback, args){
        // swap both callback/args
        if (_.is.fn(args)){
            callback = [args, args = callback][0];
        }
        if (_.is.bool(args)){
            args = {'query':args};
        }

        args              = args || {};
        args.ctx          = 'ctx' in args ? args.ctx : this.ctx;
        args.query        = 'query' in args ? args.query : false;
        args.onlyElements = args.onlyElements || false;

        if (!_.is.fn(callback)){
            return [];
        }

        var i=0, l=this.length, v, el;
        var items = [];
        for (;i<l;++i){
            v = el = this[i];

            // save the Node with a Query property, so we don't recreate them for no reason
            if (args.query){
                el = v.$QUERY = (v.$QUERY ? v.$QUERY : new this.$static(v, this));
            }

            // check all items OR just the HTMLElement
            if (this._el(v, args.onlyElements)){
                var a = {
                    'isFirst'  : i === 0,
                    'isLast'   : i === l-1,
                    'isBetween': !(i === 0 || i === l-1),
                    'ratio'    : i / (l-1),
                    'length'   : l,
                    'previous' : this[i - 1],
                    'next'     : this[i + 1],
                };
                v = callback.apply(args.ctx, [el, i, a]);
            }

            if (_.is(v)){
                items.push(v);
            }
        }

        return items;
    };

    // fetch -------------------------------------------------------------------
    this.add = function (isNewQuery, selector, callback){
        if (!_.is.bool(isNewQuery)){
            selector   = isNewQuery;
            isNewQuery = true;
        }

        // format the select (with the alias)
        selector = this._selector(selector);
        
        var ctx = this.ctx;
        var els = _.dom.get.all(selector, {'window':true}, function (v){
            return _.apply.ctx(ctx, callback, [v]);
        });

        if (isNewQuery){
            els = this.get().concat(els);
            els = this._create(els);
            return els;
        }else{
            var i=0, l=els.length, el;
            for (; i<l; ++i){
                el = els[i];                
                if (el && !~this.indexOf(el)){
                    this.push(el);
                }
            }
        }

        return this;
    };

    this.get = function (search){
        if (search === undefined){
            return _.$arr(this);
        // get a value of the elements
        }else if (_.is.fn(search)){
            return this.map(function (el){ return search(el); });
        }else if (_.is.nbr(search)){
            return this[search];
        }
        // TODO maybe use a string instead and use "dom.is" to get the items ...
    };

    /**
     * Create a new Query with the same nodes/elements in this instance
     * 
     * @param {*} args 
     * 
     * @returns {Query}
     */
    this.duplicate = function (args){
        return this._create(this, args);
    };

    // insert/remove ---------------------------------------------------------------------------------------------------
    this.remove = function (){
		return this.each(function (el){ _.dom.remove(el); });
	};

	this.append = function (selector){
		selector = this._selector(selector);
		return this._clone(selector, 'append');
	};

    this.appendTo = function (selector){
		selector = this._selector(selector);
		return this._cloneTo(selector, 'append');
	};

	this.wrap = function (selector){
		selector = this._selector(selector);
		return this._clone(selector, 'wrap');
	};

    // props -------------------------------------------------------------------
    this.id = function (v){
        return this.attrs('id', v);
    };

    this.tag = function (replace){
        if (replace || replace === false){
            return this._create(function (el){ return _.dom.tag(el, replace); });
        }else{
            return _.dom.tag(this[0]);
        }
    };
    
    this.attrs = this.attr = function (key, value){
        return this._set(_.dom.attrs, key, value, null, true);
    };

    this.props = this.prop = function (key, value){
        return this._set(_.dom.props, key, value, null, true);
    };

    this.data = function (key, value){
        return this._set(_.dom.data, key, value, null, true);
    };

    this.style = function (key, value){
        return this._set(_.dom.style, key, value, [true], true);
    };

    this.vars = this.var = function (key, value){
        return this._set(_.dom.vars, key, value, null, true);
    };

    this.px = function (key, args){
        return this[0] ? _.dom.toPx(key, args, this[0]) : 0;
    };

    this.html = function (html, data, args){
        args       = args || {};
        args.data  = data;
        args.alias = this.alias;
        return this._call(_.dom.html, (html && html !== true), [html, args], '');
    };

    this.update = function (args){
        args       = args || {};
        args.ctx   = 'ctx' in args ? args.ctx : this.ctx;
        args.alias = 'alias' in args ? args.alias : this.alias;
        return this.els(function (el){ _.dom.update(el, args); });
    };

    this.text = function (text, data){
        var isSet = arguments.length;
        var text  = isSet ? _.str.replace(text, data) : '';
        return this._call(function (el){
            if (isSet){
                el.innerText = text
            }else{
                return el.innerText;
            }
        }, isSet, null, '');
    };

    this.value = function (value, data){
        return this._call(_.dom.value, arguments.length, [value, data]);
    };
        
    this.values = function (key, value, args){
        return this._set(_.dom.values, key, value, null, [args]);
    };

    this.index = function (parentSelector){
        return this[0] ? _.dom.index(this[0], parentSelector) : -1;
    };

    this.cache = function (key, value){
        // TODO also save to the el the value with it's key. so it's not just in the $CACHE object
        return this._set(_.cache, key, value, null, true);
    };

    // // save the query to the nodes
    // this.save = function (){
    //     var query = this;
    //     return this.each(function (el){ el.$QUERY = query; });
    // };

    // dimensions/positions --------------------------------------------------------------------------------------------
	this.bounds = function (args){
		return _.dom.bounds(this[0], args);
	};

	this.scroll = function (args){
        if (args){
            return this._call(_.dom.scrollTo, true, [args]);
        }else{
            return this._call(_.dom.scroll, false);
        }
    };

    // classnames ------------------------------------------------------------------------------------------------------
    this.hasClass = function (classname, all){
        return _.dom.hasClass(this, classname, {
            'all'  : all,
            'alias': this.alias,
        });
    };

    /**
     * Set/get the HTMLElements classnames.
     * 
     * @param {string|array|object} classnames 
     * @param {number|string}       duration    duration until the previous classnames comes back
     * 
     * @returns {Query|array}       
     */
    this.classnames = function (classnames, duration){
        return this._call(_.dom.classnames, arguments.length, [classnames, {
            'alias'   : this.alias,
            'duration': duration,
        }], []);
    };
    
    /**
     * Add classnames to the HTMLElements
     * 
     * @param {string|array|object} classnames 
     * @param {number|string}       duration    duration until the previous classnames comes back
     * 
     * @returns {Query|array}       
     */
    this.addClass = function (classnames, duration){
        return this._call(_.dom.addClass, true, [classnames, {
            'alias'   : this.alias,
            'duration': duration
        }]);
    };

    /**
     * Remove classnames from the HTMLElements
     * 
     * @param {string|array|object} classnames 
     * @param {number|string}       duration    duration until the previous classnames comes back
     * 
     * @returns {Query|array}       
     */
    this.removeClass = function (classnames, duration){
        return this._call(_.dom.removeClass, true, [classnames, {
            'alias'   : this.alias,
            'duration': duration
        }]);
    };

    /**
     * Swicht classnames on/off on the HTMLElements
     * 
     * @param {string|array|object} classnames 
     * @param {number|string}       duration    duration until the previous classnames comes back
     * 
     * @returns {Query|array}       
     */
    this.toggleClass = function (classnames, duration){
        return this._call(_.dom.toggleClass, true, [classnames, {
            'alias'   : this.alias,
            'duration': duration
        }]);
    };

    // validation ------------------------------------------------------------------------------------------------------
    this.is = function (selector, allValid){
        selector = this._selector(selector);

        var self    = this;
        var isValid = null;
        this.each(function (el){
            var valid = self._is(el, selector);
            if (allValid && !valid){
                isValid = false;
            }else if (isValid === null && valid){
                isValid = true;
            }
        });

        return !!isValid;
    };

    this.isOverflow = function (direction){
        if (_.is.el(this[0])){
            var overflowX = this[0].scrollWidth > this[0].clientWidth;
            var overflowY = this[0].scrollHeight > this[0].clientHeight;
            return (!direction && (overflowX || overflowY))
                || ((direction === 'x' || direction === 'horizontal') && overflowX)
                || ((direction === 'y' || direction === 'vertical') && overflowY);
        }
        return false;
    };

    this.isVisible = function (allValid){
		var isValid = null;
		this.each(function (el){
			var valid = _.dom.visible(el);			
			if (allValid && !valid){
				isValid = false;
			}else if (isValid === null && valid){
				isValid = true;
			}
		});
		return !!isValid;
	};

    // events ----------------------------------------------------------------------------------------------------------
    this.on = function (name, args){
		name     = this._selector(name);
        args     = (_.is.fn(args) ? {'callback':args} : args) || {};
        args.ctx = 'ctx' in args ? args.ctx : this.ctx;

		return this.els(function (el){ _.dom.on(el, name, args); });
    };

    // fetch -----------------------------------------------------------------------------------------------------------
    this.filter = function (selector){
        selector = this._selector(selector);
        return this._create(function (el){
            return this._is(el, selector);
        });
    };
    
    this.not = function (selector){
        selector = this._selector(selector);
        return this._create(function (el){
            return this._is(el, selector) ? false : el;
        });
    };

    this.parent = function (selector){
        selector = this._selector(selector);
        return this._create(function (el){
            return this._is(el.parentNode, selector);
        });
    };

    this.parents = function (selector, untilSelector){
        selector      = this._selector(selector);
        untilSelector = this._selector(untilSelector);
        return this._create(function (el){
            return _.dom.parents(el, {
                'selector': selector,
                'until'   : untilSelector,
            });
        });
    };

    this.closest = function (selector, untilSelector){
        selector      = this._selector(selector);
        untilSelector = this._selector(untilSelector);
        return this._create(function (el){
            return _.dom.closest(el, selector, {'until':untilSelector});
        });
    };

    this.find = function (isSelf, selector){
        if (selector === undefined){
            selector = isSelf;
            isSelf   = false;
        }

        selector = this._selector(selector);
        return this._create(function (el){
            return _.dom.get.all(selector, {'ctx':el, 'self':isSelf});
        });
    };

    this.children = function (includeText, selector){
        if (!_.is.bool(includeText)){
            selector    = includeText;
            includeText = false;
        }

        selector = this._selector(selector);
        return this._create(function (el){
            return _.dom.children(el, {'text':includeText, 'selector':selector});
        });
    };

    this.siblings = function (includeText, selector){
        if (!_.is.bool(includeText)){
            selector    = includeText;
            includeText = false;
        }

        selector = this._selector(selector);
        return this._create(function (el){
            return _.dom.siblings(el, {'text':includeText, 'selector':selector});
        });
    };

    this.next = function (selector){
        selector = this._selector(selector);
        return this._create(function (el){
            return this._is(el.nextElementSibling, selector);
        });
    };

    this.nextAll = function (selector){
        selector = this._selector(selector);
        return this._create(function (el){
            return _.dom.siblings(el, {'previous':false, 'next':true, 'selector':selector});
        });
    };

    this.prev = function (selector){
        selector = this._selector(selector);
        return this._create(function (el){
            return this._is(el.previousElementSibling, selector);
        });
    };

    this.prevAll = function (selector){
        selector = this._selector(selector);
        return this._create(function (el){
            return _.dom.siblings(el, {'previous':true, 'next':false, 'selector':selector});
        });
    };

    this.eq = function (index, loop){
        if (index === 'first'){
            index = 0;
        }else if (index === 'last'){
            index = this.length - 1;
        }

        index = loop ? _.math.loop(index, this.length-1) : index;

        return this._create([this[index]]);
	};

    this.slice = function (index, count, args){
        if (_.is.bool(args)){
            args = {'clone':args};
		}
        
		args           = args || {};
		args.clone     = 'clone' in args ? args.clone : false;
		// args.indexAttr = args.indexAttr || '$index';             // TODO
        
        count = count !== undefined ? count : this.length;

		var els = _.arr.slice(this, index, count, function (el, i, ii){
            el = args.clone ? el.cloneNode(true) : el;
            return el;
        });

		return this._create(els);
	};

    this.first = function (count){
		if (count){
			return this.slice(0, count);
		}else{
			return this.eq('first');
		}
	};

	this.last = function (count){
		if (count){
			return this.slice(count * -1, Math.abs(count));
		}else{
			return this.eq('last');
		}
	};

});
// [ ] add templates
// [x] add events
// [x] add global style
// [ ] deal with singleton/single element
// [x] alias
// [ ] elements, when getting element, be able to get another Element
// [ ] add options for global element
// [x] add default elemenst with "$els" 
// [x] hidden element
// [ ] custom html 
// [x] add events
// [ ] when setting get/set, add types (like duration, ...) and the option to refresh them on some conditions
// [ ] deal with strings
// [ ] add new methods/style in the SETUP
// [ ] add $preload
// [ ] add clone
// [ ] Change the logs, to add the '#'
// [ ] add a $onHttp, so whenever this.http is called, the event will be triggered, maybe to call a refresh... OR trigger an event
// [ ] add isDebug setter, so it set a state too, is-debug = true on the element
// [ ] $tag = 
// [ ] Have a way of multiple types of prefix, x-, o-, z-, ...
// [ ] $data vs $props, data is data-, props are all the values and are set in "this.$"
// [ ] Use css has variable, for dynamic data 
// [ ] Be able to use css computed vars, to change the data (eg.: --x would change this.x for example). Use the MutationObserver (check for style and class properties) for re-render live the Element

/**
 * x-alias
 * x-family
 * x-el
 * x-els
 * x-bind
 * 
 * x-click
 * x-change
 * 
 * x-strings
 * x-clone
 */

Module(function Element (_){
    this.$log   = 'blue';  // 
    this.$tag   = null;    // to use with custom elements
    this.$els   = null;
    this.$style = null;

    this.$ = {
        'id'    : null,
        'alias' : '',
    };

    this.$states = {
        'mounted' : false,
        // 'enabled' : true,
    };

    // init --------------------------------------------------------------------
    this.preInit = function ($el, data){
        var $el   = this.$el = this.$$el = _.$$($el, {'ctx':this});
        var id    = $el.id() || _.random(this.$static.name + '_');
        var alias = $el.attr('x-alias') || this.$alias || ('element-'+this.$static.slug);

        $el.alias = alias;

        this.el    = $el.get(0);
        this.id    = id;
        this.alias = alias;

        data = _data.call(this, $el, data);
        
        _html.call(this, $el);
        _family.call(this, $el);
        _elements.call(this);
        // TODO template
        
        _bindings.call(this);
        _setup.call(this, $el);
        _css.call(this);

        // Add the genereal class
        this.addClass($el, '&');
        
        return [$el, data];
    };

    this.init = function ($el, data){
        // nothing
    };

    this.postInit = function (){
        // custom [setup] function
        this.$.setup();
        delete(this.$.setup);

        _hidden.call(this, this.$el);
        _events.call(this, this.$el);
                
        // refresh stuff
        this.cache();
        this.render();
        
        this.mounted = true;
        // this.ready   = true;
        this.$el.prop('is', this);
    };

    this.cache = function (){
        // nothing
    };

    this.render = function (){
        this.renderBindings();
    };

    this.renderBindings = function (){
        this.each(this.$.bindings, function (bind){
            bind.el.innerHTML = bind.render();
        });
    };

    this.refresh = function (){
        this.cache();
        this.render();
    };

    // private -----------------------------------------------------------------
    this._nodes = function (selector, args, callback){
        if (_.is.bool(args)){
            args = {'self':args};
        }else if (_.is.fn(args)){
            args = {'callback':args};
        }

        args          = args || {};
        args.all      = args.all || false;
        args.self     = args.self || false;
        args.callback = args.callback || callback;

        return _.dom.get.all(selector, {
            'ctx'    : this.$.family,
            'alias'  : this.alias,
            'include': args.self,
            'parent' : !args.all && ((el, isRoot) => {
                // only fetch the elements in the right parent
                if (el.x === this)  return el;
                else if (isRoot)    return false;
            }),
        }, args.callback);
    };

    function _data ($el, data){
        var data1 = this.data || {}; // TODO data set generally in "setup.js" OR Styles...
        var data2 = $el.data() || {};     
        var data  = _.extend({}, data1, data2, data || {});                           
        
        this.data = new DataTypes(this.$data, {
            'values': data,
            'ctx'   : this,
            'el'    : this.el,
        });
        
        // _js(this.slug, this.$data, data);

        return data;
    };

    function _html ($el){
        if (!this.$html) return;

        var html     = $el.html();
        var children = $el.children(true).get(); // TODO deal with children

        html = _.str.replace(this.$html, {'html':html});
        html = _.toAlias(html, this.alias);

        // TODO x-children

        $el.html(html);
    }

    function _family ($el){
        // add external family targets
        var selector = $el.attrs('x-family'); // external targets to include in the context
        var others   = _.dom.get.all(selector);
        var all      = $el.get().concat(others);

        // save the Element into the "x" prop
        this.each(all, function (v){
            if (v.x && v.x.constructor.name){
                this.warn('The node already has an "{{ type }}" linked to it', {'type':v.x.constructor.name});
            }else{
                v.x = this;
            }
        });

        this.$.family = all; // these are the main element AND the family members (other external elements)
    }
    
    function _elements (){
        var els = {};
        this._nodes('[x-el]', (el) => {
            var name  = el.getAttribute('x-el');
            var query = els[name] = els[name] || this.$$();

            query.add(false, el);
            this.addClass(el, '&--'+name);

            el.removeAttribute('x-el');
            el.setAttribute('x-name', name);
        });

        // default $els
        if (_.is.obj(this.$els)){
            for (var i in this.$els){
                if (i in els) continue; // skip already defined $els
                var v = this.$els[i];
                els[i] = this.$$(v);
            }
        }
        
        this.els = els;

        // Add the queries
        for (var i in els){
            var old = '$'+i;
            var key = '$$'+i;

            // old "$el" type of query item
            if (!(old in this)){
                this[old] = els[i];
            }

            // now, they have a double $$ prefix, to work better with the rest
            this[key] = els[i];
        }
    }

    function _bindings (){
        var self     = this;
        var bindings = [];
        this._nodes('[x-bind]', true, function (el){
            var bind     = el.getAttribute('x-bind');
            var tmpl     = '';
            var callback = '';

            // if "x-bind" is empty, then the innerHTML is the template
            if (bind){
                tmpl = bind;
            }else{
                tmpl         = el.innerHTML;
                el.innerHTML = '';
            }            

            if (~tmpl.indexOf('{{')){
                callback = function (){ return _.str.replace(tmpl, self); };
            }else{
                callback = function (){
                    var html = tmpl in self ? self[tmpl] : '';
                    if (_.is.fn(html)) html = html();
                    return html;
                };
            }

            bindings.push({
                'el'    : el,
                'render': callback,
            });
        });
        this.$.bindings = bindings;
    };

    function _setup ($el){
        // special "setup" script that can be used directly in the HTML
        var setup = $el.find('script[setup]').remove().html();

        this.$.setup = new Function('_', '\
            function ready (){}; // empty ready function \
            ' + setup + '\
            try{\
                ready.apply(this, [_]);\
            }catch(e){\
                _err(e);\
            };\
        ').bind(this, _);
    };

    function _css (){
        if (!this.$style) return;
        this.css('Element: '+this.constructor.name, this.$style);
    }

    function _events ($el){
        var els = $el.length ? $el.get() : document;
        var all = this.$.events = this.$.events || [];
        
        // add the events
        var evt = _.dom.event.decode(els, {
            'ctx'     : this,
            'alt'     : 'x-name',
            'prop'    : 'x',
            'defaults': 'x',
        }, this.__proto__);

        all.push(evt);
    }

    function _hidden (){
        this._nodes('[hidden]', true, function (el){
            var v = el.getAttribute('hidden');
            if (v == 'true' || v == 'hidden') return;
            el.removeAttribute('hidden');
        });
    }

    function _customElement (){
        // TODO https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements
        // TODO make sure the tag has a dash inside

        var tag = this.prototype.$tag;
        if (!tag) return;

        var klass = new Function('klass', `
            return class Element extends HTMLElement {
                constructor() {
                    super();
                    this.klass = new klass(this);
                }
                connectedCallback (){
                    // _js('connected', this.c);
                }
            }
        `)(this);

        customElements.define(tag, klass);
    }

    // events ----------------------------------------------------------------------------------------------------------
    this.$onSetupClass = function (ext, e){
        // data ----------------------------------------------------------------
        var $data = {};
        if (ext.$data){
            _.extend(true, $data, ext.$data);
        }

        // parse and standerize the definition $data (every props needs at least "type" and "default" attributes)
        if (e.definition.$data){
            _.$arr(e.definition.$data, function (v, i){
                var match = i.match(/([^:]+)(?:\:(.+))?/);
                var key   = match[1];
                var type  = match[2] || '';

                if (key in $data){
                    $data[key].default = v;
                }else{
                    if (type){
                        v = _.is.obj(v) ? v : {'type':type, 'default':v};
                    }else{
                        v = {'type':null, 'default':v};                        
                    }
                    $data[key] = v;
                }
            });
        }
        this.$data = $data;       
    };

    this.$onDefineClass = function (){
        _customElement.call(this);
    };

    this.$onStateChange = function (k, v, o){
        this.each(this.$.family, function (el){
            _.dom.attrs(el, k, v);
        });
    }; 

    // get/set -----------------------------------------------------------------
    this.$get.id = function (){
        return this.$.id;
    };

    this.$set.id = function (v){
        this.$.id = v;
        this.$el.id(v);
    };

    this.$get.alias = function (){
        return this.$.alias || this.$static.slug;
    };

    this.$set.alias = function (v){
        this.$.alias = _.toSlug(v);
    };

    // methods -----------------------------------------------------------------
    this.$$ = function (selector, args, callback){
        if (_.is.bool(args)){
            args = {'all':args};
        }else if (_.is.fn(args)){
            callback = null;
            args     = {'callback':args};
        }
        var els = this._nodes(selector, args, callback);
        return _.$$(els, {'ctx':this, 'alias':this.alias});
    };

    this.css = function (name, style){
        if (style === undefined){
            style = name;
            name  = '';
        }

        _.dom.css({
            'name'  : name,
            'alias' : this.alias,
        }, style);

        return this;
    };

    this.addClass = function (el, classnames){
        if (classnames === undefined){
            classnames = el;
            el         = this.$el;
        }
        _.dom.addClass(el, classnames, this.alias);
    };

    this.removeClass = function (el, classnames){
        if (classnames === undefined){
            classnames = el;
            el         = this.$el;
        }
        _.dom.removeClass(el, classnames, this.alias);
    };

    this.transition = function (el, args, calculate){
        if (_.is.obj(el, true)){
            calculate = args;
            args      = el;
            el        = null;
        }else if (_.is.fn(el)){
            calculate = el;
            args      = {};
            el        = null;
        }

        if (_.is.fn(args)){
            args = {'calculate':args};
        }else if (_.is.str(args)){
            args = {'props':args};
        }

        el             = el || this.el;
        args           = args || {};
        args.ctx       = this;
        args.calculate = args.calculate || calculate;

        var t = _.dom.transition(el, args);
        // _js(t);

        return this;
    };

    this.on = function (els, names, args, callback){
        // shortcut to DomReady and DomLoad
        if (els === ':ready'){
            _.dom.ready(this, names);
            return this;
        }else if (els === ':load'){
            _.dom.load(this, names);
            return this;
        }

        // Skip the els, it's a list of event name already
        if (_.is.str(els)){
            callback = args;
            args     = names;
            names    = els;
            els      = this.$el;
        }

        // The args is the callback
        if (_.is.fn(args)){
            callback = args;
            args     = null;
        }else if (_.is.str(args)){
            args = {'delegate':args};
        }

        els        = els || this.$el;
        args       = args || {};
        args.ctx   = this;
        args.alias = this.alias;
        
        var evt = _.dom.on(els, names, args, callback);
        var all = this.$.events = this.$.events || [];
        all.push(evt);

        return this;
    };

    this.trigger = function (names, data, args){
        args     = args || {};
        args.ctx = this;
        _.dom.trigger(this.$el, names, data, args);
        return this;
    };

    this.http = function (url, data, args, callback, key){
        var https = this.$.https = this.$.https || {};

        // stop all https
        if (url === false){
            for (var i in https) utils.cancel(https[i]);
            return this;
        }

        if (_.is.fn(args)){
            key      = callback;
            callback = args;
            args     = {};
        }else if (args === false){
            args     = {'loading':false};
        }

        if (_.is.fn(data)){
            key      = args;
            callback = data;
            args     = {};
            data     = {};
        }
        
        args             = args || {};
        args.ctx         = this;
        args.loading     = 'loading' in args ? args.loading : this.$el;
        args.loadingType = 'attrs';
        
        var key = key === true ? '*' : key;
        var old = key ? https[key] : null;

        // cancel old http query (with the same key)
        old && _.cancel(old);

        // make sure the key exists
        key = key || _.random();

        var http = https[key] = _.http(url, data, args, function (){
            delete(https[key]);
            var params = utils.$arr(arguments);
            _.apply.ctx(args.ctx, callback, params);
            
            // this.trigger('http', params); // TODO and test
        });

        return http;
    };
});

Module(function ElementFactory (_){
    this.$attr = null;
    this.items = [];

    this.init = function (){
        this.$.code = _.random('$' + this.$static.slug + '_');
        this.cache();
    };

    this.cache = function (){
        var selector = '[' + this.$attr + ']';
        var code     = this.$.code;

        this.$$(selector, function (v){
            if (v[code]) return;
            v[code] = this;
            
            var data = v.getAttribute(this.$attr);
            this.items.push({
                'node' : v,
                'value': _.toValue(data),
            });
        });
    };

    this.render = function (){

    };
});

// Add new Class makes
Class.add('Component', function (callback){
    
});

// Class.Element(function Bob (_){
    
// });

// Class.Element(function Bobby (_){
//     this.$extend = Bob;
// });
// [ ] Move things from Webstie here, for Web.refresh() and such
// [ ] Add the Browser code from v1
// [ ] Make sure the Element can't be created twice
// [ ] Add error validation if the definition doenst exists
// [ ] Add a quick way to add aria-hidden="true", so it's not visible
// [ ] Maybe add a "aria-live" or something like that that tells the user it's loading
// [ ] Add dependencies

/*
Web.Element(function (){
});

X(function (){
});

TODO rename to Web.
TODO add a default element maybe, just to have some interactivity (hide, move, ...)
*/

var WEB_DEFINITIONS = window.Web && Web.Elements ? Web.Elements : [];
var WEB_STYLES      = window.Web && Web.Styles ? Web.Styles : [];
var WEB_ELEMENTS    = window.ELEMENTS || {};
FFTO.Web = window.Web = (new function (){
    this.version = '1.0.1';

    var self     = this;
    var utils    = FFTO.Utils;
    var _        = utils;
    var Query    = FFTO.API.Query;
    var Styles   = [];
    var settings = {
        'prefix'  : '',
        'is'      : 'x',
        'element' : 'x-el',
        'name'    : 'x-name',
    };

    // consts ------------------------------------------------------------------
    var BASE = {
        "scan": function (ctx, refresh){
            if (ctx === true){
                refresh = true;
                ctx     = null;
            }

            if (ctx){
                self.scan(ctx);
            }

            if (refresh){
                self.refresh();
            }

            return this;
        },
        "apply" : function (callback, args, fallback){
            callback = utils.is.str(callback) ? this[callback] : callback;
            return utils.apply.ctx(this, callback, args, fallback);
        },
        "each" : function (){
            return utils.each.ctx(this, arguments);
        },
        "wait" : function (time, callback, params){
            var isInterval = false;
            
            if (utils.has(time, 'interval')){
                isInterval = true;
                time       = time.interval;
            }

            // TODO maybe add a way to cancel an Interval (if needed)

            var self     = this;
            var duration = utils.toDuration(time);
            var timeout  = null;
            var action   = function (){ 
                var r = callback.apply(self, params); 
                if (r === false){
                    clearInterval(timeout);
                    clearTimeout(timeout);
                }
            };

            timeout = isInterval ? setInterval(action, duration) : setTimeout(action, duration);

            return timeout;
        },
        '$$' : function (selector, global, callback){
            if (utils.is.fn(global)){
                callback = global;
                global   = false;
            }

            // TODO global should be TRUE if the selector is a node already

            var els = utils.dom.get.all(selector, {
                'ctx'   : global ? null : this.el,
                'parent': global ? '' : '[x]',        // limit to the current Element
                'alias' : this.$alias,
            }, callback);

            return utils.$$(els, {'ctx':this, 'alias':this.$alias});
        },

            "$el" : function (selector){
                return utils.dom.get(selector, {
                    'closest': this.$selector, 
                });
            },
            // [ ] Rename "get" to be "one" instead
            // [ ] Transform all element into "$query" items 
            "get" : function (selector, args, all){
                if (!selector) return null;

                var update = !!args;

                // simple way to add a new item to an HTMLElement
                if (utils.is.el(args)){
                    args = {'parent':args};
                }else if (args === false){
                    args = {'ctx':null};
                }

                args       = args || {};
                args.ctx   = 'ctx' in args ? args.ctx : this.el;
                args.alias = 'alias' in args ? args.alias : true;

                var alias  = args.alias ? this.$alias : null;
                var el     = utils.dom.get(selector, {'alias':alias, 'ctx':args.ctx});

                // 
                if (el){
                    var parent = 'parent' in args ? args.parent : (el.parentElement ? null : this.el);
                    
                    // if the element has no parent, it's been created, add it to the element
                    args.parent = parent;

                    if (!el.parentElement){
                        update = true;
                    }

                    update && utils.dom.update(el, args);
                }

                return el;
            },
            "all" : function (selector){
                return utils.dom.get.all(selector, {'ctx':this.el});
            },

        "css" : function (name, style){
            if (style === undefined){
                style = name;
                name  = '';
            }

            utils.dom.css({
                'name'  : name,
                'alias' : this.$alias,
            }, style);

            return this;
        },
        "http" : function (url, data, args, callback, key){
            if (!arguments.length){
                return !!this._isFetching;
            }

            this._https = this._https || {};

            // stop all https
            if (url === false){
                for (var i in this._https) utils.cancel(this._https[i]);
                this._isFetching = false;
                return null;
            }

            if (utils.is.fn(args)){
                key      = callback;
                callback = args;
                args     = {};
            }else if (args === false){
                args     = {'loading':false};
            }else if (utils.is.fn(data)){
                key      = args;
                callback = data;
                args     = {};
                data     = {};
            }
            
            if (_.is.str(args)){
                args = {'key':args};
            }

            args         = args || {};
            args.ctx     = this;
            args.loading = 'loading' in args ? args.loading : this.el;
            args.key     = 'key' in args ? args.key : key;
            
            var key = args.key === true ? '*' : args.key;
            var old = key ? this._https[key] : null;

            // cancel old http query (with the same key)
            old && utils.cancel(old);

            // format the URL for wordpress AJAX call (if it's just normal text)
            if (utils.theme('is_wp')){
                url = !~url.indexOf('/') ? '/wp-admin/admin-ajax.php?action=' + url : url;
            }    

            // make sure the key exists
            key = key || utils.random();

            this._isFetching = true;

            var http = utils.http(url, data, args, function (){
                this._isFetching = false;
                delete(this._https[key]);
                utils.apply.ctx(args.ctx, callback, utils.arr(arguments));

                // Always refresh
                Web.refresh();
            });

            this._https[key] = http;

            return http;
        },
        "on" : function (els, names, args, callback){
            if (els === ':ready'){
                utils.dom.ready(this, names);
                return this;
            }else if (els === ':load'){
                utils.dom.load(this, names);
                return this;
            }

            if (utils.is.str(els) && !utils.is.str(names)){
                callback = args;
                args     = names;
                names    = els;
                els      = this.el;
            }

            if (utils.is.fn(args)){
                callback = args;
                args     = {};
            }else if(utils.is.str(args)){
                args     = {'delegate':args};
            }

            els        = els || this.el;
            args       = args || {};
            args.ctx   = this;
            args.alias = this.$alias;

            // _js(els, names, args, callback);

            utils.dom.on(els, names, args, callback);
            
            return this;
        },
        "addClass" : function (els, names){
            if (names === undefined){
                names = els;
                els   = this.el;
            }
            utils.dom.addClass(els, names, this.$alias);
            return this;
        },        
        "removeClass" : function (els, names){
            if (names === undefined){
                names = els;
                els   = this.el;
            }
            utils.dom.removeClass(els, names, this.$alias);
            return this;
        },
        "trigger" : function (names, data, args){
            args     = args || {};
            args.ctx = this;
            utils.dom.trigger(this.el, names, data, args);
        },
        "template" : function (name, data, args){
            if (args === false){
                args = {'type':null};
            }

            data = utils.is.valid(data) ? data : this;
            args = args || {};

            var tpl = this.$.templates[name || '*'];
            if (!tpl) return false;

            var type   = 'type' in args ? args.type : tpl.type;
            var target = 'target' in args ? args.target : tpl.target;
            var html   = data ? utils.str.replace(tpl.html, data) : '';

            if (args.parent){
                target = args.parent;
            }

            // TODO add a quick way to just return the html OR type
            if (type === 'frag'){
                return utils.dom.get(html, {'type':'frag'});
            }else if (!type){
                return html;
            }else if (type && target){
                if (html){
                    html = utils.dom.create(html);
                    utils.dom.add(html, type, target);
                    // TODO deal with <script>
                }else{
                    target.innerHTML = '';
                }
            }
            
            return html;
        },
        "html" : function (el, html){
            if (html === undefined){
                html = el;
                el   = this.el;
            }

            _.dom.html(el, html, {
                'alias' : this.$alias,
            });
        },
        "bindings" : function (){
            var items = this.$.bindings || [];
            if (!items.length) return;

            // Not sure the "this" is a good idea, should be more of a sub-value maybe
            var self = this;

            utils.$arr(items, function (item){
                var html = item.html.call(self);
                utils.dom.html(item.element, html);
            });
        },
        "state" : function (key, value, delayed){
            if (utils.is.obj(key)){
                for (var i in key){
                    this.state(i, key[i]);
                }
                return this;
            }

            // make sure the states exists
            this.$.states = this.$.states || {};

            // check if the state has a linked auto set function
            if (utils.is.fn(this.__proto__.$states[key])){
                value = this.__proto__.$states[key].apply(this);
            }

            var previous = this.$.states[key];
            var response = previous;
            
            if (value !== undefined){
                this.$.states[key] = value;

                if (value !== previous && this.$onStateChange){
                    this.$onStateChange(key, value, previous);       // special methods $onStateChange
                }

                if (!delayed){
                    response = value;
                }

                // update all the $targets states
                utils.$arr(this.$.targets, function (el){
                    key = utils.toSlug(key);
                    utils.dom.attrs(el, key, value);
                });
            }

            return response;
        },
        "transition" : function (selector, args, calculate){
            if (utils.is.fn(args)){
                args = {'calculate':calculate};
            }else if (utils.is.either(args, 'str,arr')){
                args = {'props':args};
            }

            args     = args || {};
            args.ctx = this;
            utils.dom.transitionGroup(selector, args, null, calculate);

            return this;
        },
        "log" : function (){
            _log({
                'prefix': 'Web.Element.' + this.constructor.name,
                'color' : '#239b1b',
            }, arguments);
            return this;
        },
        "error" : function (){
            _log({
                'prefix': 'Web.Element.' + this.constructor.name,
                'color' : 'red',                
            }, arguments);
            return this;
        },
        "try" : function (callback){
            try{
                callback.call(this);
            }catch (e){}
        }
    };

    // props -------------------------------------------------------------------
    var isReady     = false;
    var instances   = [];
    var definitions = {};

    // private -----------------------------------------------------------------
    function _ready (){
        if (!isReady){
            isReady = true;

            // make sure the settings are fetched (if set through another file AFTER this file)
            if (window.FFTO_WEBSITE || window.WEBSITE){
                _err('Replace FFTO_WEBSITE and WEBSITE variable to FFTO_WEB and WEB');
            }
            utils.extend(settings, window.FFTO_WEB || window.WEB || {});

            // cache values
            settings.$is      = settings.prefix + settings.is;
            settings.$element = settings.prefix + settings.element;
            settings.$name    = settings.prefix + settings.name;
            settings.$selector= '[' + settings.$is + ']';
            settings.$prop    = '$' + settings.is;
        }
        
        self.scan();
    }

    function _hidden (el){
        var v = el.getAttribute('hidden');
        if (v == 'true' || v == 'hidden') return;
        el.removeAttribute('hidden');
    }

    function _clone (n){
        var el      = n.$ctx;
        var ss      = n.getAttribute('clone');
        var replace = !!~ss.indexOf('!replace');
        var html    = [];

        utils.$arr(ss, function (s){
            var inner = !!~s.indexOf('!inner');
            var ctx   = !!~s.indexOf(':scope') ? el : null;
            var h;
        
            // remove all modifiers
            s = s.replace(/\!(.|\s)+$/, '');
            // target nodes html
            h = utils.dom.get.all(s, {'ctx':ctx}, function (c){ return (inner ? c.innerHTML : c.outerHTML).trim(); }).join('\n'); 
            
            html.push(h);
        });
        html = html.join('\n');
        
        if (replace){
            utils.dom.add(html, 'replace', n);
        }else{
            n.innerHTML = html;
            n.removeAttribute('clone');
        }
    }

    function _instance (el, klass, init, data){
        var item      = new klass();
        var id        = (el && el.id) || (klass.name + '_' + (klass.count++));
        var data2     = WEB_ELEMENTS[item.$slug] || WEB_ELEMENTS[item.$name] || {}; // data set generally in "setup.js"
        var data3     = utils.dom.data(el);                                         // data from the element
        var templates = {};
        var ctx       = el;
        var els       = {original:el};

        // Elements/Templates --------------------------------------------------
        if (el && el !== document){
            // wrap html
            if (item.$wrap){
                var wrap = _.str.replace(item.$wrap, {'slot':'<slot />', 'html':'<slot />'}); // replace {{slot}} and {{html}} to a <slot> tag
                wrap = _.dom.create(wrap || 'div');

                _.dom.addClass(wrap, item.$alias + '--wrap');
                _.dom.add(wrap, 'after', el);
                
                // check if there's a slot
                var slot = _.dom.get.ctx(wrap, 'slot');
                if (slot){
                    _.dom.add(el, 'replace', slot);
                }else{
                    tag = _.dom.add(tag, 'wrap', el);
                }

                wrap.setAttribute('x', true);
                ctx = el = wrap;
            }

            utils.dom.attrs(el, 'id', id);

            var parent   = settings.$selector;
            var elAttr   = settings.$element;
            var nameAttr = settings.$name;
            var prop     = settings.$prop;
            var $targets = [el];
            
            el[prop] = item;

            // custom html 
            if (item.$html){
                var html     = item._html     = el.innerHTML;             // save the original html
                var children = item._children = utils.$arr(el.children);  // save the children

                html = utils.str.replace(item.$html, {'html':html});
                html = utils.toAlias(html, item.$alias);

                el.innerHTML = html;
            }

            // TODO Have all external items have the same default classname, + the original need it's own classname
            // add external targets
            var external = el.getAttribute('x-external');    // external targets to include in the context
            if (external && (external = utils.dom.get.all(external))){
                // make sure the new targets are linked to this 
                utils.$arr(external, function (v){ 
                    v[prop] = item; // add the '$x' to the HTMLElement
                });
                ctx = external.concat([ctx]);

                $targets = $targets.concat(external);
            }

            // get the elements
            utils.dom.get.all('['+elAttr+']', {'ctx':ctx, 'self':true, 'parent':parent, 'all':true}, function (node){
                var name       = utils.dom.attrs(node, elAttr);
                var isChildren = !!~name.indexOf('!children');
                var key        = name;
                var $node      = node;

                // A way to get the children, but give the parent the classname
                if (isChildren){
                    key   = key.replace('!children', '').trim();
                    $node = utils.dom.children($node);
                }

                // There can be multiple items with the same name (so it's turned into an array)
                if (key in els){
                    els[key] = _.is.arr(els[key], true) ? els[key] : [els[key]];
                    els[key].push($node);
                }else{
                    els[key] = $node;
                }

                // add classname
                utils.dom.addClass(node, item.$alias + '--' + key);

                // remove the "x-el" and replace it by "x-name". In case other module parse this block
                node.removeAttribute(elAttr);
                node.setAttribute(nameAttr, name);
            });

            // get the bindings
            var bindings = [];
            utils.dom.get.all('[bind]', {'ctx':ctx, 'parent':parent}, function (node){
                var bind     = node.getAttribute('bind');
                var tpl      = '';
                var callback = '';
                var self     = this;

                // there's 
                if (bind){
                    tpl = bind;
                }else{
                    tpl            = node.innerHTML;
                    node.innerHTML = '';
                }

                if (~tpl.indexOf('{{')){
                    callback = function (){
                        return utils.str.replace(tpl, this);
                    };
                }else{
                    callback = function (){
                        var html = tpl in item ? item[tpl] : tpl;
                        if (html instanceof Function){
                            html = html();
                        }
                        return html;
                    };
                }

                bindings.push({
                    'element': node,
                    'html'   : callback,
                });
            });

            // get the templates
            utils.dom.get('template, [template]', {'ctx':ctx, 'parent':parent, 'all':true}, function (node){
                var isTag  = utils.dom.tag(node) !== 'template';
                var name   = (isTag ? node.getAttribute('template') : node.getAttribute('id')) || '*';
                var target = node.parentElement;
                var type   = '';

                node.removeAttribute('template');

                if (node.hasAttribute('replace')){
                    type = 'html';
                    node.removeAttribute('replace');
                }else if (node.hasAttribute('append')){
                    type = 'append';
                    node.removeAttribute('append');
                }else if (node.hasAttribute('prepend')){
                    type = 'prepend';
                    node.removeAttribute('prepend');
                }else{
                    type = node.getAttribute('type') || (isTag ? 'html' : '');
                    node.removeAttribute('type');
                }

                templates[name] = {
                    'html'  : isTag ? node.outerHTML : node.innerHTML,
                    'type'  : type,
                    'target': target,
                }

                utils.dom.remove(node);
            });

            // TODO bind to data/content....

            el.setAttribute('module', 'ready');
            el.setAttribute('ready', '');
        }

        // Events --------------------------------------------------------------
        // props 
        item.id     = id;
        item.el     = el;
        item.target = el;
        item.els    = els;
        item.data   = utils.extend(item.data || {}, data2 || {}, data3 || {}, data || {});

        // add defaults els too
        var i, v;
        for (i in item.__proto__.$els){
            if (i in els) continue;
            v      = item.__proto__.$els[i];
            els[i] = v ? utils.dom.get(v, {'ctx':el, 'alias':this.$alias}) : false;
        }
        
        // Query elements
        item.$el = item.$$($targets);
        for (i in els){            
            item['$'+i] = item.$$(els[i], true);            
        }

        item.$.targets   = $targets;  // main targets
        item.$.templates = templates;
        item.$.bindings  = bindings;
        
        utils.dom.get.all('[clone]', {'ctx':ctx, 'parent':'[x]'}, _clone); 

        if (item.$delay){
            var delay = utils.toDuration(item.$delay);
            setTimeout(_init, delay);
        }else if (item.$ready){
            utils.dom.ready(_init);
        }else{
            _init();
        }
                
        function _init (){
            // wrapping

            // external
            utils.dom.addClass($targets, item.$alias);
            
            // clean "hidden"
            el && utils.dom.get.all('[hidden]', {'ctx':ctx, 'parent':'[x]'}, _hidden);
        
            // find styles
            for (var i in Styles){
                var style = Styles[i];
                
                if (
                    style.name 
                    && style.name !== klass.name
                    && style.name !== '*'
                ) continue;

                if (
                    style.selector 
                    && !utils.dom.is(el, style.selector)
                ) continue;

                item.data = utils.extend(item.data, style.data || {});

                utils.apply.ctx(item, style.callback, [utils, item, item.__proto__]);
            }

            // set the states
            utils.$arr(item.__proto__.$states, function (v, i){
                item[i] = v;
            });

            utils.apply(init, [item.data], {'ctx':item});
            instances.push(item);
            
            // add the events
            utils.dom.event.decode(ctx || document, {
                'ctx'     : item,
                'alt'     : settings.$name, // TODO maybe rename this to "action" instead
                // 'parent'  : '[x]',       // parent selector, check if the closest "[x]" is one of the "parents", if not, it's another child
                // 'parents' : $targets
                'defaults': 'x',
            }, item);

            item.trigger('init');
        }
        
        return item;
    }
    
    // methods -----------------------------------------------------------------
    /**
     * @class Element
     * 
     * Create a simple Element. Will add interactivity to a website. The *Element* definition can
     * contain special properties prefixed with __$_utils.
     * 
     * If the Element is linked to an HTMLElement, when being created, the [web-el] and &lt;template /&gt; nodes will be fetched and 
     * be accessible to the instance.
     * 
     * ### Special properties
     * 
     * | property   | info
     * --- | ---
     * | $is        | Specify the Element is attached to DOM elements with the attribute [x]. If not specified, the Element is a singleton, attached to nothing.
     * | $style     | CSS that will be automatically added to the &lt;head /&gt;
     * | $alias     | Replace "&" character to this value in the $style object
     * | $vars      | Other values to replace in the $style object
     * | $static    | Object that refers to the Element constructor. Shared properties can be added to this
     * | $once      | Function called only on the first creation of the first instance
     * 
     * 
     * ### Magic methods, they will be used if specified.
     * 
     * | function   | info
     * --- | ---
     * | init       | Function called on creation of every instance
     * | destroy    | Called by {@link Web.refresh} hhen the HTMLElement has been removed from the DOM
     * | refresh    | Called when Web.refresh() is called
     * | onResize   | Called when the screen resizes
     * | onScroll   | Called when the content is scrolled
     * | onLoad     | Called once the DOM has been loaded 
     * | on*        | Any functon that starts with "on" are magic functions that will link to DOM events. Those magic function can specify a eventname (eg.: onClick), or a delegate name with an eventname (eg.: onBigButtonClick). The function with delegate are linked either the [name] or [web-name] attribute. The delegate on the function are camelCase, while it's attribute name is dashCase.
     * 
     * @example 
     *
     * Web.Element(function ActionButton (){
     *      this.$is     = 'super-action-button';
     *      this.$style  = {
     *          '&' : 'border-radius:5px; padding:.5em;'
     *      };
     * 
     *      this.init = function (){ console.log('created', this.id); };
     * 
     *      this.onClick = function (){ console.log('Clicked!'); };
     * 
     *      this.onMouseenter = function (){ console.log('IN!'); };
     * }); 
     * 
     * @memberof Web
     * 
     * @param {string}          name 
     * @param {object|function} definition 
     */
    function Element (name, definition){
        var $is = null;

        // it's a singleton with NO attachemnt to a DOM element
        if (name === true){
            $is  = false;
            name = null;
        }

        // make sure it's ready 
        _ready();

        if (utils.is.fn(name) || utils.is.obj(name)){
            definition = name;
            name       = null;
        }

        if (utils.is.fn(definition)){
            name                         = name || definition.name || null;
            definition.prototype         = BASE;
            definition.prototype.$       = {};
            definition.prototype.$get    = {};
            definition.prototype.$set    = {};
            definition.prototype.$states = {};  // for changing states
            definition.prototype.$static = {};
            definition                   = new definition(utils);
        }else{
            definition.__proto__ = BASE;
        }

        name = name || utils.random('Element');
        
        if (name in definitions){
            // TODO Change this for "info" instead, so it's not visible on DEV/Stagting/Live server
            return utils.warn('[Web.Element] Element "{{ name }}" is already defined', {
                'name' : name,
            });
        }

        var $is        = $is === false ? $is : definition.$is;
        var $singleton = definition.$singleton;     // singleton = only 1 instance possible, but can have a DOM attached to it 
        var $style     = definition.$style || {};
        var $els       = definition.$els || {};
        var $slug      = $is || utils.toSlug(name);
        var $alias     = definition.$alias || ('element-' + $slug);
        var $vars      = definition.$vars || {};

        var $states    = definition.$states || {};
        var $once      = definition.$once || null;
        var init       = definition.init;

        if (!utils.is.valid($is)){
            $is = $slug;
        }

        // Deals with CamelCase of the "x", so for Element "big-box", it works with x="big-box" and x="BigBox"
        var $selector = definition.$selector || '['+settings.$is+'="'+name+'"], ['+settings.$is+'="'+$slug+'"]';
        
        delete(definition.$style);
        delete(definition.$els);
        delete(definition.$alias);
        delete(definition.$vars);
        delete(definition.$states);
        delete(definition.__proto__.$states);
        delete(definition.$static);
        delete(definition.$once);
        delete(definition.$selector);
        delete(definition.$is);
        delete(definition.init);

        // add state auto getter/setter
        utils.$arr($states, function (v, i){
            definition.$get[i] = definition.__proto__.$get[i] || function (){ 
                return this.$.states[i];
            };
            definition.$set[i] = definition.__proto__.$set[i] || function (vv){
                this.state(i, vv); 
            };
        });

        var klass                 = utils.toClassOld(name, definition);
        klass.count               = 0;
        klass.prototype.$slug     = $slug;
        klass.prototype.$name     = name;
        klass.prototype.$alias    = $alias;
        klass.prototype.$selector = $selector;
        klass.prototype.$states   = $states;
        klass.prototype.$els      = $els;
        klass.prototype.$base     = BASE;

        klass.alias = $alias;
  
        function create (ctx, el, data){
            ctx = ctx || document;
            ctx = utils.is.el(ctx) ? ctx : null;

            // add custom style to <head> --------------------------------------
            if ($style){
                utils.dom.css({
                    'name'  : 'Element: ' + name,
                    'alias' : $alias,
                    'data'  : $vars,
                }, $style);
                $style = null;
            }

            // once init -------------------------------------------------------
            // TODO search for custom element "web-element" ONLY if there's a "-" in it
            // var selector = el ? el : ($is ? [$selector, $is].join() : null); // search for HTMLElement is either "<div is="web-element"></div>" or "<web-element></web-element>"
            
            var selector = el ? el : ($is ? [$selector] : null); // search for HTMLElement is either "<div is="web-element"></div>" or "<web-element></web-element>"
            var prop     = settings.$prop;
            var targets  = selector ? utils.dom.get.all(selector, {'ctx':ctx}, function (el){
                if (el[prop]) return false;
                el[prop] = true;
                _hidden(el);
                return el;
            }) : [];
            
            if ($once && (!$is || $singleton || targets.length)){
                utils.apply($once, null, {'ctx':klass});
                $once = null;
            }
            
            // the module is element-less
            if (!$is){
                Element[name] = _instance(null, klass, init, data); 
            // a singleton class, only 1 instance is necessary
            }else if ($singleton && targets.length){
                Element[name] = _instance(targets[0], klass, init, data); 
            // list of many elements
            }else{
                Element[name] = Element[name] || [];

                var i, v;
                for (i in targets){
                    v = targets[i][prop] = _instance(targets[i], klass, init, data); 
                    Element[name].push(v);
                }
            }            
        }

        // add the create function to the list of module (that are linked to HTMLElement). 
        // if it's a Singleton, it's created only once
        if ($is){
            definitions[name] = create;
        }

        Web[name] = create;

        create(); // check right away if there's a element
    };

    /**
     * Check all the instances, and refresh for all items. If the instance has lost it's parent (eg.: has been removed from the DOM),
     * The instance will be destroyed and removed from the __LIVE__ list.
     * 
     * @memberof Web
     * @function refresh
     */
    this.refresh = function (type){
        this.each(type, function (v, i){
            // destroy module
            if (v.el && !v.el.offsetParent){
                // if (typeof v.destroy === 'function') v.destroy();
                // instances.splice(i, 1);
                // TODO deal with element that could be in cache. Maybe re-add them to the instances if IN the DOM
                // TODO also remove events                
            }else if (typeof v.refresh === 'function'){
                v.refresh();
            }
        });
    };

    this.ready = function (){
        _.dom.trigger(document, 'website-ready');
    };

    this.each = function (type, callback){
        if (utils.is.fn(type)){
            callback = type;
            type     = null;
        }

        // make sure the type is written the proper way
        type = utils.toSlug(type, 'words');

        var items = [];
        var i, v;
        for (i=instances.length - 1; i>=0; --i){ 
            v = instances[i];
            if (!v) continue;

            // skip element that aren't in the DOM anymore 
            if (v.el && !v.el.offsetParent) continue;

            // skip other's
            if (type && v.constructor.name !== type) continue;
            
            // call functions
            if (utils.is.str(callback) && utils.is.fn(v[callback])){
                utils.apply.ctx(v, v[callback]);
            }else if (utils.is.fn(callback)){
                utils.apply.ctx(v, callback, [v, i]);
            }

            items.push(v);
        }

        return items;
    };

    /**
     * Go through all the __Elements__ (that has a __$is__ property) and search for more DOM elements on the site
     * 
     * @memberof Web
     * @function scan
     * 
     * @param {HTMLElement} el  Parent context to search through
     **/
    this.scan = function (el, refresh){
        if (utils.is.bool(el)){
            refresh = el;
            el      = null;
        }

        refresh && this.refresh();
        for (var i in definitions){ 
            definitions[i](el); 
        }

        // also trigger an event on the body
        _.dom.trigger('body', 'web-scan');
    };

    /**
     * 
     * @param {*} els 
     * @param {*} type 
     * @param {*} data 
     */
    this.set = function (els, type, data){
        type = utils.toSlug(type, 'words');

        utils.dom.get.all(els, function (el){  
            if (type in definitions){
                definitions[type](null, el, data);
            }else{
                _err('Element "'+type+'" isn\'t defined.');
            }
        });
    };

    this.get = function (el, type){
        type = utils.toSlug(type, 'words');
        
        var ctx  = null;
        var prop = settings.$prop;
        if (el && el.$base === BASE){
            ctx = el;
        }else if (utils.is.el(el)){
            el  = utils.dom.closest(el, settings.$selector);
            ctx = el && el[prop] && el[prop].$base === BASE ? el.$is : null;
        }

        if (ctx && type){
            ctx = ctx.constructor.name === type ? ctx : null;
        }

        return ctx;
    };

    this.instances = instances;
    this.Element   = Element; // shortcut, using "X" instead of "Web.Element()"
    this.Style     = function (name, selector, data, callback){
        if (utils.is.obj(selector)){
            callback = data;
            data     = selector;
            selector = null;
        }
        if (utils.is.fn(data)){
            callback = data;
            data     = {};
        }

        Styles.push({
            'name'    : utils.toSlug(name, 'words'),
            'selector': selector,
            'data'    : data,
            'callback': callback,
        });
    };

    // -------------------------------------------------------------------------
    var items = window.WEB_DEFINITIONS || {}, i, l;
    for (i=0, l=items.length; i<l; ++i) Element.apply(null, items[i]);

    var items = window.WEB_STYLES || {}, i, l;
    for (i=0, l=items.length; i<l; ++i) this.Style.apply(null, items[i]);
   

    utils.dom.ready(this, _ready);
    utils.dom.load(this, _ready);
}());

/**
 * Quick shortcut for generating website elements
 */
/*
Web.Element(function ImageFocus(){
    this.refresh = function (){

    };
});

Web.Element(function UploadImage(){
    this.$is = 'upload-image';
    this.$alias  = 'field--upload-image';

    this.init = function (){

    };

    this.destroy = function (){

    };

    this.refresh = function (){

    };
});
*/

// console.log('WEB');
var CORE     = Core = {};
var BREAK    = '__BREAK__';
var CONTINUE = '__CONTINUE__';
var DEBUG    = '__DEBUG__';
var CLEAR 	 = '__CLEAR__';
var EXPANDO  = EXPANDO || '__CACHE__';
var KEY 	 = '► ⚀ ⚁ ⚂ ⚃ ⚄ ⚅ ◄'; 

/**
 * Utils singleton.
 * @class
 * @hideconstructor
 */
var Utils = CORE.Utils = window.utils = (new function (){
	var utils = this;

	this.version = '1.4.3';

	// contants ----------------------------------------------------------------
	var CONSTS = this.CONSTS = {
		RE : {
			NOT_PERCENTAGE	 : /[^0-9+-.%]/,
			VARS      		 : /\{{1,2}(.+?)\}{1,2}/g,
			NUMBER_WITH_UNIT : /(\-?\d+\.?\d*)([a-z\%]+)/g,
			NOT_NUMBER 		 : /[^0-9\+\-\*\/\.\(\)]/g,
			EMAIL            : /^([a-zA-Z0-9_\-\.\+]+)\@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/,
			APOSTROPHES      : /^['"](.+)['"]$/g,
			JSON_KEY         : /\s?([a-z\_\$][a-z\_\-\$]+)\s*\:/gi,
			JSON_STRING      : /(^(?:\[.+\])|(?:\{[^\{].+[^\}]\}{1}))/, // will only match "[ ... ]" and "{ ... }", not "{{ ... }}"
			//STRING_VALUES    : /(?:,|^|;)((?:[^,\("\'\{\[]+(?:(?:\(.+?\))|(?:(\{.+?\}))|(?:(\[.+?\]))|(?:\".+?\")|(?:\'.+?\'))?)|(?:\(.+?\))|(?:\".+?\")|(?:\'.+?\'))/g,
			STRING_VALUES    : /((?:[a-z0-9-+_%\/\\]+(?:\(.+\))?)|(?:\d[^\s,]*)|(?:"[^"]+")|(?:'[^']+')|(?:\[.+\])|(?:\(.+\))|(?:\{[^}]+\})|(?:\{\{[^}]+\}\}))(?:$|(?:\,\s*)|(?:\;\s*)|\s)/g,
			SRC_PATH 		 : /url\(([^\)]+)\)/,
			SRC_IMAGE_EXT    : /\.(jpg|jpeg|gif|png|svg|webp)(?:\?|\#|$)/g,
		},
		CACHE   : {},
		TIMERS  : {},
		LOGS    : [],
		LOG_LAST: '',
		COLOR_NAMES : {
			"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff",
			"beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2",
			"brown":"#a52a2a","burlywood":"#deb887","cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50",
			"cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff","darkblue":"#00008b","darkcyan":"#008b8b",
			"darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b",
			"darkolivegreen":"#556b2f","darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a",
			"darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1","darkviolet":"#9400d3",
			"deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff","firebrick":"#b22222",
			"floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff","gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700",
			"goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f","honeydew":"#f0fff0","hotpink":"#ff69b4",
			"indianred ":"#cd5c5c","indigo":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c","lavender":"#e6e6fa","lavenderblush":"#fff0f5",
			"lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff",
			"lightgoldenrodyellow":"#fafad2","lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a",
			"lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de","lightyellow":"#ffffe0",
			"lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6","magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa",
			"mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee",
			"mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa",
			"mistyrose":"#ffe4e1","moccasin":"#ffe4b5","navajowhite":"#ffdead","navy":"#000080","oldlace":"#fdf5e6","olive":"#808000",
			"olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6","palegoldenrod":"#eee8aa","palegreen":"#98fb98",
			"paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb",
			"plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080","red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1",
			"saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d",
			"silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f",
			"steelblue":"#4682b4","tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0","violet":"#ee82ee",
			"wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5","yellow":"#ffff00","yellowgreen":"#9acd32"
		}
	};

	// namespaces --------------------------------------------------------------
	this.string = {};
	this.number = {};
	this.math   = {};
	this.object = {};
	this.array  = {};
	this.fn 	= {};
	this.el     = {};
	this.els    = {};
	this.dom    = {};

	// type validation ---------------------------------------------------------
	this.is = function (v){
		return !!(v || v === 0 || v === '0');
	};
	this.is.not = function (v){
		return v === null || v === undefined || v === '' || v === false;
	};
	this.is.valid = function (v){
		return !(v === null || v === undefined || (typeof v === 'number' && (isNaN(v) || !isFinite(v))) || (v instanceof Date && isNaN(v)));
	};
	this.is.invalid = function (v){
		return !utils.is.valid(v);
	};
	this.is.defined = this.is.def = function (v){
		return v !== undefined;
	};
	this.is.null = function (v){
		return v === null;
	};
	this.is.string = this.is.str = function (v, re){
		return typeof(v) === 'string' && (!re || (re instanceof RegExp && !!v.match(re)) || (typeof(re) === 'string' && !!~v.indexOf(re)));
	};
	this.is.number = this.is.nbr = function (v){
		return typeof(v) === 'number';
    };
    this.is.numeric = function (v){
        return !isNaN(parseFloat(v)) && isFinite(v);
	};
	this.is.boolean = this.is.bool = function (v){
		return typeof(v) === 'boolean';
	};
	this.is.object = this.is.obj = function (v, isPlain){
		return isPlain ? 
			v !== null && typeof(v) === 'object' && Object.getPrototypeOf(v) == Object.prototype :
			v !== null && typeof(v) === 'object';
	};
	this.is.class = function (v, className){
		return v && typeof(v) === 'object' && v.constructor.name === className;
	};
	this.is.regexp = this.is.re = function (v){
		return utils.is.class(v, 'RegExp');
	};
	this.is.array = this.is.arr = function (v, isStrict){
		return v && (isStrict && typeof(v) === 'object' ? Object.getPrototypeOf(v) == Array.prototype : v instanceof Array);
	};
	this.is.function = this.is.fn = function (v){
		return typeof(v) === 'function';
	};
	this.is.node = function (v, type){
		var isNode = typeof Node === "object" ? 
			v instanceof Node : 
			v && typeof v === "object" && typeof v.nodeType === "number" && typeof v.nodeName==="string";

		if (isNode && type){
			if (type === 'text') 				isNode = v.nodeType === Node.TEXT_NODE;
			else if (type === 'comment') 		isNode = v.nodeType === Node.COMMENT_NODE;
			else if (typeof(type) === 'number')	isNode = v.nodeType === type;
		}

		return isNode;
	};
	this.is.element = this.is.el = function (v, tagOrQuery){
		var isElement = typeof HTMLElement === "object" || typeof SVGElement === 'object' ?
			v instanceof HTMLElement || v instanceof SVGElement :
			v && typeof v === "object" && v !== null && v.nodeType === 1 && typeof v.nodeName==="string";

		if (isElement && typeof(tagOrQuery) === 'string'){
			var tags = utils.toArray(tagOrQuery);
			var tag  = v.tagName.toLowerCase();
			isElement = !!~tags.indexOf(tag);
		}else if (tagOrQuery === true && utils.is.query(v)){
			isElement = true;
		}

		return !!isElement;
	};
	this.is.dom = function (v, isRoot, includeWindow){
		includeWindow = includeWindow === undefined ? true : includeWindow;

		// var isRootElement = v && ((includeWindow && v === window) || v === document || v === document.body || v === document.documentElement);
		var isRootElement = v && ((includeWindow && v === window) || v === document || v === document.documentElement);
		
		return isRoot ? isRootElement : (isRootElement || utils.is.element(v));
	};
	this.is.query = function (v, isDom){
		return !!(v instanceof NodeList || v instanceof HTMLCollection || (window.jQuery && v instanceof jQuery) || (v instanceof Array && utils.is.node(v[0])) || (isDom && utils.is.dom(v)));
	};
	this.is.input = function (v){
		return v instanceof HTMLInputElement;
	};
	this.is.svg = function (v){
		return v instanceof SVGElement;
	};
	this.is.empty = function (v){
		if (typeof v === 'string' && v.trim() === ''){
			return true;
		}else if (Array.isArray(v) && !v.length){
			return true;
		}else if (typeof v === 'object'){
			for (var i in v){
				return false;
			}
			return true;
		}else if (v === undefined || v === null){
			return true;
		}
		return false;
	};
	this.is.enumerable = function (v){
		return !!(v instanceof Array ||
			(v && typeof v === 'object' && v.length !== undefined));
	};
	this.is.hex = function (v){
		return typeof(v) === 'string' && /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(v);
	};
	this.is.rgb = function (v){
		return typeof(v) === 'string' && /^rgb/.test(v); 
	};
	this.is.hsl = function (v){
		return typeof(v) === 'string' && /^hsl/.test(v); 
	};
	this.is.color = function (v){
		return typeof(v) === 'string' && v.toLowerCase() in CONSTS.COLOR_NAMES || utils.is.hex(v) || utils.is.rgb(v) || utils.is.hsl(v);
	};
	this.is.email = function (v){
		return utils.is.string(v) && !!v.match(CONSTS.RE.EMAIL);
	};
	this.is.url = function (v){
		return typeof(v) === 'string' && v.indexOf('http') === 0;
	};
	this.is.img = function (v){
		return typeof(v) === 'string' && !!v.match(CONSTS.RE.SRC_IMAGE_EXT);
	};
	this.is.percent = function (v){
		return utils.is.string(v) && !!~v.indexOf('%');
	};
	this.is.encoded = function (v){
		if (
			typeof v !== 'string' ||
			v === '' ||
			v.trim() === ''
		) return false;

        try {
            return btoa(atob(v)) == v;
        } catch (err) {
            return false;
        }
	};
	this.is.either = function (v, types){
		if (!utils.is(v)) return false;
		
		types = utils.toArray(types);

		var i=0, l=types.length, t;
		for (;i<l;++i){
			t = types[i];
			if (t in utils.is && utils.is[t](v)){
				return true;
			}
		}

		return false;
	};
	this.is.in = function (v, list){
		list = utils.toArray(list, {'parse':true});
		return !!~list.indexOf(v);
	};
	this.has = function (obj, keys, all){
		if (!utils.is.obj(obj)){
			return;
		}

		keys = utils.toArray(keys);
		
		var i=0, l=keys.length, k;
		for (;i<l;++i){
			k = keys[i];

			if (all && !(k in obj)){
				return false;
			}else if (!all && (k in obj)){
				return true;
			}
		}

		return all ? true : false;
	};
	
	// getter/setter/calls -----------------------------------------------------
	this.get = function (value, args, context){
		if (utils.is.fn(args)){
			value = args.apply(context, [value]);
		}else if (utils.is.obj(value, true) && utils.is(args)){
			value = args in value ? value[args] : null;
		}else if (utils.is.fn(value)){
			value = value.apply(context, args);
		}
		return value;
	};

	this.apply = function (callback, args, context, fallback){
		if (typeof callback === 'function'){
			var response = callback.apply(context, args);
			if (response !== undefined){
				return response;	
			}
		}
		return fallback !== undefined ? fallback : (args && 0 in args ? args[0] : null);
	};

	this.format = function (value, format, context){
		return utils.is.fn(format) ? format.call(context, value) : value;
	};

	this.call = function (callback, value, context){
		this.deprecated('utils.call', 'utils.apply');
		
		if (typeof callback === 'function'){
			return utils.apply(callback, [value], context);
		}
	};

	this.defined = function (){
		var list = arguments;
		var i;
		if (list.length === 1 && Array.isArray(list[0])){
			list = list[0];
		}

		for (i in list){
			if (utils.is.defined(list[i])){
				return list[i];
			}
		}

		return null;
	};

	this.nvl = function (){
        var list = arguments;
		var i;
		
		if (list.length === 1 && Array.isArray(list[0])){
			list = list[0];
		}

		for (i in list){
			if (this.is.valid(list[i])){
				return list[i];
			}
		}

		return null;
	};

	this.fallback = function (obj, attr, fallback){
		if (obj && utils.is(obj[attr])){
			return obj[attr];
		}else{
			return fallback;
		}
	};

	this.args = function (args, defaults, key){
		if (key && args && typeof(args) !== 'object' && !~args.toString().indexOf('=')){
			args = utils.toSet(key, args);
		}

		args     = args || {};
		defaults = defaults || {};

		// parse args as string like 'key=value&key2=value'
		if (utils.is.str(args)){
			args = utils.string.decodeQuery(args);
		}

		var i;
		for (i in args){
			defaults[i] = args[i];
		}

		return defaults;
	};
	
	this.now = function (){
		return +new Date();
	};

	// helpers -----------------------------------------------------------------
	this.match = function (item, search, args){
		args         = args || {};
		args.case    = 'case' in args ? args.case : true;
		args.loose   = 'loose' in args ? args.loose : true;
		args.deep    = 'deep' in args ? args.deep : true;    // go deeper and deeper in arrays/objects
		args.data    = 'data' in args ? args.data : {};
		args.context = args.context || null;

		if ('caseSensitive' in args){
			utils.deprecated('utils.match(?, ?, args.caseSensitive)', 'args.case');
			args.case = args.caseSensitive;
		}

		var iType 		= typeof(item);
		var sType 		= typeof(search);
		var areStrings  = iType === 'string' && iType === sType;
		var areObjects 	= utils.is.object(item, true) && utils.is.object(search, true);
		var areArrays 	= utils.is.array(item, true) && utils.is.array(search, true);
		
		function _match (a, b, depth){
			depth = depth === undefined ? 0 : depth;

			// one children is missing/null
			if (a === null || b === null){
				return false;
			}

			var i;
			for (i in b){
				if (!b.hasOwnProperty(i)) continue;
				if (!_is(a, b, i)){
					return false;
				}
			}

			return true;
		}

		function _is (a, b, i){
			var aValue  = a[i];
			var bValue  = b[i];
			var isObject= utils.is.object(aValue, true) && args.loose;
			var isArray = utils.is.array(aValue, true) && args.loose;

			if (
				((isArray || isObject) && !_match(aValue, bValue)) ||
				(!isObject && !isArray && aValue !== bValue)
			){
				return false;
			}

			return true;
		}

		if (
			item === search ||
            (areStrings && !args.case && item.toLowerCase() === search.toLowerCase()) ||
            (iType === 'string' && search instanceof RegExp && item.match(search)) ||
			(sType === 'function' && search.apply(args.context || item, [item, args.data]) === true) ||
			(args.loose && (areObjects || areArrays) && _match(item, search))
		){
			return true
		}

		return false;
	};

	this.equal = function (a, b){
		if (a === b){
			return true;
		}
		if (a === null || b === null){
			return false;
		}

		var aType 	= Object.prototype.toString.call(a);
		var bType 	= Object.prototype.toString.call(b);

		if (aType !== bType){
			return false;
		}

		if (b instanceof Array){
			if (a.length !== b.length){
				return false;
			}
			var i=0, l=b.length;
			for (; i<l; ++i){
				if (!utils.equal(a[i], b[i])){
					return false;
				}
			}
		}else if (typeof b === 'object' && utils.is.object(b, true)){
			// not the same length
			var aCount = 0;
			var bCount = 0;
			var i;
			for (i in a){
				if (!a.hasOwnProperty(i)) continue;
				aCount++;
			}
			for (i in b){
				if (!b.hasOwnProperty(i)) continue;

				if (!utils.equal(a[i], b[i])){
					//utils.debug.log('---->' , i, a[i], '!==',  b[i]);
					return false;
				}

				bCount++;
			}
			if (aCount !== bCount){
				return false;
			}
		}else if (a !== b){
			return false;
		}

		return true;
	};

	this.each = function (list, args, callback){
		if (typeof args === 'function'){
			callback 	= args;
			args 		= {};
		}

		args           = args || {};
		args.type      = 'type' in args ? args.type : null;
		args.args      = 'args' in args ? args.args : false;
		args.all 	   = args.all || false;
		args.context   = 'context' in args ? args.context : list;
		
		args.separator = 'separator' in args ? args.separator : ',';
		args.trim      = 'trim' in args ? args.trim : true;
		args.lowercase = 'lowercase' in args ? args.lowercase : false;
		args.update    = 'update' in args ? args.update : false;
		args.reindex   = 'reindex' in args ? args.reindex : false;
		args.filter    = 'filter' in args ? args.filter : false;
		
		args.continue  = 'continue' in args ? args.continue : CONTINUE;
		args.break     = 'break' in args ? args.break : BREAK;
		
		// [normal, reverse, random, grid]
		args.order = 'order' in args ? args.order : false;
		if (args.reverse){
			args.order = 'reverse';
		}

		// @todo grid order https://animejs.com/documentation/#gridStaggering

		var keys 	= [];
		var length  = 0;
		var type 	= null;

		if (list === null){
			list = [];
			type = 'null';
		}else if (typeof list === 'number'){
			keys   = null;
			length = list;
			type   = 'number';
		}else if (typeof list === 'string'){
			keys   = null;
			list   = list.trim().split(args.separator).filter(function (v){ return v.trim() !== ''; });
			type   = 'string';
			length = list.length;
		}else if (utils.is.enumerable(list)){
			keys 	= null;
			length 	= list.length;
			type 	= 'array';
		}else{
			var keys = [], i;
			for (i in list){
				if (args.all || list.hasOwnProperty(i)){
					keys.push(i);
				}
			}
			length  = keys.length;
			type 	= 'object';
		}

		if (args.reindex){
			type = 'object';
		}

		// forced type
		if (args.type){
			type = args.type;
		}

		if (args.order === 'random'){
			if (!keys){
				keys = utils.array.create(length, function (v){ return v - 1; });
			}

			utils.array.shuffle(keys);
		}

		function _get (index){
			if (args.order === 'reverse' || args.order === 'backward'){
				index = length - index - 1;
			}else if (utils.is.arr(args.order)){
				// @todo deal with grid
			}

			var key   = keys ? keys[index] : index;
			var value = type === 'number' ? index+1 : list[key];
		
			return {
				'index' : index,
				'key'	: key,
				'value'	: value,
			}
		};

		var items = type === 'object' ? {} : [];
		var last  = null;
		var i, l, a, item, response, previous, next;
		for (i=0, l=length; i<l; ++i){
			item = _get(i);
			
			if (typeof item.value === 'string'){
				if (args.trim) 		item.value = item.value.trim();
				if (args.lowercase) item.value = item.value.toLowerCase();
			}

			response = undefined;
			if (typeof callback === 'function'){
				previous = _get(i - 1);
				next     = _get(i + 1);

				a 	 	      = args.args || {};
				a.index       = i;
				a.isFirst 	  = i === 0;
				a.isLast 	  = i === (length-1);
				a.isBetween   = (!a.isFirst && !a.isLast);
				a.ratio 	  = (i + 1) / length;
				a.key 	      = item.key;
				a.length      = length;
				a.type        = type;
				a.previousKey = previous.key;
				a.nextKey     = next.key;
				a.previous    = previous.value;
				a.next 	      = next.value;
				a.last  	  = last;

				response = callback.apply(args.context || item.value, [item.value, item.key, a]);
			}else{
				response = item.value;
			}

			if (response === args.continue){
				continue;
			}else if (response === args.break){
				break;
			}else if (response !== undefined && args.update){
				list[item.key] = response;
			}

			last = response;

			if (response !== undefined || !args.filter){
				if (response === undefined){
					response = item.value;
				}

				if (utils.has(response, '$id')){
					// convert to object if it's not already set
					if (items instanceof Array){
						items = {};
					}

					var id 	  = response['$id'];
					var value = last = response['$value'] ? response['$value'] : response;

					delete(response['$id']);
					delete(response['$value']);

					items[id] = value;
				}else if (args.reindex && utils.has(response, 'key,value')){
					utils.deprecated('Utils.each(), return "key, value"', "$id");
					items[response.key] = last = response.value;
				}else if (type === 'object'){
					items[item.key] = last = response;
				}else if (utils.is(response) || !args.filter){
					last = response;
					items.push(response);
				}
			}
		}

		return items;
	};

	this.eachContext = this.each.context = function (ctx, list, args, callback){
		if (utils.is.fn(args)){
			callback = args;
			args 	 = {};
		}
		
		args         = args || {};
		args.context = args.context || ctx;

		return utils.each(list, args, callback);
	};

	this.eachGet = this.each.get = function (ctx){
		return function (list, args, callback){
			return utils.each.context(ctx, list, args, callback);
		};
	};

	this.map = function (list, callback){
		return utils.each(list, {'type':'array', 'filter':true}, callback);
	};

	this.count = function (list, separator){
		if (separator instanceof RegExp){
			var m = list.match(separator);
			return m ? m.length : 0;
		}
		separator = this.defined(separator, '');
		list      = this.toArray(list, separator);
		return list.length;
	};

	this.extend = function (){
		var copies = [];
		var clones = [];
		var isDebug= arguments[0] === DEBUG;

		function _walk (){
			var target = arguments[0];

			if (target === undefined || target === null){
				return target;
			}

			var isDeep   = false;
			var i		 = 1;
			var length   = arguments.length;

			if (typeof target === 'boolean' || target === DEBUG){
				isDeep = !!target;
				target = arguments[i] || {};
				i++;
			}

			for (; i<length; ++i){
				var item = arguments[i];

				// add the current target/copie to list of clones and copies (when refering to "same" item)
				if (isDeep){
					clones.push(target);
					copies.push(item);
				}

				for (var name in item){
					if (!target.hasOwnProperty(name)){
						var info = Object.getOwnPropertyDescriptor(target, name);
						// console.log(target, info);
					}

					var src        = target[name];
					var copy       = item[name];
					var copyIndex  = isDeep ? copies.indexOf(copy) : -1;
					var clone;

					// skip infinity loop
					if (target === copy){
						continue;
					}

					if (~copyIndex){
						target[name] = clones[copyIndex];
					}else if (isDeep && copy && (utils.is.arr(copy, true) || utils.is.obj(copy, true))){
						// make sure to create a new Array/Object when it's an inherited property
						if (!target.hasOwnProperty(name)){
							src = null;
						}

						if (utils.is.arr(copy, true)){
							clone = src && utils.is.arr(src, true) ? src : [];
						}else{
							clone = src && utils.is.obj(src, true) ? src : {};
						}

						copies.push(copy);
						clones.push(clone);

						if (isDebug){
							console.log(name, copy, clone);
						}

						target[name] = _walk(isDeep, clone, copy);
					}else{
						target[name] = copy;
					}
				}
			}

			return target;
		}

		var response = _walk.apply(this, arguments);
		delete(clones);
		delete(copies);

		return response;
	};

	this.copy = function (obj, props){
		if (obj instanceof Array){
			return utils.extend(true, [], obj, props || []);
		}else if (typeof obj === 'object'){
			return utils.extend(true, {}, obj, props || {});
		}else{
			return obj;
		}
	};

	this.defaults = function (obj, defaults, isCopy){
		obj = obj || {};

		var i;
		for (i in defaults){
			if (i in obj) continue;
			obj[i] = isCopy ? utils.copy(defaults[i]) : defaults[i];
		}
		return obj;
	};

	this.cache = function (obj, key, value, expando){
        if (!utils.is.obj(obj)){
            return null;
		}
		
		expando = expando || EXPANDO;

		var set  = utils.toSet(key, value);
		var data = (expando !== undefined ? obj[expando] || (obj[expando] = {}) : obj) || {};
		
		// symbols complex ID
		if (Array.isArray(key)){
			var symbols = data['__SYMBOLS__'] || (data['__SYMBOLS__'] = []);
			var index   = null;
			var next 	= null;
			var i=0, l=symbols.length, keys, ii, ll;

			loop_items : for (;i<l;++i){
				keys = symbols[i];
				ii   = 0;
				ll   = key.length;

				if (keys === null){
					// re-use an old Symbol entry
					if (next === null) next = i;
					continue;
				}
				
				if (keys.length !== key.length) continue;

				loop_keys: for (;ii<ll;++ii){
					if (keys[ii] !== key[ii]){
						continue loop_items;
					}
				}

				index = i;
				break;
			}

			if (index === null){
				index = next === null ? symbols.length : next;
			}

			if (utils.is.defined(value)){
				if (value === null){
					symbols[index] = null;
				}else{
					symbols[index] = key;
				}

				set 	 = {};
				key 	 = 'Symbol(' + index + ')';
				set[key] = value;
			}else{
				set = null;
				key = 'Symbol(' + index + ')';
			}
		}
		
		if (set){
			utils.extend(data, set);
			return data;
        }else if (key !== undefined){
			return data[key];
        }else{
            return data;
        }
	};
	
	this.calculate = function (nbr, units, args){
		if (typeof units === 'number'){
			units = {'%':units};
		}
		if (typeof args === 'number'){
			args = {'offset':args};
		}

		units  		= units || {};
		args 		= args || {};
		args.offset = 'offset' in args ? args.offset : 0;
		args.vars 	= 'vars' in args ? args.vars : null;

		if (units['%'] === undefined){
			units['%'] = 1;
		}

		var isFloor = false;
		var isRound = false;
		var isCeil  = false;
		var isHalf 	= false;

		if (typeof nbr === 'string'){
			isFloor = !!~nbr.indexOf('!floor');
			isRound = !!~nbr.indexOf('!round');
			isCeil  = !!~nbr.indexOf('!ceil');			
			isHalf  = !!~nbr.indexOf('!half');	// add half a pixel
		}

		// if there's variable to replace (eg.: (2n + 45))
		if (utils.is.str(nbr) && args.vars){
			var i;
			var re = [];
			for (i in args.vars) re.push(i);
			
			re = new RegExp('(\-?\\d+(?:\\.\\d+)?)?(' + re.join('|') + ')', 'g');

			nbr = nbr.replace(re, function (m, $1, $2){
				var m = parseFloat($1) || 1;
				var n = args.vars[$2];
				return n  * m;
			});
		}

		if (nbr === undefined || nbr === null){
			nbr = 0;
		}else if (!isNaN(nbr)){
			nbr = parseFloat(nbr);
		}else if (nbr === '?' || nbr === 'random'){
			nbr = Math.random() * units['%'];
		}else if (typeof nbr === 'string' && !nbr.match(CONSTS.RE.NOT_PERCENTAGE)){
			nbr = parseFloat(nbr) / 100 * units['%'];
		}else if (typeof nbr === 'string'){
			// random numbers (the previous ifs are shortcuts when the string is simpler, makes things faster)
			nbr = nbr.replace(/\?/g, function (){
				return Math.random() * units['%'];
			});

			nbr = nbr.replace(CONSTS.RE.NUMBER_WITH_UNIT, function (m, $1, $2){
				var n = parseFloat($1);

				if ($2 in units){
					n = (n / 100) * units[$2]; 
				}else{
					n = m;
				}

				return n;
			});
		}

		if (typeof nbr === 'string'){
			nbr = nbr.replace(CONSTS.RE.NOT_NUMBER, '');
			try{ nbr = eval(nbr); }catch (e){}
		}
		
		nbr = (nbr || 0);
		
		if (args.offset){
			nbr += args.offset;
		}

		if (isFloor) nbr = ~~nbr;
		if (isRound) nbr = Math.round(nbr);
		if (isCeil)  nbr = Math.ceil(nbr);
		if (isHalf)	 nbr = ~~nbr + 0.5; 	// half decimals, good to graphic when we need half a pixel
		
		return nbr;
	};

	this.encode = function (data){
		if (!utils.is.valid(data)) return null;
		data = JSON.stringify(data);
		data = window.btoa(unescape(encodeURIComponent(data)));
		return data;
	};

	this.decode = function (data){
		try{
			data = decodeURIComponent(escape(window.atob(data)));
			data = JSON.parse(data);
		}catch(e){
			data = null;
		}
		return utils.is.valid(data) ? data : null;
	};

	// casting -----------------------------------------------------------------
	this.toSet = function (key, value, fallback){
		if (utils.is.obj(key, true)){
			return key;
		}else if (value !== undefined){
			var values = {};
			values[key] = value;
			return values;
		}else{
			return fallback;
		}
	};

	this.toString = function (value, fallback){
		fallback = fallback === undefined ? '' : fallback;
		return utils.nvl(value, fallback).toString().trim();
	};

	this.toArray = function (list, args){
		if (!list && list !== 0){
			return [];
		}

		if (utils.is.either(args, 'str,re')){
            args = {'separator':args};
        }else if (utils.is.bool(args)){
            args = {'unique':args};
        }else if (utils.is.fn(args)){
			args = {'filter':args};
		}

        args = args || {};
		
		if ('map' in args){
			this.deprecated('args.map', 'args.filter');
			args.filter = args.filter || args.map;
		}

        args.parse     = args.parse || null;
		args.filter    = args.filter || null;
		args.separator = 'separator' in args ? args.separator : ',';
        args.multiple  = 'multiple' in args ? args.multiple : false;
        args.unique    = 'unique' in args ? args.unique : false;

		// is an array of array
		if (args.multiple){
			var i=0, l=list.length, item;
			var arr = [];
			for (; i<l; ++i){
				item = utils.toArray(list[i], {'separator':args.separator});
				arr  = arr.concat(item);
			}
			list = arr;
		}

        var arr = [];
		if (utils.is.arr(list, true)){
			arr = list;
		}else if (utils.is.enumerable(list)){
			var i=0, l=list.length;
			for (;i<l;++i){ arr.push(list[i]); };
		}else if (utils.is.obj(list, true)){
			var i;
			for (i in list){
				arr.push(list[i]);
			}			
		}else if (typeof list === 'string'){
			arr = utils.string.split(list, args.separator, {'keep':false});
			arr = arr.map(function (v){ return v.trim(); });
		}else if (list !== undefined){
			arr = [list];
		}

		if (args.map || args.parse || args.filter){
			var arr2 = [];
			var i=0, l=arr.length, v;
			for (; i<l; ++i){
				v = arr[i];
				v = args.parse ? utils.toValue(v) : v;
				v = utils.format(v, args.filter);

				if (utils.is(v)){
					arr2.push(v);
				}
			}
			
			arr = arr2;
		}

        if (args.unique){
            arr = utils.array.unique(arr);
        }

		return arr;
	};

	this.toObject = function (obj, key, extend, copy){
		if (utils.is.bool(extend)){
			copy   = extend;
			extend = null;
		}

		// make sure it has a default pattern (if not already set properly)
		if (!utils.has(obj, key)){
			obj = utils.toSet(key, obj);
		}else if (copy){
			obj = utils.copy(obj);
		}

		if (utils.is.obj(extend)){
			obj = utils.extend(true, obj, extend);
		}

		return obj
	};

	this.toJson = function (str, args){
		if (utils.is.obj(str)){
			return str;
		}
		if (utils.is.bool(args)){
			args = {'normalize':args};
		}

        args           = args || {};
        args.normalize = 'normalize' in args ? args.normalize : false;
        args.context   = 'context' in args ? args.context : null;
        args.warn      = 'warn' in args ? args.warn : false;
		args.fallback  = 'fallback' in args ? args.fallback : null;

        if (!utils.is.str(str)){
			return args.fallback;
        }
        
		str = str.trim();

        if (args.normalize){
			str = str.replace(/\'/g, '"');
			str = str.replace(/\/\/.+/g, '');
			str = str.replace(CONSTS.RE.JSON_KEY, '"$1":');
			str = utils.string.trim(str, true);

			// remove the first and last "{/}" to be able to remove the last ","
			if (!str.match(/^[\{\[].+[\}\]]$/)){
				str = str.replace(/^\{|\}$/g, '');
				str = str.replace(/\,$/, '');
				str = '{' + str + '}';
			}
		}else{
			str = str.replace(/^\/\/.*/gm, ''); // remove comments
            // str = str.replace(/\t|\r|\n/g, ' ').trim();
			// console.log(str);

            // make sure there's a brackets
            if (str[0] !== '{' && str[0] !== '['){
                str = '{'+str+'}';
            }
        }

        var json = args.fallback;
        try{
            var fn = eval('(function (){ return function (){ return '+str+'; } }())');
            json = fn.apply(args.context);
		}catch (e){
			if (args.warn){
				utils.warn('The JSON string couldn\'t be eval().\n{error}\n\n{str}', {'error':e, 'str':str});
			}
		}

		return json;
    };

	this.toSrc = function (src, args){
		if (utils.is.str(args)){
			args = {'type':args};
		}
		
		args 		= args || {};
		args.type 	= args.type || null;
		args.ext 	= 'ext' in args ? args.ext : null;

		var isImage = false;
		if (args.type === 'image'){
			if (src instanceof Image){
				src     = src.getAttribute('src') || '';
				isImage = true;
			}else if (utils.is.el(src)){
				src = window.getComputedStyle(src).backgroundImage;
			}
		}
		if (args.type === 'link'){
			if (!src && utils.is.el(src)){
				src = src.getAttribute('href') || '';
			}
		}
		
		if (!utils.is.str(src)){
			return false;
		}

		src = ~src.indexOf('url(') ? src.match(CONSTS.RE.SRC_PATH)[1] : src;
		src = src.trim().replace(/^"|"$/g, '');

		if (args.type === 'image' && !isImage && !src.match(CONSTS.RE.SRC_IMAGE_EXT)){
			src = '';
		}

		// @info an hashtag means a local element
		if (src && src[0] === '#'){
			src = false;
		}

		return src ? src : false;
	};

    this.toValue = function (str, args){
		if (typeof str !== 'string' || str === ''){
			return str;
		}
		if (utils.is.bool(args)){
			args = {'json':args};
		}

		args 			= args || {};
		args.context 	= 'context' in args ? args.context : null;
		args.clean 		= 'clean' in args ? args.clean : true;
		args.wrap 		= 'wrap' in args ? args.wrap : false; // wrap string with apostrophes
		args.color 		= 'color' in args ? args.color : true;
		args.json 		= 'json' in args ? args.json : false;

		var value = str.trim();

		if (value === 'true'){
			value = true;
		}else if (value === 'false'){
			value = false;
		}else if (value === 'null' || value === 'undefined' || value === null || value === undefined){
			value = null;
		}else if (!isNaN(value) && value !== '' && (value == 0 || value[0] !== '0')){
			value = parseFloat(value);
		}else if (args.color && typeof(value) === 'string' && value.match(/^rgba\(/)){
			var values = value.replace(/(rgba\()|\)/g, '').split(',');
			if (values.length === 2){
				var color = values[0].trim().toLowerCase();
				
				if (color in CONSTS.COLOR_NAMES){
					var color = CONSTS.COLOR_NAMES[color].replace('#', '');
					var r     = parseInt(color.substring(0,2), 16);
					var g     = parseInt(color.substring(2,4), 16);
					var b     = parseInt(color.substring(4,6), 16);
					var a     = values[1].trim();
					value = 'rgba('+[r,g,b,a]+')';
				}
			}
		}else if (value === 'this'){
			value = args.context;
		}else if (args.json && value.match(CONSTS.RE.JSON_STRING)){
			value = utils.toJson(value, false) || value;
		// remove the beginining an ending apostrophe
		}else if (args.clean){
			value = value.replace(CONSTS.RE.APOSTROPHES, '$1');
		}else{
			value = str;
		}

		if (args.wrap && utils.is.str(value)){
			value = '"' + value.replace(/\"/, '\"') + '"';
		}

		return value;
	};

	this.toValues = function (str, args){
		var values = [];

		if (!str){
			return values;
		}

		if (str instanceof Array){
			for (var i in str){
				var value = args !== false ? utils.toValue(str[i], args) : value;
				values.push(value);
			}
		}else if (typeof str === 'string'){
            // @info this does not work with complex string like : `"text", 1234, true, { a : "value" }` the object isn't parsed properly
			str.replace(CONSTS.RE.STRING_VALUES, function (m, $1){
				var value = args !== false ? utils.toValue($1, args) : $1;

				if (args === false){
					value = value.replace(CONSTS.RE.APOSTROPHES, '$1');
				}

				values.push(value);
			});
		}

		return values;
	};

	this.toColor = function (color){
		// var color = color.trim().toLowerCase();
		// if (color in CONSTS.COLOR_NAMES){
		// 	var color = CONSTS.COLOR_NAMES[color].replace('#', '');
		// 	var r     = parseInt(color.substring(0,2), 16);
		// 	var g     = parseInt(color.substring(2,4), 16);
		// 	var b     = parseInt(color.substring(4,6), 16);
		// 	var a     = values[1].trim();
		// 	value = 'rgba('+[r,g,b,a]+')';
		// }
		// return color;
	};

	this.toRandom = function (type){
		type = type || 'string';

		if (type === 'color'){
			var r = Math.floor(Math.random() * 255).toString(16);
			var g = Math.floor(Math.random() * 255).toString(16);
			var b = Math.floor(Math.random() * 255).toString(16);
	
			r = (r.length == 1 ? '0' : '') + r;
			g = (g.length == 1 ? '0' : '') + g;
			b = (b.length == 1 ? '0' : '') + b;
	
			return '#'+[r,g,b].join('').toUpperCase();
		}else if (type === 'string'){
			return Math.floor(Math.random() * 0xFFFFFF).toString(16);
		}else if (type === 'number'){
			return Math.random() * 1000;
		}else if (type === 'ratio'){
			return Math.random() * 1;
		}else if (type === 'boolean'){
			// @todo
		}else if (type === 'date'){
			// @todo
		}
	};

	// logs --------------------------------------------------------------------
	var _log = function (type, msg, data, args){
		args        = args || {};
		args.colors = args.colors || null;
		args.once 	= args.once || false;
		args.repeat = 'repeat' in args ? args.repeat : true;

		if (utils.is.obj(data)){
			msg = msg.replace(CONSTS.RE.VARS, function (m, $1){
				return data[$1.trim()] || '';
			});
		}

		if (args.once){
			if (~CONSTS.LOGS.indexOf(msg)){
				return;
			}
			CONSTS.LOGS.push(msg);
		}else if (!args.repeat){
			if (CONSTS.LOG_LAST === msg){
				return;
			}
			CONSTS.LOG_LAST = msg;
		}

		if ('table' in console){
			msg = [msg].concat(args.colors || []);
		}else{
			msg = [msg.replace('%c', '')];
		}

		console[type].apply(null, msg);
	};

	this.log = function (msg, data, args){
		_log('log', msg, data, args);
	};

	this.info = function (msg, data, args){
		args        = args || {};
		args.colors = ['color:#aaa;'];
		
		if (typeof msg === 'string'){
			msg = '%c' + msg.replace(/\%c/g, '');
		}else{
			args.colors = null;
		}

		_log('info', msg, data, args);
	};

	this.warn = function (msg, data, args){
		_log('warn', msg, data, args);
	};

	this.error = function (msg, data, args){
		_log('error', msg, data, args);
	};

	this.deprecated = function (msg, alt){
		if (alt){
			console.warn('[DEPRECATED] "'+msg+'" is deprecated, use "'+alt+'" instead');
		}else{
			console.warn('[DEPRECATED] '+msg);
		}
	};
	
	this.time = function (key, clear){
		if (typeof key === 'boolean'){
			clear = key;
			key   = '*';
		}else{
			key = key !== undefined ? key : '*';	
		}

		var timer = CONSTS.TIMERS[key];
		if (timer === undefined){
			timer = CONSTS.TIMERS[key] = {'time':0};
			clear = true;
		}

		var now = +new Date();
		if (clear){
			timer.time = now;
		}else{
			var time = now - timer.time;
			var text = '[TIMER:'+key + '] ' + time + 'ms';
			
			console.log(text);
			
			timer.time = now;

			return time + 'ms';
		}
	};

	this.debug = function (on){
		if (utils.is.bool(on)){
			window.__debug__ = on;
			return;
		}

		if (window.__debug__){
			console.log.apply(null, arguments);
		}
	};

	window.p = function (){
		var args = utils.toArray(arguments);

		if (args.length){
			console.trace.apply(null, args);
		}else{
			console.trace(args[0]);
		}
	};

	// Fallbacks ---------------------------------------------------------------
	this._easing = function (easing, isCss, fallback){
		if (easing === 'linear'){
			easing = null;
		}

		if (utils.easing){
			easing = utils.easing.get(easing, isCss);
		}else{
			if (easing && easing !== utils.fn.empty){
				utils.warn('Easing utils is missing, import it to use "{name}" easing', {'name':easing}, {'once':true});
			}
		}

		if (isCss){
			if (utils.is.str(easing) && (
				utils.is.in(easing, 'linear,ease,ease-in,ease-in-out,ease-out') || 
				easing.indexOf('cubic-bezier(') === 0 ||
				easing.indexOf('steps(') === 0
			)){
				return easing;
			}else{
				return (fallback ? fallback : easing) || 'linear';
			}
		}else{
			return (utils.is.fn(easing) ? easing : fallback) || utils.fn.empty;
		}
	};

	this._log = function (){
		if (!window.Console) return;
		var c = Console.get();

		if (arguments[0] === CLEAR){
			c.clear();
		}else{
			c.log.apply(c, arguments);
		}
		
		return c;
	};

	this._draw = function (){
		if (!window.Console) return;
		var c = Console.get();
		c.draw.apply(c, arguments);
		return c;
	};

	// extras ------------------------------------------------------------------
	this.add = function (namespace, fn){
		if (fn === undefined){
			fn        = namespace;
			namespace = null;
		}

		var obj  = this;
		var cName= null;
		if (namespace){
			namespace = namespace.split('.');

			var i, name;
			for (i in namespace){
				name = namespace[i];
				obj  = (obj[name] = obj[name] || {});
			}

			cName = namespace.join('_').toUpperCase();
		}

		if (utils.is.obj(fn)){
			var i;
			for (i in fn){
				obj[i] = fn[i];
			}
		}else if (utils.is.fn(fn)){
			var static = CONSTS;

			// create a static constant holder for the new group
			if (cName){
				static = CONSTS[cName] = CONSTS[cName] || {};
			}
			
			fn.apply(obj, [this, static, CONSTS.RE, CONSTS]);
		}
	};

	this.brand = function (){
		var bears = [
			'ᕦʕ •ᴥ•ʔᕤ           ',
			'ʕ ㅇ ᴥ ㅇʔ           ',
			'ʕง•ᴥ•ʔง             ',
			'ʕ•ᴥ•ʔﾉ♡             ',
			'ʕ ꈍᴥꈍʔ              ',
			'ʕ – ᴥ – ʔ           ',
			'ʕノ•ᴥ•ʔノ ︵ ┻━┻   '
		];
	
		var index  = (Math.random() * bears.length) | 0;
		var bear   = bears[index];
		var color  = '#9AC0DF';


		console.log(
			'%c'+bear+'   ffto/js v'+utils.version,
			'font-weight:bold; color:'+color+';',
		);
	};

	window.site = window.site || {};

	var v = 'v' + utils.version;
	if (window.site.js){
		window.site.js = [window.site.js, v];
	}else{
		window.site.js = v;
	}
});

// Alias namespaces
window._    = window._ || Utils;
window._.v1 = Utils;

// console.log('V1');
Utils.add('string', function (utils, STRING, RE){
    // consts ------------------------------------------------------------------
    RE.REPLACE_IF       = window.RE_REPLACE_IF || /\{\{\s*\@if\s+(!)?([^}]+)\s*\}\}([\s\S]+?)\{\{\s*@endif\s*\}\}/gm;
    RE.REPLACE_EACH     = window.RE_REPLACE_EACH || /\{\{\s*\@each\s+(?:(?:(.+)\:)?(.+))\s+in\s+([^}]+)\s*\}\}([\s\S]+?)\{\{\s*@endeach\s*\}\}/gm;
    RE.REPLACE_VARS     = window.RE_REPLACE_VARS || /\{\{\s*([^}|]+)(?:\|([^}]*))?\s*\}\}/g; 
	RE.REPLACE_VARS 	= window.RE_REPLACE_VARS || /\{\{\s*([^}|\:]+)(?:\|([^:}]*))?(?:\:([^}]*))?\s*\}\}/g;

	// RE.REPLACE_IF       = /\{\{\s*\@if\s+(!)?([^}]+)\s*\}\}([\s\S]+?)\{\{\s*@endif\s*\}\}/gm;
    // RE.REPLACE_EACH     = /\{\{\s*\@each\s+(?:(?:(.+)\:)?(.+))\s+in\s+([^}]+)\s*\}\}([\s\S]+?)\{\{\s*@endeach\s*\}\}/gm;
    // RE.REPLACE_VARS     = /\{\{\s*([^}|]+)(?:\|([^}]*))?\s*\}\}/g; 
	RE.SPACE_CASE       = /((?:\_|\s|\-|\/|[A-Z]))[a-z0-9]/g;
	RE.CALLBACK_PARAMS  = /([^\(]+)(?:\(([^\)]+)\))?/;
	RE.ACCENTS 			= /[^A-Za-z0-9\[\] ]/g;
	RE.CSS 				= /(.+?)\{((?:.|\r|\t|\n)+?)\}/gm;
	RE.COMMENTS 		= /\/\*(.|\n|\r)+?\*\//gm;

	RE.CSS_SELECTOR     = /(\#[a-z][\w-]*)|(\.[\-a-z][\w-]*)|(\[[^\]]+\])|(\{[^\]]+\})|(\=.+)|([a-z][\w-]*)/gi;

	STRING.TEXTAREA 	= null;

	STRING.ACCENTS_MAP = {
		"Á":"A","Ă":"A","Ắ":"A","Ặ":"A","Ằ":"A","Ẳ":"A","Ẵ":"A","Ǎ":"A","Â":"A","Ấ":"A","Ậ":"A","Ầ":"A","Ẩ":"A","Ẫ":"A","Ä":"A","Ǟ":"A","Ȧ":"A","Ǡ":"A","Ạ":"A","Ȁ":"A","À":"A","Ả":"A","Ȃ":"A","Ā":"A","Ą":"A","Å":"A","Ǻ":"A","Ḁ":"A","Ⱥ":"A","Ã":"A","Ꜳ":"AA","Æ":"AE","Ǽ":"AE","Ǣ":"AE","Ꜵ":"AO","Ꜷ":"AU","Ꜹ":"AV","Ꜻ":"AV","Ꜽ":"AY",
		"Ḃ":"B","Ḅ":"B","Ɓ":"B","Ḇ":"B","Ƀ":"B","Ƃ":"B",
		"Ć":"C","Č":"C","Ç":"C","Ḉ":"C","Ĉ":"C","Ċ":"C","Ƈ":"C","Ȼ":"C",
		"Ď":"D","Ḑ":"D","Ḓ":"D","Ḋ":"D","Ḍ":"D","Ɗ":"D","Ḏ":"D","ǲ":"D","ǅ":"D","Đ":"D","Ƌ":"D","Ǳ":"DZ","Ǆ":"DZ",
		"É":"E","Ĕ":"E","Ě":"E","Ȩ":"E","Ḝ":"E","Ê":"E","Ế":"E","Ệ":"E","Ề":"E","Ể":"E","Ễ":"E","Ḙ":"E","Ë":"E","Ė":"E","Ẹ":"E","Ȅ":"E","È":"E","Ẻ":"E","Ȇ":"E","Ē":"E","Ḗ":"E","Ḕ":"E","Ę":"E","Ɇ":"E","Ẽ":"E","Ḛ":"E","Ꝫ":"ET",
		"Ḟ":"F","Ƒ":"F",
		"Ǵ":"G","Ğ":"G","Ǧ":"G","Ģ":"G","Ĝ":"G","Ġ":"G","Ɠ":"G","Ḡ":"G","Ǥ":"G",
		"Ḫ":"H","Ȟ":"H","Ḩ":"H","Ĥ":"H","Ⱨ":"H","Ḧ":"H","Ḣ":"H","Ḥ":"H","Ħ":"H",
		"Í":"I","Ĭ":"I","Ǐ":"I","Î":"I","Ï":"I","Ḯ":"I","İ":"I","Ị":"I","Ȉ":"I","Ì":"I","Ỉ":"I","Ȋ":"I","Ī":"I","Į":"I","Ɨ":"I","Ĩ":"I","Ḭ":"I",
		"Ꝺ":"D","Ꝼ":"F","Ᵹ":"G","Ꞃ":"R","Ꞅ":"S","Ꞇ":"T","Ꝭ":"IS",
		"Ĵ":"J","Ɉ":"J",
		"Ḱ":"K","Ǩ":"K","Ķ":"K","Ⱪ":"K","Ꝃ":"K","Ḳ":"K","Ƙ":"K","Ḵ":"K","Ꝁ":"K","Ꝅ":"K",
		"Ĺ":"L","Ƚ":"L","Ľ":"L","Ļ":"L","Ḽ":"L","Ḷ":"L","Ḹ":"L","Ⱡ":"L","Ꝉ":"L","Ḻ":"L","Ŀ":"L","Ɫ":"L","ǈ":"L","Ł":"L","Ǉ":"LJ",
		"Ḿ":"M","Ṁ":"M","Ṃ":"M","Ɱ":"M",
		"Ń":"N","Ň":"N","Ņ":"N","Ṋ":"N","Ṅ":"N","Ṇ":"N","Ǹ":"N","Ɲ":"N","Ṉ":"N","Ƞ":"N","ǋ":"N","Ñ":"N","Ǌ":"NJ",
		"Ó":"O","Ŏ":"O","Ǒ":"O","Ô":"O","Ố":"O","Ộ":"O","Ồ":"O","Ổ":"O","Ỗ":"O","Ö":"O","Ȫ":"O","Ȯ":"O","Ȱ":"O","Ọ":"O","Ő":"O","Ȍ":"O","Ò":"O","Ỏ":"O","Ơ":"O","Ớ":"O","Ợ":"O","Ờ":"O","Ở":"O","Ỡ":"O","Ȏ":"O","Ꝋ":"O","Ꝍ":"O","Ō":"O","Ṓ":"O","Ṑ":"O","Ɵ":"O","Ǫ":"O","Ǭ":"O","Ø":"O","Ǿ":"O","Õ":"O","Ṍ":"O","Ṏ":"O","Ȭ":"O","Ƣ":"OI","Ꝏ":"OO","Ɛ":"E","Ɔ":"O","Ȣ":"OU",
		"Ṕ":"P","Ṗ":"P","Ꝓ":"P","Ƥ":"P","Ꝕ":"P","Ᵽ":"P","Ꝑ":"P",
		"Ꝙ":"Q","Ꝗ":"Q",
		"Ŕ":"R","Ř":"R","Ŗ":"R","Ṙ":"R","Ṛ":"R","Ṝ":"R","Ȑ":"R","Ȓ":"R","Ṟ":"R","Ɍ":"R","Ɽ":"R","Ꜿ":"C","Ǝ":"E",
		"Ś":"S","Ṥ":"S","Š":"S","Ṧ":"S","Ş":"S","Ŝ":"S","Ș":"S","Ṡ":"S","Ṣ":"S","Ṩ":"S",
		"Ť":"T","Ţ":"T","Ṱ":"T","Ț":"T","Ⱦ":"T","Ṫ":"T","Ṭ":"T","Ƭ":"T","Ṯ":"T","Ʈ":"T","Ŧ":"T","Ɐ":"A","Ꞁ":"L","Ɯ":"M","Ʌ":"V","Ꜩ":"TZ",
		"Ú":"U","Ŭ":"U","Ǔ":"U","Û":"U","Ṷ":"U","Ü":"U","Ǘ":"U","Ǚ":"U","Ǜ":"U","Ǖ":"U","Ṳ":"U","Ụ":"U","Ű":"U","Ȕ":"U","Ù":"U","Ủ":"U","Ư":"U","Ứ":"U","Ự":"U","Ừ":"U","Ử":"U","Ữ":"U","Ȗ":"U","Ū":"U","Ṻ":"U","Ų":"U","Ů":"U","Ũ":"U","Ṹ":"U","Ṵ":"U",
		"Ꝟ":"V","Ṿ":"V","Ʋ":"V","Ṽ":"V","Ꝡ":"VY",
		"Ẃ":"W","Ŵ":"W","Ẅ":"W","Ẇ":"W","Ẉ":"W","Ẁ":"W","Ⱳ":"W",
		"Ẍ":"X","Ẋ":"X",
		"Ý":"Y","Ŷ":"Y","Ÿ":"Y","Ẏ":"Y","Ỵ":"Y","Ỳ":"Y","Ƴ":"Y","Ỷ":"Y","Ỿ":"Y","Ȳ":"Y","Ɏ":"Y","Ỹ":"Y",
		"Ź":"Z","Ž":"Z","Ẑ":"Z","Ⱬ":"Z","Ż":"Z","Ẓ":"Z","Ȥ":"Z","Ẕ":"Z","Ƶ":"Z","Ĳ":"IJ",
		"Œ":"OE",
		"ᴀ":"A","ᴁ":"AE","ʙ":"B","ᴃ":"B","ᴄ":"C","ᴅ":"D","ᴇ":"E","ꜰ":"F","ɢ":"G","ʛ":"G","ʜ":"H","ɪ":"I",
		"ʁ":"R","ᴊ":"J","ᴋ":"K","ʟ":"L","ᴌ":"L","ᴍ":"M","ɴ":"N","ᴏ":"O","ɶ":"OE","ᴐ":"O","ᴕ":"OU","ᴘ":"P",
		"ʀ":"R","ᴎ":"N","ᴙ":"R","ꜱ":"S","ᴛ":"T","ⱻ":"E","ᴚ":"R","ᴜ":"U","ᴠ":"V","ᴡ":"W","ʏ":"Y","ᴢ":"Z",
		"á":"a","ă":"a","ắ":"a","ặ":"a","ằ":"a","ẳ":"a","ẵ":"a","ǎ":"a","â":"a","ấ":"a","ậ":"a","ầ":"a","ẩ":"a","ẫ":"a","ä":"a","ǟ":"a","ȧ":"a","ǡ":"a","ạ":"a","ȁ":"a","à":"a","ả":"a","ȃ":"a","ā":"a","ą":"a","ᶏ":"a","ẚ":"a","å":"a","ǻ":"a","ḁ":"a","ⱥ":"a","ã":"a","ꜳ":"aa","æ":"ae","ǽ":"ae","ǣ":"ae","ꜵ":"ao","ꜷ":"au","ꜹ":"av","ꜻ":"av","ꜽ":"ay",
		"ḃ":"b","ḅ":"b","ɓ":"b","ḇ":"b","ᵬ":"b","ᶀ":"b","ƀ":"b","ƃ":"b","ɵ":"o","ć":"c","č":"c","ç":"c","ḉ":"c","ĉ":"c","ɕ":"c","ċ":"c","ƈ":"c","ȼ":"c","ď":"d","ḑ":"d","ḓ":"d","ȡ":"d","ḋ":"d","ḍ":"d","ɗ":"d","ᶑ":"d","ḏ":"d","ᵭ":"d","ᶁ":"d","đ":"d","ɖ":"d","ƌ":"d","ı":"i","ȷ":"j","ɟ":"j","ʄ":"j","ǳ":"dz","ǆ":"dz",
		"é":"e","ĕ":"e","ě":"e","ȩ":"e","ḝ":"e","ê":"e","ế":"e","ệ":"e","ề":"e","ể":"e","ễ":"e","ḙ":"e","ë":"e","ė":"e","ẹ":"e","ȅ":"e","è":"e","ẻ":"e","ȇ":"e","ē":"e","ḗ":"e","ḕ":"e","ⱸ":"e","ę":"e","ᶒ":"e","ɇ":"e","ẽ":"e","ḛ":"e","ꝫ":"et","ḟ":"f","ƒ":"f","ᵮ":"f","ᶂ":"f","ǵ":"g","ğ":"g","ǧ":"g","ģ":"g","ĝ":"g","ġ":"g","ɠ":"g","ḡ":"g","ᶃ":"g","ǥ":"g",
		"ḫ":"h","ȟ":"h","ḩ":"h","ĥ":"h","ⱨ":"h","ḧ":"h","ḣ":"h","ḥ":"h","ɦ":"h","ẖ":"h","ħ":"h","ƕ":"hv","í":"i","ĭ":"i","ǐ":"i","î":"i","ï":"i","ḯ":"i","ị":"i","ȉ":"i","ì":"i","ỉ":"i","ȋ":"i","ī":"i","į":"i","ᶖ":"i","ɨ":"i","ĩ":"i","ḭ":"i","ꝺ":"d","ꝼ":"f","ᵹ":"g","ꞃ":"r","ꞅ":"s","ꞇ":"t","ꝭ":"is","ǰ":"j","ĵ":"j","ʝ":"j","ɉ":"j",
		"ḱ":"k","ǩ":"k","ķ":"k","ⱪ":"k","ꝃ":"k","ḳ":"k","ƙ":"k","ḵ":"k","ᶄ":"k","ꝁ":"k","ꝅ":"k","ĺ":"l","ƚ":"l","ɬ":"l","ľ":"l","ļ":"l","ḽ":"l","ȴ":"l","ḷ":"l","ḹ":"l","ⱡ":"l","ꝉ":"l","ḻ":"l","ŀ":"l","ɫ":"l","ᶅ":"l","ɭ":"l","ł":"l","ǉ":"lj","ſ":"s","ẜ":"s","ẛ":"s","ẝ":"s","ḿ":"m","ṁ":"m","ṃ":"m","ɱ":"m","ᵯ":"m","ᶆ":"m",
		"ń":"n","ň":"n","ņ":"n","ṋ":"n","ȵ":"n","ṅ":"n","ṇ":"n","ǹ":"n","ɲ":"n","ṉ":"n","ƞ":"n","ᵰ":"n","ᶇ":"n","ɳ":"n","ñ":"n","ǌ":"nj",
		"ó":"o","ŏ":"o","ǒ":"o","ô":"o","ố":"o","ộ":"o","ồ":"o","ổ":"o","ỗ":"o","ö":"o","ȫ":"o","ȯ":"o","ȱ":"o","ọ":"o","ő":"o","ȍ":"o","ò":"o","ỏ":"o","ơ":"o","ớ":"o","ợ":"o","ờ":"o","ở":"o","ỡ":"o","ȏ":"o","ꝋ":"o","ꝍ":"o","ⱺ":"o","ō":"o","ṓ":"o","ṑ":"o","ǫ":"o","ǭ":"o","ø":"o","ǿ":"o","õ":"o","ṍ":"o","ṏ":"o","ȭ":"o","ƣ":"oi","ꝏ":"oo","ɛ":"e","ᶓ":"e","ɔ":"o","ᶗ":"o","ȣ":"ou",
		"ṕ":"p","ṗ":"p","ꝓ":"p","ƥ":"p","ᵱ":"p","ᶈ":"p","ꝕ":"p","ᵽ":"p","ꝑ":"p","ꝙ":"q","ʠ":"q","ɋ":"q","ꝗ":"q","ŕ":"r","ř":"r","ŗ":"r","ṙ":"r","ṛ":"r","ṝ":"r","ȑ":"r","ɾ":"r","ᵳ":"r","ȓ":"r","ṟ":"r","ɼ":"r","ᵲ":"r","ᶉ":"r","ɍ":"r","ɽ":"r","ↄ":"c","ꜿ":"c","ɘ":"e","ɿ":"r","ś":"s","ṥ":"s","š":"s","ṧ":"s","ş":"s","ŝ":"s","ș":"s","ṡ":"s","ṣ":"s","ṩ":"s","ʂ":"s","ᵴ":"s","ᶊ":"s","ȿ":"s",
		"ɡ":"g","ᴑ":"o","ᴓ":"o","ᴝ":"u","ť":"t","ţ":"t","ṱ":"t","ț":"t","ȶ":"t","ẗ":"t","ⱦ":"t","ṫ":"t","ṭ":"t","ƭ":"t","ṯ":"t","ᵵ":"t","ƫ":"t","ʈ":"t","ŧ":"t","ᵺ":"th","ɐ":"a","ᴂ":"ae","ǝ":"e","ᵷ":"g","ɥ":"h","ʮ":"h","ʯ":"h","ᴉ":"i","ʞ":"k","ꞁ":"l","ɯ":"m","ɰ":"m","ᴔ":"oe","ɹ":"r","ɻ":"r","ɺ":"r","ⱹ":"r","ʇ":"t","ʌ":"v","ʍ":"w","ʎ":"y","ꜩ":"tz",
		"ú":"u","ŭ":"u","ǔ":"u","û":"u","ṷ":"u","ü":"u","ǘ":"u","ǚ":"u","ǜ":"u","ǖ":"u","ṳ":"u","ụ":"u","ű":"u","ȕ":"u","ù":"u","ủ":"u","ư":"u","ứ":"u","ự":"u","ừ":"u","ử":"u","ữ":"u","ȗ":"u","ū":"u","ṻ":"u","ų":"u","ᶙ":"u","ů":"u","ũ":"u","ṹ":"u","ṵ":"u","ᵫ":"ue","ꝸ":"um","ⱴ":"v","ꝟ":"v","ṿ":"v","ʋ":"v","ᶌ":"v","ⱱ":"v","ṽ":"v","ꝡ":"vy","ẃ":"w","ŵ":"w","ẅ":"w","ẇ":"w","ẉ":"w","ẁ":"w","ⱳ":"w","ẘ":"w",
		"ẍ":"x","ẋ":"x","ᶍ":"x","ý":"y","ŷ":"y","ÿ":"y","ẏ":"y","ỵ":"y","ỳ":"y","ƴ":"y","ỷ":"y","ỿ":"y","ȳ":"y","ẙ":"y","ɏ":"y","ỹ":"y","ź":"z","ž":"z","ẑ":"z","ʑ":"z","ⱬ":"z","ż":"z","ẓ":"z","ȥ":"z","ẕ":"z","ᵶ":"z","ᶎ":"z","ʐ":"z","ƶ":"z","ɀ":"z","ﬀ":"ff","ﬃ":"ffi","ﬄ":"ffl","ﬁ":"fi","ﬂ":"fl","ĳ":"ij","œ":"oe","ﬆ":"st","ₐ":"a","ₑ":"e","ᵢ":"i","ⱼ":"j","ₒ":"o","ᵣ":"r","ᵤ":"u","ᵥ":"v","ₓ":"x"
	};

    // methods -----------------------------------------------------------------
    this.trim = function (str, clearAll){
        if (!str) return '';
        
		if (clearAll){
			str = str.replace(/\t/g, ' ').replace(/\n|\r/g, ' ');
		}

		return str.replace(/\s{2,}/g, ' ').trim();
    };

    this.match = function (str, re, singleOrCallback){
		var isSingle = singleOrCallback === true;
		var callback = typeof singleOrCallback === 'function' ? singleOrCallback : null;
		var groups   = [];
		var match    = null;
		var max      = 1000;
		var i        = 0;
		var l        = 0;
        var value;

		if (re.global){
            while ((match = re.exec(str)) !== null && max > 0){
				value = match;

				if (callback){
					value = callback.apply(null, match);
				}else if (value.groups){
					value = value.groups;
				}else{
					value = [];
					for (i=1, l=match.length; i<l; ++i){
						value.push(match[i]);
					}
				}

				groups.push(value);
				max--;
			}
		}else if (match = str.match(re)){
			if (match.groups && callback){
				groups = callback.call(null, match.groups);
			}else if (match.groups){
				groups = match.groups;
			}else{
				for (i=1, l=match.length; i<l; ++i){
				    value = match[i];

					if (callback){
						value = callback.call(null, value, i-1);
					}

					groups.push(value);
				}
			}
		}

		return isSingle ? groups[0] : groups;
    };
    
    this.repeat = function (str, times){
		if (typeof times !== 'number' || times < 0){
			return '';
		}
		return new Array((times+1) | 0).join(str);
    };
    
    this.truncate = function (str, limit, suffix){
		if (!str) 					return '';
		if (suffix === undefined) 	suffix = '...';
		if (limit === undefined) 	limit = 25;

		var text 	= str.toString();
		var length 	= text.length;

		return length <= limit ? text : text.substr(0, limit) + suffix;
    };
    
    this.split = function (str, separator, args){
		if (utils.is.bool(args)){
			args = {'trim':args};
		}

		args        = args || {};
		args.trim   = 'trim' in args ? args.trim : false;
		args.keep   = 'keep' in args ? args.keep : false;  // keep the separator
		args.format = args.format || null;

		var isNumber = utils.is.number(separator);

        separator = separator === undefined ? 1 : separator;
        separator = isNumber ? new RegExp('.{1,'+separator+'}', 'g') : separator;

		var arr = [];
		if (utils.is.string(separator)){
			arr = str.split(separator);

			if (args.keep){
				var list = [];
				utils.each(list, function (v, i){
					if (i) list.push(separator);
					list.push(v);
				});
			}
		}else if (separator instanceof RegExp){
			if (isNumber || !args.keep){
				arr = str.match(separator);
			}else{
				var seps = [];
				str = str.replace(separator, function (v){
					seps.push(v);
					return KEY;
				}).split(KEY);

				var list = [];
				utils.each(str, function (v, i){
					var s = seps[i];
					if (v){
						v = utils.apply(args.format, [v, false]);
						list.push(v);
					}
					if (s){
						v = utils.apply(args.format, [s, true]);
						list.push(s);
					}
				});

				arr = list;
			}
		}

		if (args.trim){
			arr = arr.map(function (v){ 
				return v.trim(); 
			});
		}

		return arr;
	};
    
    this.pad = function (str, pad, length, position){
        if (utils.is.not(str)) return '';
		if (str.toString().length >= length) return str;

        position = position === undefined ? 'right' : position;

		var count 	= length - str.toString().length;
		var result  = '';

		if (position == 'left'){
			result = utils.string.repeat(pad, count) + str;
		}else if (position == 'center'){
			var leftCount 	= Math.floor(count / 2);
			var rightCount 	= Math.ceil(count / 2);
			result = utils.string.repeat(pad, leftCount) + str + utils.string.repeat(pad, rightCount);
		}else if (position == 'right'){
			result = str + utils.string.repeat(pad, count);
		}

		return result;
    };
    
    this.replace = function (str, data, args){
		args     = args || {};
		args.var = 'var' in args ? args.var : /\$([a-z_-]+)/ig;
		
		if (typeof str === 'string' && args.var){
			str = str.replace(args.var, '{{$1}}');
		}

		if (typeof str !== 'string' || !~str.indexOf('{')){
			return str;
		}
		if (data === undefined){
			data = {};
		}

        // make sure the string variables are single "{" and "}"
		//str = str.replace(/\{{2}/g, '{').replace(/\}{2}/g, '}');

		args.fallback  = 'fallback' in args ? args.fallback : '';
		args.separator = 'separator' in args ? args.separator : '';
		args.filters   = args.filters || null;
		args.paths     = 'paths' in args ? args.paths : true;        // try to resolve path like with the data
		
		function _get (data, key){
			var value = undefined;
			data = data || {};

			if (typeof data === 'function'){
				value = data(key);
			}else if (data[key] !== undefined){
				value = data[key];
			}else if (key && args.paths && typeof data === 'object'){
                if (!utils.object.resolve){
                    utils.warn('Utils.object.resolve() is missing');
                }else{
                    value = utils.object.resolve(data, key);   
                }
			}

			if (typeof value === 'function'){
				value = value();
			}

			return value;
		}

		if (data instanceof Array){
			var items = [], i, l, item;
			for (i=0, l=data.length; i<l; ++i){
				item = typeof data[i] !== 'object' ? {'value':data[i]} : data[i];
				item = utils.string.replace(str, item, {
					'fallback': args.fallback,
					'filters' : args.filters,
					'paths'   : args.paths
				});
				items.push(item);
			}
			return items.join(args.separator);
		}else{
			// simple each
			str = str.replace(RE.REPLACE_EACH, function (match, key, value, list, row){
				key   = (key || '').trim();
				value = (value || '').trim();
				list  = (list || '').trim();
				list  = _get(data, list) || [];
				list  = utils.is.numeric(list) ? utils.array.create(list) : list;

				var items = [];
				var i=0, l=list.length, item;
				for (; i<l; ++i){
					item = utils.copy(data);

					if (key){
						item[key] = i;
					}
					if (value){
						item[value] = list[i];
					}

					item = utils.string.replace(row, item, {'fallback':args.fallback, 'paths':args.paths});
					items.push(item);
				}
				
				return items.join('\n');
			});

			// simple if(s)
			str = str.replace(RE.REPLACE_IF, function (match, isNot, key, content){
				isNot = isNot === '!' ? true : false;
				key   = key.trim();

				var value  = _get(data, key);
				var isTrue = !!value; // value === 0 || value === '0' || !!value;

				return isNot !== isTrue ? content : '';
			});

			// Variable replacement
			var values 	 = [];
			var isSingle = str.replace(RE.REPLACE_VARS, '') === '';

			str = str.replace(RE.REPLACE_VARS, function (match, text, fallback, filters){
				var value = undefined;
				var keys  = text.trim().split(',');

				for (var i=0, l=keys.length; i<l; ++i){
					var key   = keys[i].trim();
					var value = _get(data, key);

					if (value !== undefined){
						break;
					}
				}

				if (value === undefined){
					if (fallback === undefined){
						value = args.fallback !== null ? args.fallback : '{{'+text+'}}';
					}else{
						value = fallback;
					}
				}

				// formating
				if (args.filters && filters){
					filters.split(':').forEach(function (f){
						f = utils.string.toAction(f.trim());
						
						if (args.filters[f.name]){
							value = utils.apply(args.filters[f.name], [value].concat(f.params));
						}
					});
				}

				values.push(value);

				return value;
			});

			if (values.length === 1 && isSingle){
				str = values[0];
			}
		}

		return str;
	};

    this.stripTags = function (str, allowedTags){
		// add new-lines to blocks
		str = str
				.replace(/(<br\s*\/?>)/g, "$1\n")
				.replace(/(<\/(?:p|ul|ol|div)>)/g, '$1\n');

		if (!allowedTags){
			str = str.replace(/(<([^>]+)>|<|>)/ig, ' ');
		}else{
			// making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
			allowedTags = ((allowedTags || '') + '').toLowerCase();
			allowedTags = utils.toArray(allowedTags).map(function (v){ return '<' + v + '>'; }).join('');

			var tags 	 = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
			var comments = /<!--[\s\S]*?-->/gi;

			str = str.replace(comments, '').replace(tags, function($0, $1) {
			    return allowedTags.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : ' ';
			});
		}

		return str.trim();
	};

    this.random = function (prefix, separator){
        separator = utils.defined(separator, '_');
		return (prefix ? prefix+separator : '')+utils.toRandom('string');
	};

	this.uuidv4 = function (){
		// @link https://stackoverflow.com/questions/105034/how-to-create-guid-uuid
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
			var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		});
	};
	
	this.md5 = function (str){
		// @source https://stackoverflow.com/questions/14733374/how-to-generate-an-md5-file-hash-in-javascript-node-js
		function M(d){for(var _,m="0123456789ABCDEF",f="",r=0;r<d.length;r++)_=d.charCodeAt(r),f+=m.charAt(_>>>4&15)+m.charAt(15&_);return f}
		function X(d){for(var _=Array(d.length>>2),m=0;m<_.length;m++)_[m]=0;for(m=0;m<8*d.length;m+=8)_[m>>5]|=(255&d.charCodeAt(m/8))<<m%32;return _}
		function V(d){for(var _="",m=0;m<32*d.length;m+=8)_+=String.fromCharCode(d[m>>5]>>>m%32&255);return _}
		function Y(d,_){d[_>>5]|=128<<_%32,d[14+(_+64>>>9<<4)]=_;for(var m=1732584193,f=-271733879,r=-1732584194,i=271733878,n=0;n<d.length;n+=16){var h=m,t=f,g=r,e=i;f=md5_ii(f=md5_ii(f=md5_ii(f=md5_ii(f=md5_hh(f=md5_hh(f=md5_hh(f=md5_hh(f=md5_gg(f=md5_gg(f=md5_gg(f=md5_gg(f=md5_ff(f=md5_ff(f=md5_ff(f=md5_ff(f,r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+0],7,-680876936),f,r,d[n+1],12,-389564586),m,f,d[n+2],17,606105819),i,m,d[n+3],22,-1044525330),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+4],7,-176418897),f,r,d[n+5],12,1200080426),m,f,d[n+6],17,-1473231341),i,m,d[n+7],22,-45705983),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+8],7,1770035416),f,r,d[n+9],12,-1958414417),m,f,d[n+10],17,-42063),i,m,d[n+11],22,-1990404162),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+12],7,1804603682),f,r,d[n+13],12,-40341101),m,f,d[n+14],17,-1502002290),i,m,d[n+15],22,1236535329),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+1],5,-165796510),f,r,d[n+6],9,-1069501632),m,f,d[n+11],14,643717713),i,m,d[n+0],20,-373897302),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+5],5,-701558691),f,r,d[n+10],9,38016083),m,f,d[n+15],14,-660478335),i,m,d[n+4],20,-405537848),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+9],5,568446438),f,r,d[n+14],9,-1019803690),m,f,d[n+3],14,-187363961),i,m,d[n+8],20,1163531501),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+13],5,-1444681467),f,r,d[n+2],9,-51403784),m,f,d[n+7],14,1735328473),i,m,d[n+12],20,-1926607734),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+5],4,-378558),f,r,d[n+8],11,-2022574463),m,f,d[n+11],16,1839030562),i,m,d[n+14],23,-35309556),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+1],4,-1530992060),f,r,d[n+4],11,1272893353),m,f,d[n+7],16,-155497632),i,m,d[n+10],23,-1094730640),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+13],4,681279174),f,r,d[n+0],11,-358537222),m,f,d[n+3],16,-722521979),i,m,d[n+6],23,76029189),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+9],4,-640364487),f,r,d[n+12],11,-421815835),m,f,d[n+15],16,530742520),i,m,d[n+2],23,-995338651),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+0],6,-198630844),f,r,d[n+7],10,1126891415),m,f,d[n+14],15,-1416354905),i,m,d[n+5],21,-57434055),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+12],6,1700485571),f,r,d[n+3],10,-1894986606),m,f,d[n+10],15,-1051523),i,m,d[n+1],21,-2054922799),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+8],6,1873313359),f,r,d[n+15],10,-30611744),m,f,d[n+6],15,-1560198380),i,m,d[n+13],21,1309151649),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+4],6,-145523070),f,r,d[n+11],10,-1120210379),m,f,d[n+2],15,718787259),i,m,d[n+9],21,-343485551),m=safe_add(m,h),f=safe_add(f,t),r=safe_add(r,g),i=safe_add(i,e)}return Array(m,f,r,i)}
		function md5_cmn(d,_,m,f,r,i){return safe_add(bit_rol(safe_add(safe_add(_,d),safe_add(f,i)),r),m)}
		function md5_ff(d,_,m,f,r,i,n){return md5_cmn(_&m|~_&f,d,_,r,i,n)}
		function md5_gg(d,_,m,f,r,i,n){return md5_cmn(_&f|m&~f,d,_,r,i,n)}
		function md5_hh(d,_,m,f,r,i,n){return md5_cmn(_^m^f,d,_,r,i,n)}
		function md5_ii(d,_,m,f,r,i,n){return md5_cmn(m^(_|~f),d,_,r,i,n)}
		function safe_add(d,_){var m=(65535&d)+(65535&_);return(d>>16)+(_>>16)+(m>>16)<<16|65535&m}
		function bit_rol(d,_){return d<<_|d>>>32-_}

		var str = M(V(Y(X(str),8*str.length)));
		return str.toLowerCase();
	};

	this.encodeHtml = function (str){
		var text = STRING.TEXTAREA = STRING.TEXTAREA || document.createElement('textarea');
		text.innerText = str;
		return text.innerHTML;
	};

	this.decodeHtml = function (str){
		var text = STRING.TEXTAREA = STRING.TEXTAREA || document.createElement('textarea');
		text.innerHTML = str;
		return text.value;
	};

	this.decode = this.parseStr = function (str, args){
		if (utils.is.str(args)){
			args = {'separator':args};
		}else if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args          = args || {};
		args.callback = args.callback || null;

		var props = {};
        // @info this will parse the string and turn a pattern into an object (eg.: "key:value, key2:value2" or "key=value&key2=value2")
		if (utils.is.str(str)){
			args.separator 		= 'separator' in args ? args.separator : ',';
			args.pairSeparator 	= 'pairSeparator' in args ? args.pairSeparator : ':';
			args.clean 			= 'clean' in args ? args.clean : true;
			
			// remove the start "{" and "}" wrapping the string
			str = str.trim().replace(/^\{|\}$/g, '').split(args.separator);
			
			for (var i=0, l=str.length; i<l; ++i){
				var prop = str[i].trim();

				if (!prop) continue;

				var pair = prop.split(args.pairSeparator);
				try{
					var key  = pair[0].trim();
					var value= utils.toValue(pair[1].trim(), {'clean':args.clean});
					props[key] = value;

					utils.apply(args.callback, [key, value]);
				}catch (e){}
			}
		}else if (utils.is.obj(str, true)){
			props = str;

			if (utils.is.fn(args.callback)){
				for (var i in props){
					utils.apply(args.callback, [i, prop[i]]);
				}
			}
		}

		return props;
	};
	
	this.decodeStyle = this.decode.style = function (str, args){
		if (utils.is.obj(str)){
			return str;
		}else if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args               = args || {};
		args.separator     = ';';
		args.pairSeparator = ':'
		return utils.string.decode(str, args);
	};

	this.decodeQuery = function (str, args){
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args               = args || {};
		args.separator     = '&';
		args.pairSeparator = '='
		return utils.string.decode(str, args);
	};
	
	this.decodeClassnames = this.decode.classnames = function (str){
		if (utils.is.obj(str)){
			return str;
		}else if (utils.is.fn(args)){
			args = {'callback':args};
		}
		return utils.toArray(str, {'separator':' ', 'unique':true});
	};

	this.decodeSelector = function (str, args){
		args 		= args || {};
		args.single = 'single' in args ? args.single : true;
		
		var i, l, v, p, node;
		var selectors = str.split(' ').map(function (path){
			path = path.match(RE.CSS_SELECTOR) || [];
			i    = 0;
			l    = path.length;

			node = {
				'type' : null,
				'id'   : null,
				'attrs': {},
				'style': {},
				'class': [],
				'value': null,
			};

			for (;i<l;++i){
				v = path[i].slice(1);
				p = path[i][0];

				if (p === '{'){
					v = v.substring(0, v.length-1);
					utils.string.decodeStyle(v, function (i, v){ node.style[i] = v; });
				}else if (p === '['){
					v = v.substring(0, v.length-1);
					utils.string.decodeQuery(v, function (i, v){ node.attrs[i] = v; });
				}else if (p === '#'){
					node.id = v;
				}else if (p === '.'){
					node.class.push(v);
				}else if (p === '='){
				 	node.value = value;
				}else{
				 	node.type = path[i];
				}
			}

			return node;
		});

		return args.single ? selectors[0] : selectors; 
	};

	this.removeAccents = function (str){
		// https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/5912746#5912746
		return str.replace(RE.ACCENTS, function ($1){
			return STRING.ACCENTS_MAP[$1] || $1;
		});
	};

    // casting -----------------------------------------------------------------
    this.toSpaceCase = function (str){
		if (!str) return '';

		return str.replace(RE.SPACE_CASE, function ($1){
			return ' '+$1.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
		}).toLowerCase().trim();
	};

	this.toDashCase = this.toSlug = function (str){
        return utils.string.toSpaceCase(str)
            .replace(/\s/g, '-')
            .replace(/\-+/g, '-');
	};

	this.toUnderscoreCase = function (str){
        return utils.string.toSpaceCase(str)
            .replace(/\s/g, '_');
	};

	this.toSlashCase = function (str){
        return utils.string.toSpaceCase(str)
            .replace(/\s/g, '/');
	};

	this.toCamelCase = function (str, allWords){
		str = utils.string.toSpaceCase(str);
		if (allWords){
			str = ' ' + str;
		}
		return str.replace(/(\s[a-z0-9])/g, function ($1){
			return $1.substring(1).toUpperCase();
		});
    };
    
    this.toRegExp = function (str, args){
		if (utils.is.arr(str) && str.length >= 3){
			args        = args || {};
			args.prefix = str[0];
			args.suffix = str[2];
			str         = str[1];
		}

		args               = args || {};
		args.group         = 'group' in args ? args.group : false;
		args.global 	   = 'global' in args ? args.global : true;
		args.exact 		   = args.exact || false;
		args.prefix 	   = args.prefix || '';
		args.suffix 	   = args.suffix || '';
		args.caseSensitive = 'caseSensitive' in args ? args.caseSensitive : true;
		args.return 	   = 'return' in args ? args.return : 'RegExp';

		str = str.replace(/([-+().*\/\[\]])/g, '\\$1');

		if (args.prefix){
			str = args.prefix + str;
		}
		if (args.suffix){
			str = str + args.suffix;
		}
		if (args.group){
			str = '('+str+')';
		}
		if (args.exact){
			str = '^' + str + '$';
		}

		if (args.return === 'string'){
			return str;
		}else{
			return new RegExp(str, (args.global ? 'g' : '') + (args.caseSensitive ? '' : 'i'))
		}
	};

	this.toNumber = function (str){
		if (utils.is.nbr(str)){
			return str;
		}else if (utils.is.str(str)){
			var nbr = str.replace(/[^0-9-.]/g, '').replace(/(?:(.)\-)/, '$1');
			nbr = parseFloat(nbr);
			return nbr;
		}
		return 0;
	};

    this.toDuration = function (str){
		if (str === null || str === undefined){
			str = 0;
		}

		if (typeof str === 'string'){
			var time = parseFloat(str);

			if (~str.indexOf('min')){
				time *= 60000;
			}else if (~str.indexOf('hour')){
				time *= 3.6e+6;
			}else if (~str.indexOf('day')){
				time *= 8.64e+7;
			}else if (~str.indexOf('week')){
				time *= 6.048e+8;
			}else if (~str.indexOf('month')){
				time *= 2.628e+9;
			}else if (~str.indexOf('year')){
				time *= 3.154e+10;
			}else if (~str.indexOf('ms')){
				time = time;
			}else if (~str.indexOf('s')){
				time *= 1000;
			}
		}else{
            time = str;
        }

		return isNaN(time) ? 0 : time;
	};

	this.toBytes = function (str){
		if (utils.is.nbr(str)){
			return str;
		}

		// @source https://www.codegrepper.com/code-examples/javascript/javascript+file+size+converter
		
		var units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
		var match = utils.string.match(str, /(\d+(?:\.\d+)?)(.+)?/);
		var nbr   = parseFloat(match[0]) || 0;
		var unit  = (match[1] || 'B').toUpperCase();
		var exp   = units.indexOf(unit) || 0;

		return nbr * Math.pow(1024, exp);
	};

    this.toAction = function (str, args){
		if (typeof str !== 'string'){
			return null;
		}

        args                   = args || {};
        args.modifierSeparator = 'modifierSeparator' in args ? args.modifierSeparator : ':';
        args.typeSeparator     = 'typeSeparator' in args ? args.typeSeparator : '.';
        args.context           = 'context' in args ? args.context : null;
		args.wrapText 		   = 'wrapText' in args ? args.wrapText : false;

		var name 		= str;
		var type 		= null;
		var params  	= null;
		var modifiers 	= {};
		var filters 	= [];

		if (!!~name.indexOf(args.modifierSeparator) || utils.is.re(args.modifierSeparator)){
			var modifiers = name.split(args.modifierSeparator);
			name = modifiers.shift().trim();

			var items = {};
			for (var i=0, l=modifiers.length; i<l; ++i){
				var modifier 	= modifiers[i];
				var match 		= modifier.match(RE.CALLBACK_PARAMS);
				var key 		= match ? (match[1] || '').trim() : null;

				if (!key) continue;

				var values = utils.toValues(match[2], {'context':args.context, 'wrap':args.wrapText});

				filters.push({
					'name'  : key,
					'values': values,
					'raw'	: match[2],
				});

				items[key] = values[0];
			}
			modifiers = items;
		}

		if (!!~name.indexOf(args.typeSeparator)){
			var pair = name.split(args.typeSeparator);
			name = pair[0];
			type = pair[1];
		}

		var action = name;
		var match  = name.match(RE.CALLBACK_PARAMS);
		if (match){
			name   = match[1];
			params = utils.toValues(match[2] || null, {'context':args.context});
		}

		return {
			'action'	: action,
			'name'    	: name,
			'type'		: type,
			'params'    : params,
			'modifiers' : modifiers,
			'filters'	: filters,
		};
	};

	this.toCss = function (str){
		var css = {};
		
		str = str.replace(RE.COMMENTS, '');
		this.match(str, RE.CSS, function (m, $1, $2){
			var selector = $1.trim();
			
			$2.split(';').forEach(function (p){
				p = p.trim();

				if (!p) return;
				var pair  = p.split(':');
				var key   = pair[0].trim();
				var value = pair[1].trim();

				if (!css[selector]){
					css[selector] = {};
				}

				css[selector][key] = value;
			});
		});

		return css;
	};

	this.toTimeline = function (from, to, total, args){
		if (utils.is.str(args)){
			args = {'fill':args};
		}else if (utils.is.nbr(args)){
			args = {'length':args};
		}

		args       = args || {};
		args.empty = 'empty' in args ? args.empty : '⋅';
		args.fill  = 'fill' in args ? args.fill : '█';
		args.length= 'length' in args ? args.length : 50;

		from = (from / total) * args.length | 0;
		to   = (to / total) * args.length | 0;

		return (from > 0 ? utils.string.repeat(args.empty, from) : '') + 
			utils.string.repeat(args.fill, to - from) + 
			(to < args.length ? utils.string.repeat(args.empty, args.length - to) : '');
	};

	// aliases -----------------------------------------------------------------
	this.toStyle      = this.decodeStyle;
	this.toClassnames = this.decodeStyle;
});
Utils.add('number', function (utils, NUMBER){
    // consts ------------------------------------------------------------------
	NUMBER.SEPARATORS = {
		'en-US' : {'decimal':'.', 'group':','},
		'fr-CA' : {'decimal':',', 'group':' '},
		'pt-BR' : {'decimal':',', 'group':'.'},
	};

	NUMBER.THOUSANDS = [
		{ value: 1e18, unit: "E" },
		{ value: 1e15, unit: "P" },
		{ value: 1e12, unit: "T" },
		{ value: 1e9, unit: "G" },
		{ value: 1e6, unit: "M" },
		{ value: 1e3, unit: "k" },
		{ value: 1, unit: "" },
	];

    // methods -----------------------------------------------------------------
    this.decimals = function (nbr, count){
		if (count === undefined){
			var str = nbr.toString();
            var nbr = Math.floor(parseFloat(nbr) || 0).toString();

            if (!isNaN(nbr) && nbr !== str){
                var pair = str.split(".");
                return (pair[1] && pair[1].length) || 0;
            }

            return 0;
		}else{
			if (count === true){
                count = 2;
            }
            nbr = parseFloat(nbr) || 0;
            return parseFloat(nbr.toFixed(count));
		}
    };

	this.separators = function (locale, type){
		locale = locale || document.documentElement.lang || navigator.language;

		if (NUMBER.SEPARATORS[locale] === undefined && window.Intl){
			var nbr     = 1000.1;
			var decimal = '';
			var group   = '';

			try{
				var parts = Intl.NumberFormat(locale || undefined).formatToParts(nbr);
				var i, l;

				for (i=0, l=parts.length; i<l; ++i){
					var part = parts[i];

					switch (part.type){
						case 'decimal'	: decimal = part.value; break;
						case 'group'	: group = part.value; break;
					}
				}
			}catch (e){
				decimal = '.';
				group   = ',';
			}

			
			NUMBER.SEPARATORS[locale] = {
				'decimal' : decimal || '.',
				'group'   : group || '',
			};
		}

		var separators = NUMBER.SEPARATORS[locale] || NUMBER.SEPARATORS['en-US'];
		return type ? separators[type] : separators;
	};

    this.format = function (nbr, args){
		if (utils.is.either(args, 'arr,nbr')){
			args = {'decimals':args};
		}

		args            = args || {};
		args.locale     = args.locale || null;
		args.negative   = 'negative' in args ? args.negative : null;        // forced negative/positive
		args.decimals   = 'decimals' in args ? args.decimals : true;        // count / {count:?, min:?, max:?, empty:false}
		args.separators = args.separators || this.separators[args.locale];	// {decimal:?, group:?}
		args.thousands  = args.thousands || false;                          // true / false / decimals.  format with suffix (k, M, G, ....) when it's bigger than 1000 (1000 = 1k)
		args.zeros 		= args.zeros || false;								// keep the prefix 0 to number, or suffix 0 for deicmals
		args.template 	= args.template || null;							// for text like {{ value }}%
		args.fallback   = 'fallback' in args ? args.fallback : '';
		
		var hasDecimalSeparator = false;
		var zeroPrefix          = '';
		var zeroSuffix          = '';
		if (utils.is.str(nbr)){
			// @todo try decoding with the locale
			nbr = nbr.replace(/[^0-9-.]/g, '').replace(/\.+/, '.').replace(/(?:(.)\-)/, '$1');

			hasDecimalSeparator = !!utils.string.match(nbr, /(\.$)/, true);
			zeroPrefix          = (utils.string.match(nbr, /^(?:-?(0+)[^0]?)/, true) || '').length;
			zeroSuffix          = (utils.string.match(nbr, /(?:\.[0-9]*?(0+))$/, true) || '').length;
			nbr 				= parseFloat(nbr);
			
			// console.log({nbr, zeroPrefix, hasDecimalSeparator, zeroSuffix});
			
			if ((nbr | 0) === 0 && zeroPrefix){
				zeroPrefix--;
			}

			zeroPrefix = utils.string.repeat('0', zeroPrefix);
			zeroSuffix = utils.string.repeat('0', zeroSuffix);
		}

		if (isNaN(nbr)){
			return args.fallback;
		}

		var prefix     = nbr < 0 ? '-' : '';
		var suffix 	   = '';
		var value      = Math.abs(nbr);
		var decimals   = utils.args(args.decimals, {'count':true, 'min':0, 'max':0, 'empty':false}, 'count');
		var separators = utils.args(args.separators, {'decimal':'.', 'group':','}, 'decimal');

		if (args.thousands !== false){
			// @source https://stackoverflow.com/questions/9461621/format-a-number-as-2-5k-if-a-thousand-or-more-otherwise-900
			var i=0, l=NUMBER.THOUSANDS.length, t;
			for (; i<l; ++i){
				t = NUMBER.THOUSANDS[i];
				if (value > t.value){
					value  = value / t.value;
					suffix = t.unit;
					break;
				}
			}

			// limit the decimals for the 
			if (utils.is.nbr(args.thousands)){
				decimals.max = args.thousands;
			}else if (args.thousands === true){
				decimals.max = 0;
			}
		}

		// forced negative/positive
		if (utils.is.bool(args.negative)){
			prefix = args.negative ? '-' : '';
		}
		
		// decimal count
		var count = decimals.count;
		if (count === true){
			count = utils.number.decimals(value);
		}else if (count === false){
			count = 0;
		}

		if (decimals.max && count > decimals.max){
			count = decimals.max;
		}
		if (decimals.min && count < decimals.min){
			count = decimals.min;
		}

		var d = (value % 1).toFixed(count).slice(2) + (args.zeros ? zeroSuffix : '');  // decimals
		var n = (args.zeros ? zeroPrefix : '') + parseInt(value).toString();           // number
		var o = n.length > 3 ? n.length % 3 : 0;      // overhead of numbers (over the 1000)

		value = prefix +
				(o ? n.slice(0, o) + separators.group : '') +
				n.slice(o).replace(/(\d{3})(?=\d)/g, "$1" + separators.group) +
				(
					(d ? (separators.decimal + d) : '') ||
					(!d && hasDecimalSeparator && decimals.empty ? separators.decimal : '')	// keep the separator, even if there's no decimals
				) +
				suffix;

		if (args.template){
			value = utils.string.replace(args.template, {'value':value});
		}

		return value;
    };

	this.toPercent = function (nbr, args){
		args          = (typeof args === 'number' ? {'decimals':args} : args) || {};
        args.base     = 'base' in args ? args.base : 100;
        args.decimals = args.decimals || 0;

        nbr = nbr / args.base * 100;
		nbr = utils.number.decimals(nbr, args.decimals);
		
		return nbr + '%';
	};

    // casting -----------------------------------------------------------------


	this.toDuration = function (time){
		if (!utils.is.nbr(time)){
			return time;
		}
		if (time === null || time === undefined){
			time = 1000;
		}
		return Math.round(time / 10)/100 + 's';
	};

	this.toFraction = function (ratio){
		// @source https://stackoverflow.com/questions/23575218/convert-decimal-number-to-fraction-in-javascript-or-closest-fraction
		function _gcd (a, b) {
			if (b < 0.0000001) return a;
			return _gcd(b, Math.floor(a % b));
		};

		var len         = ratio.toString().length - 2;
		var denominator = Math.pow(10, len);
		var numerator   = ratio * denominator;
		var divisor     = _gcd(numerator, denominator);

		numerator   /= divisor;
		numerator	 = Math.floor(numerator);
		denominator /= divisor;
		denominator	 = Math.floor(denominator);

		return numerator + '/' + denominator;
	};

	this.toTime = function (nbr){
		var isNegative = nbr < 0;

		nbr = Math.abs(nbr);

		var hours   = Math.floor(nbr / 3600);
		var minutes = Math.floor(nbr / 60 % 60);
		var seconds = Math.floor(nbr % 60);

		if (seconds < 10){
			seconds = '0' + seconds; 
		}
		if (hours && minutes < 10){
			minutes = '0' + minutes; 
		}

		return (isNegative ? '-' : '') + (hours ? hours + ":" : '') + minutes + ':' + seconds;  
	};

	this.toUnit = function (nbr, unit){
		unit = unit || '';
		if (utils.is.numeric(nbr)){
			return nbr + unit;
		}else{
			return nbr;
		}
	};
});

Utils.add('math', function (utils, MATH, RE){
    // consts ------------------------------------------------------------------

    // methods -----------------------------------------------------------------
    this.get = function (nbr, args){
		args 				= (typeof args === 'number' ? {'max':args} : args) || {};
		args.min 			= 'min' in args ? args.min : -Infinity;
		args.max 			= 'max' in args ? args.max : Infinity;
		args.current		= 'current' in args ? args.current : 0;
		args.loop			= 'loop' in args ? args.loop : null;
		args.decimals 		= args.decimals !== undefined ? args.decimals : true;
		args.overflow 		= 'overflow' in args ? args.overflow : null;
		args.fallback 		= 'fallback' in args ? args.fallback : nbr;

		if ('outOfBounds' in args){
			utils.deprecated('math.get -> outOfBounds', 'overflow');
			args.overflow = args.outOfBounds;
		}

		var hasLimits = isFinite(args.min) || isFinite(args.max);
		if (args.overflow === null){
			args.overflow = hasLimits ? false : true;
		}

		var min = isFinite(args.min) ? args.min : 0;
		var max = isFinite(args.max) ? args.max : min;

		// flip min and max if wrong side
		if (min > max){
			min = [max, max = min][0];
		}

		var length = max - min;

		// @todo review this code with the min/max, to make sure it work properly
		
		// if there's a prefix ":", remove it (it keeps it standard to do ":start" for example)
		if (utils.is.str(nbr) && nbr[0] == ':'){
			nbr = nbr.slice(1);
		}

		if (nbr === 'start' || nbr === 'first' || nbr === 'left' || nbr === 'top'){
			nbr = min;
		}else if (nbr === 'end' || nbr === 'last' || nbr === 'right' || nbr === 'bottom'){
			nbr = max;
		}else if (nbr === 'middle' || nbr === 'center'){
			nbr = min + length/2;
		}else if (nbr === 'next'){
			nbr = args.current + 1;
		}else if (nbr === 'previous'){
			nbr = args.current - 1;
		}else if (nbr === 'random' || nbr === '?'){
			nbr = hasLimits ? min + (Math.random() * length) : Math.random();
		}else if (nbr === null){
			nbr = args.fallback;
		}else if (typeof nbr === 'object' && nbr.ratio !== undefined){
			nbr = min + (nbr.ratio * length);
		}else if (typeof nbr === 'string' && !!~nbr.indexOf('%')){
			nbr = parseFloat(nbr)/100;
			nbr = min + (nbr * length);
		}else if (!isNaN(nbr)){
			nbr = parseFloat(nbr);
		}
		
		if (typeof nbr === 'number'){
			if (!args.decimals){
				nbr = Math.round(nbr);
			}

			if (args.loop){
				if (nbr < min){
					nbr = (max + 1) + ((nbr - min) % (length + 1));
				}
				if (nbr > max){
					nbr = min + ((nbr - min) % (length + 1));
				}
			}

			if (!args.overflow){
				if (nbr < min){
					nbr = min;
				}
				if (nbr > max){
					nbr = max;
				}
			}
		}

		return isNaN(nbr) ? args.fallback : nbr;
	};

	this.sign = function (nbr){
		return nbr < 0 ? -1 : (nbr > 0 ? 1 : 0);
	};

	this.min = function (a, b){
		if (isNaN(a)) a = Infinity;
		if (isNaN(b)) b = Infinity;
		return Math.min(a, b) || 0;
	};

	this.max = function (a, b){
		if (isNaN(a)) a = -Infinity;
		if (isNaN(b)) b = -Infinity;
		return Math.max(a, b) || 0;
	};

	this.sum = function (values){
		values = utils.toArray(values instanceof Array ? values : arguments);

		var nbr = 0;
		utils.each(values, function (v){
			nbr += utils.is.nbr(v) ? v : 0;
		});

		return nbr;
	};

    this.clamp = function (nbr, min, max, priority){
		priority = priority || 'min';

		if (min === undefined && max === undefined){
			min = 0;
			max = 1;
		}
		if (max === undefined){
			max = min;
			min = 0;
		}

		if (priority === 'max'){
			return Math.min(Math.max(min, nbr), max);
		}else{
			return Math.max(Math.min(max, nbr), min);
		}
    };

	this.between = function (nbr, min, max){
		if (min > max){
			min = [max, min = max][0];
		}
		return nbr >= min && nbr <= max;
	};

    this.loop = function (nbr, min, max){
		return utils.math.get(nbr, {
			'min' : min,
			'max' : max,
			'loop': true,
		});
    };
    
    this.steps = function (nbr, steps){
		return Math.floor(nbr / steps) * steps;
    };

    this.random = function (min, max){
        max = max || 0;
        
        if (max < min){
            min = [max, max = min][0];
        }

		return utils.math.get('?', {'min':min, 'max':max});
	};
    
    this.lerp = this.mid = function (min, max, ratio){
        ratio = ratio === undefined ? 0.5 : ratio;
		ratio = utils.calculate(ratio);
		return min + (max - min) * ratio;
	};

	this.map = function (nbr, from, to, from2, to2){
		// taking into consideration nbr is a ratio, from = 0 and to = 1
		if (from2 === undefined && to2 === undefined){
			from2 = from;
			to2   = to;
			from  = 0;
			to    = 1;
		}

		var r = this.toRatio(nbr, from, to);
		var v = this.lerp(from2, to2, r);
		return v;
	};

    this.align = function (nbr, max, ratio){
        // @info align an item and needs to be contained in the container size
        ratio = ratio === undefined ? 0.5 : ratio;

		if (ratio === 'start' || ratio === 'top' || ratio === 'left'){
			ratio = 0;
		}else if (ratio === 'end' || ratio === 'bottom' || ratio === 'right'){
			ratio = 1;
		}else if (ratio === 'middle' || ratio === 'center'){
			ratio = 0.5;
		}

		return (max - nbr) * ratio;
    };
    
    this.contain = function (rect, container, args){
        args        = args || {};
        args.resize = 'resize' in args ? args.resize : false;

		rect 		= utils.math.toRect(rect);
		container 	= utils.math.toRect(container);

		var dx = 0;
		var dy = 0;

		if (args.resize){
            rect = utils.math.toRect([
                rect.x,
                rect.y,
                Math.min(rect.width, container.width),
                Math.min(rect.height, container.height),
            ]); 
		}

		// x 
		if (rect.left < container.left){
			dx = container.left - rect.left;
		}else if (rect.right > container.right){
			dx = container.right - rect.right;
		}
		
		// y
		if (rect.top < container.top){
			dy = container.top - rect.top;
		}else if (rect.bottom > container.bottom){
			dy = container.bottom - rect.bottom;
		}		

		return {
			'dx'    : dx,
			'dy'    : dy,
			'x'     : rect.x + dx,
			'y'     : rect.y + dy,
			'width' : rect.width,
			'height': rect.height,
		}
    };

    this.ratio = function (from, to, ratio, easing){
		var value = null;
		var range = null;

		if (typeof from === 'object'){
			easing   = ratio;
			ratio    = to;
			range    = from;
			from 	 = null;
			to 		 = null;
		}

		easing= utils._easing(easing);
		ratio = ratio || 0;
		ratio = easing(ratio);
		
		// range of values (ex.: [0,1,1,1,0] OR {0:0, 0.2:1, 0.8:1, 0.9:0})
		if (range){
			var values = [];
			var isArray= range instanceof Array;
            var i, l, r, prev, next;

			for (i in range){
                r = parseFloat(i);
                r = isArray ? r / (range.length-1) : r;
				values.push({'ratio':r, 'value':range[i]});
			}

			if (values.length){
				values.sort(function (a, b){ 
                    return a.ratio - b.ratio; 
                });

				// make sure there's a 0 and 1 ratio
				if (values[0].ratio !== 0){
					values.unshift({'ratio':0, 'value':values[0].value});
				}
				var last = values.length-1;
				if (values[last].ratio !== 1){
					values.push({'ratio':1, 'value':values[last].value});
				}

				for (i=1, l=values.length; i<l; ++i){
					prev = values[i-1];
					next = values[i];

					// in between 2 values
					if (ratio >= prev.ratio && ratio < next.ratio){
						r     = (ratio - prev.ratio) / (next.ratio - prev.ratio);
						value = prev.value + (next.value - prev.value) * r;
						break;
					}else if (ratio < prev.ratio){
						value = prev.value;
						break;
					}else if (ratio >= next.ratio){
						value = next.value;
					}
				}
			}
		}else{
			from = parseFloat(from);
			to   = parseFloat(to);
			value= from + (to - from) * ratio;
		}

		return value;
	};

	this.ratioSub = this.ratio.sub = function (from, to, ratio, args){
		args     = args || {};
		args.mid = 'mid' in args ? args.mid : 0;	// @info favoritise the start/end ratio when between 2 ratios

        from = utils.is.percent(from) ? parseFloat(from) / 100 : from;
        to   = utils.is.percent(to) ? parseFloat(to) / 100 : to;

		// mid point : 0 -> 1 -> 0
		var r = (ratio - from) / (to - from);
		if (args.mid){
			var mid = args.mid === true ? 0.5 : args.mid;

			if (r <= 0 || r >= 1){
				r = 0;
			}else if (r >= mid){
				r = 1 - (r - mid) / (1 - mid);
			}else{
				r = r / mid;
			}
		}else{
			if (r <= 0){
				r = 0;
			}else if (r >= 1){
				r = 1;
			}
		}

		return r;
	};

	this.ratioStagger = this.ratio.stagger = function (index, length, ratio, wait){
		wait  = wait || 0;
		ratio = ratio || 0;

		var waitRatio   = wait/(length-1) || 0;
		var itemRatio 	= 1 / length * (1-wait);
		var startRatio 	= index * (itemRatio + waitRatio);
		var endRatio 	= startRatio + itemRatio;
		ratio           = utils.math.ratio.sub(startRatio, endRatio, ratio);

		return {
			'start': startRatio,
			'end'  : endRatio,
			'wait' : waitRatio,
			'item' : itemRatio,
			'ratio': ratio,
		};
	};
    
    // condition ---------------------------------------------------------------

    
    // casting -----------------------------------------------------------------
    this.toMinMax = function (values){
		var min = Infinity;
		var max = -Infinity;

        var self = {
            'min': 0,
            'max': 0,
            'add': _add,
        };

		function _add (v){
			min = utils.math.min(min, v);
			max = utils.math.max(max, v);
			self.min = isFinite(min) ? min : 0;
			self.max = isFinite(max) ? max : 0;
		};

		if (values !== undefined){
			values = values instanceof Array ? values : arguments;
			
			var v, i=0;
			while ((v = values[i++]) !== undefined){
				self.add(v);
			}
		}

		return self;
    };
        
	this.toRectByPoints = function (points, args){
        args         = args || {};
        args.offsetX = args.offsetX || 0;
        args.offsetY = args.offsetY || 0;
        args.margin  = utils.array.to4Numbers(args.margin || 0);

		var top 	= Infinity;
		var right 	= -Infinity;
		var bottom 	= -Infinity;
		var left 	= Infinity;
		var self    = {
			'x'		: 0,
			'y'		: 0,
			'top'	: 0,
			'right'	: 0,
			'bottom': 0,
			'left'	: 0,
			'width' : 0,
			'height': 0,
			'add'	: _add,
		};

		function _add (point){
			if (!utils.is.arr(point) && !utils.has(point, 'x,y,width,height')) return;

			point 	= utils.math.toRect(point);
			top 	= Math.min(top, point.y);
			right 	= Math.max(right, point.x + point.width);
			bottom 	= Math.max(bottom, point.y + point.height);
			left 	= Math.min(left, point.x);

			self.top    = self.y = (isFinite(top) ? top : 0) + args.offsetY + args.margin[0];
			self.right  = (isFinite(right) ? right : 0) + args.offsetX - args.margin[1];
			self.bottom = (isFinite(bottom) ? bottom : 0) + args.offsetY - args.margin[2];
			self.left   = self.x = (isFinite(left) ? left : 0) + args.offsetX + args.margin[3];
			self.width  = self.right - self.left;
			self.height = self.bottom - self.top;
		}

        for (var i in points){
			_add(points[i]);
        }

		return self;
	};

    this.toXY = function (nbr, columns, args){
		args      = args || {};
		args.axis = 'axis' in args ? args.axis : 'horizontal';

		nbr     = nbr || 0;
		columns = columns || 1;

        var xy = {
			'x' : nbr % columns,
			'y'	: Math.floor(nbr / columns),
		};
        
		if (args.axis === 'vertical'){
			xy.x = [xy.y, xy.y = xy.x][0];
		}

		xy[0] = xy.x;
        xy[1] = xy.y;

		return xy;
    };

    this.toFrames = function (duration, fps){
		duration = utils.string.toDuration(duration);
		return (duration / 1000) * (fps || 60);
	};

    this.toRatio = function (nbr, min, max, isContained, easing){
		if (utils.is.bool(max)){
			isContained = max;
			max         = min;
			min         = 0;
		}

		if (max === undefined){
			max = min;
			min = 0;
		}

		if (isContained){
			if (nbr < min){
				nbr = min;
			}else if (nbr > max){
				nbr = max;
			}
		}

		var r = (nbr - min) / (max - min);
		if (easing){
			easing = utils._easing(easing);
			r 	   = easing(r);
		}

		return r;
	};
	
    this.toPoint = function (x, y, z){
		if (x instanceof Array){
			z = x[2];
			y = x[1];
			x = x[0];
		}else if (typeof x === 'object'){
			var o = x;
			x = 'x' in o ? o.x : 'left' in o ? o.left : 0;
			y = 'y' in o ? o.y : 'top' in o ? o.top : 0;
			z = 'z' in o ? o.z : 'depth' in o ? o.depth : 0;
		}

		x = x || 0;
		y = y || 0;
		z = z || 0;

		return {
			'x' : x,
			'y' : y,
			'z' : z,
		}
	};

	this.toRect = function (x, y, w, h){
		if (x instanceof Array){
			h = x[3];
			w = x[2];
			y = x[1];
			x = x[0];
		}else if (typeof x === 'object'){
			var o = x;
			x = 'x' in o ? o.x : 'left' in o ? o.left : 0;
			y = 'y' in o ? o.y : 'top' in o ? o.top : 0;
			w = 'width' in o ? o.width : 'right' in o ? o.right - x : 0;
			h = 'height' in o ? o.height : 'bottom' in o ? o.bottom - y : 0;
		}

		x = x || 0;
		y = y || 0;
		w = w || 0;
		h = h || 0;

		return {
			'x' 	: x,
			'y' 	: y,
			'top'	: y,
			'right' : x + w,
			'bottom': y + h,
			'left'	: x,
 			'width' : w,
			'height': h,
		}
	};

	this.toBounds = function (data, args){
		args 		 = args || {};
		args.offsetX = 'offsetX' in args ? args.offsetX : 0;
		args.offsetY = 'offsetY' in args ? args.offsetY : 0;
		args.padding = 'padding' in args ? args.padding : null;
		args.margin  = 'margin' in args ? args.margin : null;
		
		var p;
		if (args.margin){
			p = utils.array.to4Numbers(args.margin || 0).map(function (v){ return -v; });
		}else if (args.padding){
			p = utils.array.to4Numbers(args.padding || 0);
		}else{
            p = [0,0,0,0];
        }

		var x = 0;
		var y = 0;
		var w = 0;
		var h = 0;

		if (data instanceof Array){
			x = data[0] || 0;
			y = data[1] || 0;
			w = data[2] || 0;
			h = data[3] || 0;
		}else if (typeof data === 'object'){
			if ('x' in data) 			x = data.x;
			else if ('x1' in data) 		x = data.x1;
			else if ('left' in data) 	x = data.left;

			if ('y' in data) 			y = data.y;
			else if ('y1' in data) 		y = data.y1;
			else if ('top' in data) 	y = data.top;
			
			if ('w' in data) 			w = data.w;
			else if ('width' in data)	w = data.width;
			else if ('x2' in data) 		w = data.x2 - x;
			else if ('right' in data) 	w = data.right - x;

			if ('h' in data) 			h = data.h;
			else if ('height' in data)	h = data.height;
			else if ('y2' in data) 		h = data.y2 - y;
			else if ('bottom' in data) 	h = data.bottom - y;
			
			/*
			x = 'x' in data ? data.x : 'left' in data ? data.left : 0;
			y = 'y' in data ? data.y : 'top' in data ? data.top : 0;
			w = 'w' in data ? data.w : 'width' in data ? data.width : 'right' in data ? data.right - x : 0;
			h = 'h' in data ? data.h : 'height' in data ? data.height : 'bottom' in data ? data.bottom - y : 0;
			//*/

			// radius for circles
			if ('radius' in data){
				x -= data.radius;
				y -= data.radius;
				w = data.radius * 2;
				h = data.radius * 2;
			}
		}

		x = (isFinite(x) ? x : 0) + p[3] + args.offsetX;
		y = (isFinite(y) ? y : 0) + p[0] + args.offsetY;
		w = (isFinite(w) ? w : 0) - (p[3] + p[1]);
		h = (isFinite(h) ? h : 0) - (p[0] + p[2]);

		// make sure the height/width are not negative
		if (h < 0) h = 0;
		if (w < 0) w = 0;

		var cx = x + (w / 2);
		var cy = y + (h / 2);
		
		return {
			'top'	 : y,
			'right'	 : x + w,
			'bottom' : y + h,
			'left'   : x,
			'x'		 : x,
			'y'		 : y,
			'width'	 : w,
			'height' : h,
			'centerX': cx,
			'centerY': cy,
			'center' :{'x':cx, 'y':cy}
		};
	};

    this.toPointInRect = function (rect, position, reset){
		rect 	 = utils.math.toRect(rect);
		rect     = reset ? utils.math.toRect([0,0,rect.width,rect.height]) : rect;
		position = position instanceof Array ? position.join(' ') : position.toString();
		
		var positionXY = position.split(' ');
		var positionX  = ~position.indexOf('left') ? '0%' :
						 ~position.indexOf('center') ? '50%' :
						 ~position.indexOf('right') ? '100%' :
                         positionXY[0];
                         
		var positionY  = ~position.indexOf('top') ? '0%' :
						 ~position.indexOf('middle') ? '50%' :
						 ~position.indexOf('bottom') ? '100%' :
						 positionXY[1];

		positionX = (positionX || '').toString().replace(/[^0-9\.\-\%]/g, '') || '0%';
		positionY = (positionY || '').toString().replace(/[^0-9\.\-\%]/g, '') || '0%';
		positionX = utils.math.get(positionX, {'max':rect.width, 'fallback':null});
		positionY = utils.math.get(positionY, {'max':rect.height, 'fallback':null});

		if (positionX !== null) positionX += rect.x;
		if (positionY !== null) positionY += rect.y;

		return {
			'x'	: positionX,
			'y' : positionY,
		}
	};

    this.toColumnSizes = function (size, count, gap, columnSize){
		// need to at least have 1 item
        count = !count || count < 1 ? 1 : count;
        gap         = gap || 0;
        columnSize  = columnSize || 0;

		if (gap && columnSize){
			size = count * (gap + columnSize) - gap;
		}else if (gap){
			columnSize = ((size + gap) / count) - gap;
		}else if (columnSize){
			gap = (size - (count * columnSize)) / (count-1);
		}else{
			columnSize = size / count;
		}

		gap        = gap < 0 ? 0 : gap;
		columnSize = columnSize < 0 ? 0 : columnSize;
		size       = size < 0 ? 0 : size;

		// make sure the max isn't at 0
		if (size < columnSize){
			size = columnSize;
		}

		function _get (count){
			return count * (columnSize + gap) - gap;
		}

		return {
			'gap'        : gap,
			'column'     : columnSize,
			'columnGap'	 : columnSize + gap,
			'size'       : size,			
			'countColumn': count,
			'countGap'	 : count - 1,	
			'totalColumn': columnSize * count,
			'totalGap'   : gap * (count - 1),
			'get'		 : _get,
		};
    };
});

Utils.add(function (utils, CONSTS){
	this.math.probability = function (weights){
		var total    = 0;
		var items    = [];
		var found    = null;
		var isArray	 = weights instanceof Array;

		for (var i in weights){
			var weight 	= parseFloat(isArray ? weights[i].weight : i);
			var value 	= isArray ? weights[i].value : weights[i];

			items.push({
				'weight': weight,
				'value'	: value,
			});

			total += weight;
		}

		var index 	= Math.random() * total;
		var sum 	= 0;
		for (var i=0, l=items.length; i<l; ++i){
			var item = items[i];
			var next = sum + item.weight;

			if (index <= next){
				found = item;
				break;
			}

			sum = next;
		}

		return found ? found.value : null;
    };
    
    this.math.nearest = function (nbr, arr, args){
		args 		= args || {};
		args.get	= 'get' in args ? args.get : null;
		args.near	= 'near' in args ? args.near : 'mid';
		args.return = 'return' in args ? args.return : null;

		// special array
		var list = [];
		for (var i in arr){
			var item  = arr[i];
			var value = typeof args.get === 'function' ? args.get(item, i) :
						args.get ? item[args.get] :
						item;

			list.push({
				'value' : value,
				'item'	: item
			});
		}

		// order items
		list.sort(function (a, b){
			return a.value - b.value;
		});

		// the array needs to be in the right order
		var index 	= -1;

		// extermities
		var first   = list[0].value;
		var last    = list[list.length-1].value;
		var from 	= -1;
		var to 	 	= -1;

		if (nbr <= first){
			index = 0;
			from  = 0;
			to    = 1;
		}else if (nbr >= last){
			index = list.length-1;
			from  = index;
			to    = index - 1;
		}else{
			for (var i=1, l=list.length; i<l; ++i){
				var prev = list[i-1].value;
				var next = list[i].value;

				if (nbr >= prev && nbr <= next){
					if (args.near === 'previous'){
						index = i-1;
					}else if (args.near === 'next'){
						index = i;
					}else{
						// will automatically chose the nearest
						var diffPrev = nbr - prev;
						var diffNext = next - nbr;

						if (diffPrev < diffNext){
							index = i-1;
							from  = i-1;
							to 	  = i;
						}else{
							index = i;
							from  = i;
							to 	  = i + 1;
						}
					}
				}
			}
		}

		if (args.return === 'index'){
			return index;
		}else if (args.return === 'ratio'){

			//return list[index] ? [list[from].item, list[from].item, list[index]] : null;
			/*
			if (list[index] && index === 0){
				return [list[index].item, list[index+1].item];
			}else if (list[index] && index === list.length-1){
				return [list[index-1].item, list[index].item];
			}else if (list[index]){
				return [list[index-1].item, list[index].item];
			}else{
				return null;
			}
			*/
		}else if (args.return === 'value'){
			return list[index] ? list[index].value : null;
		}else{
			return list[index] ? list[index].item : null;
		}
	};
});
Utils.add('fn', function (utils, FN, RE){
    // consts ------------------------------------------------------------------
	RE.SUPER 			= /xyz/.test(function(){xyz;}) ? /\.\$super\(/ : /.*/;
	RE.TWEEN_VARS 		= /\{\{(.+?)\}\}/g;										// "test {{10.1}}%"
	RE.TWEEN_NOT_NUMBER = /[^0-9.-]/g;
	RE.TWEEN_NUMERIC 	= /(([^0-9- ]+)?-?[0-9,]*\.?[0-9]+(?:e[-+]?\d+)?)([^, ]+)?/g;
	RE.TWEEN_PATHS 		= /^(?:([astvzqmhlc])(?:([0-9,.-]|\s)+)){2,}$/gi;
	RE.TWEEN_POINTS 	= /^((?:\s?)(-?\d*(\.\d+)?,-?\d*(\.\d+)?))+$/g;

	FN.WRAP_KEY = KEY || '▓▓▓';
	FN.ONCES 	= [];
	FN.WHEN   	= {};

    // methods -----------------------------------------------------------------
	this.empty = function (v){ return v; };
	
	this.prepare = function (){
		var self 		= this;
		var args 		= utils.toArray(arguments);
		var callback 	= args.shift();

		return function (){
			var a = utils.toArray(arguments);
			return callback.apply(self, args.concat(a));
		};
	};

	this.once = function (name, callback){
		if (utils.is.fn(name)){
			callback = name;
			name     = null;
		}

		var key = name || callback;
		if (!~FN.ONCES.indexOf(key)){
			FN.ONCES.push(key);
			callback();
		}
	};

	this.super = function (callback, superCallback){
		if (typeof callback === 'function' && typeof superCallback === 'function' && RE.SUPER.test(callback)){
			return function (){
				var old = this.$super;
				// gotta fix the bug with infinite loop of $super();
				this.$super = superCallback;

				var response = callback.apply(this, arguments);

				if (old){
					this.$super = old;
				}else{
					delete(this$super);
				}

				return response;
			}
		}else{
			return callback;
		}
	};

	// grouping ----------------------------------------------------------------
	// create a queue system
	this.queue = function (){
		// ({args}, callback1, callback2, callback...)
		// ({args}, [callbacks])
		// (callback1, callback2, callback...)
		// ([callbacks])
		// callbacks are : function, duration or true

		var args      = {};
		var callbacks = utils.toArray(arguments);
		if (utils.is.obj(callbacks[0], true)){
			args = callbacks.shift();
		}else if (utils.is.bool(callbacks[0])){
			args = callbacks.shift();
			args = {'now':args};
		}
		if (utils.is.arr(callbacks[0])){
			callbacks = callbacks[0];
		}

		args.context      = args.context || null;
		args.params       = args.params || [];
		args.onComplete   = args.onComplete || null;
		args.onEach 	  = args.onEach || null;
		args.onError 	  = args.onError || null;
		args.wait         = 'wait' in args ? utils.string.toDuration(args.wait || 0) : null;	// will call all the callbacks simultaneous (with a wait if set to higher than 0)
		args.now          = 'now' in args ? args.now : true;					
		args.reset 		  = 'reset' in args ? args.reset : false;								// reset the index back to 0 on completed

		// @todo maybe add a "catch" callback
		var value       = args.params[0];
		var index       = 0;
		var doneCount 	= 0;
		var isCancelled = false;

		function _done (){
			doneCount++;

			var v = arguments.length ? arguments[0] : value;
			var i = doneCount;
			var t = callbacks.length;

			if (doneCount >= callbacks.length){
				utils.apply(args.onComplete, [v, i, t], args.context);
			}else{
				utils.apply(args.onEach, [v, i, t], args.context);
			}

			if (args.wait === null){
				_next();
			}
		};

		function _next (){
			if (isCancelled){
				return;
			}

			// update the params by passing arguments to _next()
			var params = utils.toArray(arguments);
			if (params.length){
				value = params[0];
			}else{
				params = args.params;
			}
			
			var callback = callbacks[index];

			// finished going through all the callbacks
			if (!callback){
				if (args.reset){
					index = 0;
				}

				return;
			}
			index++;
			
			// if there's no wait value, then the _done() is added to the params at the end
			if (args.wait === null || args.wait === false){
				params.push(_done);
			}
			
			// does all the callbacks simultaneous with the "wait" argument
			var next = function (){ _next.apply(null, params); };
			
			if (callback === true){
				utils.fn.requestFrame(next);
				return;
			}else if (utils.is.either(callback, 'str,nbr')){
				var duration = utils.string.toDuration(callback);
				timeout = setTimeout(next, duration);
				return;
			}

			var response;
			if (utils.is.fn(args.onError)){
				try{
					response = utils.apply(callback, params, args.context);
				}catch (e){
					utils.apply(args.onError, [e], args.context);
				}
			}else{
				response = utils.apply(callback, params, args.context);
			}
			
			// if the function return a value, then that should update the first params/argument
			if (response !== undefined){
				params[0] = value = response;
			}

			if (args.wait !== null){
				if (args.wait){
					timeout = setTimeout(next, args.wait);
				}else{
					next();
				}
			}

			return value;
		}

		_next.reset = function (){
			params = args.params.slice(0);
			index  = 0;
			return _next;
		};

		_next.add = function (){
			var add = utils.toArray(arguments);
			if (utils.is.arr(add[0])){
				add = add[0];
			}

			callbacks = callbacks.concat(add);

			return _next;
		};

		_next.cancel = function (){
			isCancelled = true;
			return _next;
		};

		_next.isCompleted = function (){
			return index === callbacks.length - 1;
		};

		if (args.now && callbacks.length){
			if (args.wait !== null){
				return _next();
			}else{
				_next();
			}
		}

		return _next;
	};

	// create a function that will call callbacks one after the other
	this.compose = function (){
		var args      = {};
		var callbacks = utils.toArray(arguments);
		if (utils.is.obj(callbacks[0], true)){
			args = callbacks.shift();
		}
		if (utils.is.arr(callbacks[0])){
			callbacks = callbacks[0];
		}

		args.wait  = 0;
		args.now   = false;
		args.reset = true;

		var queue = utils.fn.queue(args, callbacks);

		return queue;
	};

	// call a serie of callback in succession
	this.all = function (){
		var compose = utils.fn.compose.apply(null, arguments);
		return compose();
	};

    // animation/timing --------------------------------------------------------
	this.requestFrame = function (callback, context, isDouble){
		if (utils.is.bool(context)){
			isDouble = context;
			context  = null;
		}

		if (context){
			callback = callback.bind(context);
		}

		if (!window.requestFrame){
			window.requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || (function() {
		        var timeLast = 0;
		        return function(fn) {
		            var timeCurrent = (new Date()).getTime();
		            var timeDelta;

		            // Dynamically set the delay on a per-tick basis to more closely match 60fps.
		            // Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671.
		            timeDelta 	= Math.max(0, 16 - (timeCurrent - timeLast));
		            timeLast 	= timeCurrent + timeDelta;

		            return setTimeout(function() {
						fn(timeCurrent + timeDelta);
					}, timeDelta);
		        };
		    })();
		}

		var request = {
			'id' : null,
		};

		if (isDouble){
			// @todo find a way to cancel both
			request.id = window.requestFrame(function (){
				request.id = window.requestFrame(callback);
			});
		}else{
			request.id = window.requestFrame(callback);
		}

		return request;
	};

	this.cancelFrame = function (request){
		if (!request) return;

		if (!window.cancelFrame){
			window.cancelFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.msCancelAnimationFrame || function (id){
				return clearTimeout(request.id);
			};
        }
        
		void window.cancelFrame(request.id);
	};

    this.animate = function (args, callback){
		if (utils.is.either(args,'str,nbr,boolean')){
			args = {'duration':args};
		}else if (utils.is.fn(args)){
			callback = args;
			args     = {};
		}

		// args.duration should be 0/none by default, unless it's specified

		args          = args || {};
		args.frames   = args.frames || null;                        // animate by a number of frames
		args.duration = 'duration' in args ? args.duration : 1000;  // animate by a durations
		args.easing   = args.easing || null;
		args.context  = args.context || null;
		args.loop     = 'loop' in args ? args.loop : false;
		args.reverse  = 'reverse' in args ? args.reverse : false;
		args.fps      = 'fps' in args ? args.fps : null;
		args.delay 	  = 'delay' in args ? args.delay : 0;
		args.now      = 'now' in args ? args.now : true;
		// args.enable   = args.enable || 'focus';	// visible, focus, true @todo

		// window.addEventListener('blur', function (e){
		// 	console.log('wind;', e);
		// });
		// document.addEventListener('visibilitychange', function (e){
		// 	console.log(e);
		// });


        // format
        args.duration = utils.string.toDuration(args.duration);
        args.delay    = utils.string.toDuration(args.delay);
        args.easing   = utils._easing(args.easing);

		if (args.frames){
			args.frames = Math.abs(args.frames) | 0;
		}
		
		var self 		  = {};
        var request       = null;
        var start         = +new Date();
        var looped        = 0;
		var isPlaying     = false;
		var isReverse 	  = args.reverse;
		var previousFrame = -1;
		var tick 		  = 0;
		var now 		  = 0;
		var last 		  = 0;
        
		function _tick (){
			isPlaying = true;
			now       = +new Date();

            var time  = now - start;
            var ratio = 0;
            var frame = 0;
			
			last = now;

			if (args.duration === true){
				frame = previousFrame + 1;
			}else{
				if (args.duration && time > args.duration){
					time = args.duration;
				}

				// animation by frames
				if (args.frames){
					frame = previousFrame + 1;
					ratio = frame / args.frames;
				// animation by duration
				}else{
					ratio = time / args.duration;
					frame = Math.floor(args.fps ? time / 1000 * args.fps : previousFrame+1);
				}
			}

			if (frame !== previousFrame){
				var r, e, response;
				
                r = isReverse ? 1 - ratio : ratio;
                r = utils.is.fn(args.easing) ? args.easing(r) : r;
                e = {
					'time'    : time,
					'duration': args.duration,
					'ratio'   : r,
					'progress': ratio,
					'frame'   : frame,
					'isStart' : ratio <= 0,
					'isEnd'   : ratio >= 1,
					'tick'    : tick++,
					'looped'  : looped,
				};

				// if it's infinite, ratio should be 1 or 0

                response = callback.apply(args.context, [r, e]);
                
				if (response === false){
					isPlaying = false;
				}
			}


			var willTick = isPlaying && (!args.duration || ratio < 1);
			if (args.loop && ratio >= 1){
				start    = +new Date();
				willTick = true;
				looped++;
			}

			// next frame
			if (willTick){
				previousFrame = frame;
				request       = utils.fn.requestFrame(_tick);
			}else{
				isPlaying = false;
			}
		}

		function _start (){
			start     = +new Date();
			looped    = 0;
			isPlaying = true;
			_tick();
		}

		function _play (reverse){
			if (!isPlaying){
				isReverse = reverse;

				if (args.delay){
					setTimeout(_start, args.delay);
				}else{
					_start();
				}
			}else if (isReverse !== reverse){
				isReverse = reverse;
				start     = +new Date() - (args.duration - (now - start));
			}
		}

		self.play = function (){
			_play(false);
			return this;
		};

		self.reverse = function (){
			_play(true);
			return this;
		};

		self.stop = function (){
            if (isPlaying){
				isPlaying = false;
				utils.fn.cancelFrame(request);
			}
			return this;
		};
		
		self.ratio = function (r){
			callback.apply(args.context, [r]);
		};
        
        self.isPlaying = function (){
            return isPlaying;
        }

		if (args.now){
			self.play();
		}

		return self;
	};

	this.cancel = function (item){
		if (item && utils.is.fn(item.stop)){
			item.stop();
		}else if (item && utils.is.fn(item.cancel)){
			item.cancel();
		}else if (utils.is.fn(item)){
			item();
		}else if (item && utils.is(item.id)){
			utils.fn.cancelFrame(item);
		}else if (utils.is.nbr(item)){
			clearTimeout(item);
			clearInterval(item);
		}
		return null;
	};

	this.tick = function (args, callback){
		if (utils.is.fn(args)){
			callback = args;
			args 	 = {};
		}else if (utils.is.bool(args)){
			args = {'now':args};
		}else if (utils.is.nbr(args)){
			args = {'delay':args};
		}

		args 			= args || {};
		args.delay		= utils.string.toDuration('delay' in args ? args.delay : 1000);
		args.context	= 'context' in args ? args.context : null;
		args.now		= 'now' in args ? args.now : true;

		var id 		  = utils.string.random();
		var count     = 0;
		var isTicking = false;
		var tick  	  = null;
		var self 	  = {
			'id'	  : id,
			'start'	  : null,
			'end'	  : null,
			'delay'	  : args.delay,
		};
		
		self.start = function (reset){
			if (isTicking) return this;
			isTicking = true;

			if (reset){
				count = 0;
			}

			if (self.delay){
				tick = setTimeout(_tick, self.delay);
			}else{
				_tick();
			}

			return this;
		}

		self.stop = function (){
			if (!isTicking) return this;
			isTicking = false;

			utils.fn.cancel(tick);

			return this;
		}

		function _tick (){
			var response = utils.apply(callback, [{'count':count}], args.context);
			
			// the callback stops itself
			if (response === false){
				return self.stop();
			}
			if (!isTicking){
				return;
			}

			count++;

			if (self.delay){
				tick = setTimeout(_tick, self.delay);
			}else{
				tick = utils.fn.requestFrame(_tick);
			}
		}

		if (args.now){
			self.start();
		}
		
		return self;
	};

	this.sync = function (args){
		if (typeof args === 'function'){
			args = {'onChange':args};
		}

		args 			= args || {};
		args.context 	= args.context || null;
		args.debounce 	= utils.string.toDuration('debounce' in args ? args.debounce : 300);
		args.throttle 	= 'throttle' in args ? args.throttle : 300;
		args.throttle	= args.throttle === true ? true : utils.string.toDuration(args.throttle);
		args.format 	= args.format || null;
		//args.callback 	= args.callback || null;
		args.onStart 	= args.onStart || null;
		args.onChange 	= args.onChange || null;
		args.onEnd	 	= args.onEnd || null;
		args.onAll 		= args.onAll || args.callback || null;

		var dataStart       = null;
		var timeoutThrottle = null;
		var timeoutDebounce = null;
		var isStarted       = false;
		var isWaiting       = false;

		var onChange1 = null;
		var onChange2 = null;
		if (utils.is.arr(args.onChange)){
			onChange1 = args.onChange[0];
			onChange2 = args.onChange[1];
		}else{
			onChange1 = args.onChange;
		}

		function _tick (data){
			// format the data
			data = utils.apply(args.format, [data, dataStart], args.context, data);
			
			// start callback
			if (!isStarted && utils.is.fn(args.onStart)){
				if (utils.is.obj(data)){
					data.isStart = true;
					data.isChange= false;
					data.isAll 	 = false;
					data.isEnd 	 = false;
				}
				
				dataStart = data;

				utils.apply(args.onStart, [data, dataStart], args.context);
			}			

			// always callback
			if (typeof data === 'object'){
				data.isStart = false;
				data.isChange= false;
				data.isAll   = true;
				data.isEnd 	 = false;
			}
			utils.apply(args.onAll, [data, dataStart], args.context);
			
			// change callback (throttle)
			if (!isWaiting && (utils.is.fn(onChange1) || utils.is.fn(onChange2))){
				if (typeof data === 'object'){
					data.isStart = false;
					data.isChange= true;
					data.isAll   = false;
					data.isEnd 	 = false;
				}

				utils.apply(onChange1, [data, dataStart], args.context);

				isWaiting = true;

				// requestAnimationFrame
				if (args.throttle === true){
					timeoutThrottle = utils.fn.requestFrame(function (){ 
						utils.apply(onChange2, [data, dataStart], args.context);
						isWaiting = false; 
					});
				// timeout
				}else if (utils.is.nbr(args.throttle)){
					timeoutThrottle = setTimeout(function (){ 
						utils.apply(onChange2, [data, dataStart], args.context);
						isWaiting = false; 
					}, args.throttle);
				// all the time
				}else{
					utils.apply(onChange2, [data, dataStart], args.context);
					isWaiting = false;
				}
			}

			// end callback (debounce)
			isStarted = true;
			utils.fn.cancel(timeoutDebounce);

			timeoutDebounce = setTimeout(function (){
				if (typeof data === 'object'){
					data.isStart = false;
					data.isChange= false;
					data.isAll   = false;
					data.isEnd 	 = true;
				}
				
				isStarted = false;
				dataStart  = null;

				utils.apply(args.onEnd, [data, dataStart], args.context);
			}, args.debounce);
		};

		_tick.cancel = function (){
			utils.fn.cancel(timeoutThrottle);
			utils.fn.cancel(timeoutDebounce);
		};

		return _tick;
	};

	this.debounce = function (args, callback){
		if (utils.is.either(args, 'string,number')){
			args = {'wait':args};
		}
		if (utils.is.fn(args)){
			callback = args;
			args     = {};
		}

		args 			= args || {};
		args.wait 		= utils.string.toDuration(args.wait || 300);
		args.context 	= 'context' in args ? args.context : null;
		args.now 		= 'now' in args ? args.now : false;
	
		return utils.fn.sync({
			'debounce': args.wait,
			'context' : args.context,
			'onStart' : args.now && callback,
			'onEnd'   : !args.now && callback,
		});
	};

	this.throttle = function (args, callback){
		if (utils.is.either(args, 'string,number')){
			args = {'wait':args};
		}
		if (utils.is.fn(args)){
			callback = args;
			args     = {};
		}

		args 			= args || {};
		args.wait 		= utils.string.toDuration(args.wait || 300);
		args.context 	= 'context' in args ? args.context : null;
		args.now 		= 'now' in args ? args.now : true;
		
		return utils.fn.sync({
			'throttle': args.wait,
			'context' : args.context,
			'onChange': [args.now && callback, !args.now && callback],
		});
	};

	this.wait = function (time, context, callback, args){
		if (utils.is.fn(context)){
			args     = callback;
			callback = context;
			context  = null;
		}
		if (!utils.is.fn(callback)){
			return;
		}
		if (!time){
			callback.apply(context, args);
		}else if (time === true){
			utils.fn.requestFrame(function (){
				callback.apply(context, args);
			});
		}else{
			time = utils.string.toDuration(time);
			return setTimeout(function (){ 
				callback.apply(context, args); 
			}, time);
		}
	};

	/**
	 * Check if a state is ready (true) and call the callback, if not ready, add it to a queue
	 * 
	 * @param {string} key 
	 * @param {function|boolean} callback add/call a callback OR make a state ready, which will call all the callbacks in queue
	 * @param {object} data 
	 * @param {*} context 
	 * @returns 
	 */
	this.when = function (key, callback, data, context){
		data = data || FN.WHEN;

		var value = data[key]; 

		// call callbacks
		if (!utils.is.valid(callback)){
			// @info when there's has been no callbacks and wasn't changed to true, the result is null
			if (value === true){
				return true;
			}else if (value === false || value instanceof Array){ // array is a list of callbacks
				return false;
			}else{
				return null;
			}
		}

		var isDone = value === true;
		if (utils.is.fn(callback)){
			if (isDone){
				utils.apply(callback, null, context);
			}else{
				value = utils.is.arr(value) ? value : [];
				value.push(callback);
			}
		}else if (callback === true){
			var callbacks = utils.is.arr(value) ? value : [];
			var i=0, l=callbacks.length;

			// need to put at true value before doing the callbacks, if the callback try asking if the key is true
			data[key] = true;

			for (;i<l;++i){
				utils.apply(callbacks[i], null, context);
			}
			value = true;
		}else if (callback === false){
			value = false;
		}
		
		data[key] = value;

		return value;
	};

    // casting -----------------------------------------------------------------
	this.toCounters = function (){
		var counters = {};

		function _get (key){
			key = key || '*';

			if (counters[key] === undefined){
				counters[key] = 0;
			}

			var count = counters[key]++;
			return count;
		};

		return _get;
	};

	this.toPauses = function (){
		// will set a var to paused or not
		var timeouts = {};
		var items    = {};

		function _pause (key, time){
			if (!arguments.length){
				key = '*';
			}else if (utils.is.nbr(key)){
				time= key;
				key = '*';
			}
			
			if (time !== undefined){
				clearTimeout(timeouts[key]);

				if (time === true){
					items[key] = true;
				}else if (time === false){
					items[key] = false;
				}else if (!isNaN(time)){
					time 			= utils.string.toDuration(time);
					items[key] 		= true;
					timeouts[key] 	= setTimeout(function (){ items[key] = false; }, time);
				}	
			}

			return !!items[key];
		}

		return _pause;
	}; 

	this.toDelays = function (args){
		args         = args || {};
		args.context = args.context || null;

		var timeouts = {};
		function _delay (key, delay, callback){
			if (utils.is.fn(key)){
				callback = key;
				delay    = 0;
				key      = '*';
			}else if (utils.is.fn(delay)){
				callback = delay;
				delay 	 = key;
				key 	 = '*'; 	 
			}

			delay = utils.string.toDuration(delay);

			clearTimeout(timeouts[key]);

			function _callback (){
				utils.apply(callback, null, args.context);
			}

			if (delay){
				timeouts[key] = setTimeout(_callback, delay);
			}else{
				_callback();
			}
		}

		return _delay;
	};

	this.toTween = function (start, end, args){
		args          = args || {};
		args.format   = 'format' in args ? args.format : utils.fn.empty; 
		args.type     = 'type' in args ? args.type : null;
		args.easing   = utils._easing('easing' in args ? args.easing : null);
		args.decimals = 'decimals' in args ? args.decimals : true;
		args.match    = 'match' in args ? args.match : RE.TWEEN_VARS;

		// make sure from and to aren't null/undefined
		var from     = utils.is(start) ? start : '';
		var to       = utils.is(end) ? end : '';
		var type     = args.type;

		var values 	 = [];
		var template = '';
		var decimals = null;
		var isString = utils.is.str(from) || utils.is.str(to);
		var tween    = null;
	
		function _ (a, b, r){
			var v = utils.math.ratio(a, b, r);
			v = utils.format(v, args.format);
			return v;
		}
		
		function _n (v, d){
			if (args.decimals === false){
				v = v.toFixed(0);
			}else if (args.decimals === true){
				v = v.toFixed(d);
			}else if (utils.is.numeric(args.decimals)){
				v = v.toFixed(args.decimals);
			}
			return v;
		}

		function _bool (r){
			return r < 0.5 ? from : to;
		}

		function _number (r){
			var value = _(from, to, r);
			return isString ? _n(value, decimals).toString() : value;
		}

		function _color (r){
			var f 	  = values.from;
			var t 	  = values.to;
			var red   = _(f[0], t[0], r) | 0;
			var green = _(f[1], t[1], r) | 0;
			var blue  = _(f[2], t[2], r) | 0;
			var alpha = _(f[3], t[3], r) | 0;
			var color 	= 'rgba('+[red, green, blue, alpha]+')';
			return color;
		}

		function _vars (r, isWrapped){
			var text = template.toString();
			
			for (var i=0, l=values.length; i<l; ++i){
				var item  = values[i];
				var value = _(item.from, item.to, r);

				value = item.prefix + _n(value, item.decimals) + item.suffix;

				if (type === 'vars' && isWrapped){
					value = '{{ ' + value + ' }}';
				}

				text = text.replace(FN.WRAP_KEY + i + FN.WRAP_KEY, value);
			}

			return text;
		}
		
		function _list (r){
			var list = type === 'array' ? [] : {};
			for (var i in values){
				list[i] = values[i].tween(r);
			}
			return list;
		}

		// find the type if not set
		if (type === null){
			if (from === null && to === null){
				type = 'null';
			}else if (utils.is.bool(from) || utils.is.bool(to)){
				type = 'boolean';
			}else if (utils.is.numeric(from) || utils.is.numeric(to)){
				type = 'number';
			}else if (utils.is.arr(from) || utils.is.arr(to)){
				type = 'array';
			}else if (utils.is.obj(from) || utils.is.obj(to)){
				type = 'object';
			}else if (utils.is.color(from) || utils.is.color(to)){
				type = 'color';
			}else if (utils.is.str(from) || utils.is.str(to)){
				// variable in text
				if (to.match(args.match)){
					type = 'vars';
				}else if (to.match(RE.TWEEN_PATHS)){
					type = 'path';
				}else if (to.match(RE.TWEEN_POINTS)){
					type = 'points';
				}else if (to.match(RE.TWEEN_NUMBERS)){
					type = 'numbers';
				}else{
					type = 'string';
				}
			}
		}

		if (type === 'number'){
			var d1  = utils.number.decimals(from);
			var d2  = utils.number.decimals(to);
			from  	= parseFloat(from) || 0;
			to    	= parseFloat(to) || 0;
			decimals= Math.max(d1, d2);
			tween 	= _number;
		}else if (type === 'color'){
			values = {
				'from'  : utils.color.get(from),
				'to'	: utils.color.get(to),
			};

			tween = _color;
		}else if (type === 'path'){
			// @todo todo
			from  = utils.string.toSvgPath(from);
			to    = utils.string.toSvgPath(to);
			tween = _path;
		}else if (type === 'points'){
			// @todo todo
			// make sure there's the same amount of points
			from  = utils.string.toSvgPoints(from);
			to    = utils.string.toSvgPoints(to);
			tween = _points;
		}else if (type === 'array' || type === 'object'){
			values = {};
			from   = from || (type === 'array' ? [] : {});
			to     = to || (type === 'array' ? [] : {});
			
			for (var i in from){
				values[i] = {
					'from'	: from[i],
					'to'	: from[i],
					'tween' : null,
				};
			}
			for (var i in to){
				if (!values[i]){
					values[i] = {
						'from'	: to[i],
						'to'	: null,
						'tween'	: null,
					};
				}

				values[i].to = to[i];
			}

			for (var i in values){
				var item = values[i];
				item.tween = utils.fn.toTween(item.from, item.to);
			}

			tween = _list;
		}else if (type === 'numbers'){
			from   = from.toString();
			to     = to.toString();
			tween  = _vars;

			// list of numbers
			var i = 0;
			template = from.replace(RE.TWEEN_NUMERIC, function (m, $1, $2, $3){
				var nbr = parseFloat($1.replace(RE.TWEEN_NOT_NUMBER, ''));
				var dec = utils.number.decimals(nbr);

				values[i] = {
					'from'     : nbr,
					'to'       : nbr,
					'prefix'   : $2 || '',
					'suffix'   : $3 || '',
					'decimals' : dec,
				};

				return FN.WRAP_KEY + (i++) + FN.WRAP_KEY;
			});

			var i = 0;
			to.replace(RE.TWEEN_NUMERIC, function (m, $1, $2, $3){
				var nbr  = parseFloat($1.replace(RE.TWEEN_NOT_NUMBER, ''));
				var dec  = utils.number.decimals(nbr);
				var item = values[i++];

				item.to       = nbr;
				item.prefix   = item.prefix || $2 || '';
				item.suffix   = item.suffix || $3 || '';
				item.decimals = Math.max(item.decimals, dec);
			});
		}else if (type === 'vars'){
			from     = from.toString();
			to       = to.toString();
			values   = [];
			template = to;
			tween    = _vars;

			var i = 0;
			from = from.replace(args.match, function (m, $1){
				var value 	= utils.string.match($1, RE.TWEEN_NUMERIC, true);
				var nbr     = parseFloat(value[0].replace(RE.TWEEN_NOT_NUMBER, ''));
				var dec 	= utils.number.decimals(nbr);
				
				values[i++]  = {
					'from'    : nbr,
					'to'      : nbr,
					'prefix'  : value[1] || '',
					'suffix'  : value[2] || '',
					'decimals': dec,
				};

				return $1.trim();
			});

			to = to.replace(args.match, function (m, $1){
				return $1.trim();
			});

			var i = 0;
			template = template.replace(args.match, function (m, $1){
				var value 	= utils.string.match($1, RE.TWEEN_NUMERIC, true);
				var nbr     = parseFloat(value[0].replace(RE.TWEEN_NOT_NUMBER, ''));
				var dec 	= utils.number.decimals(nbr);
				var item 	= values[i];
				
				console.log(value);

				item.to 		= nbr;
				item.prefix     = item.prefix || value[1] || '';
				item.suffix     = item.suffix || value[2] || '';
				item.decimals	= Math.max(item.decimals, dec);

				return FN.WRAP_KEY + (i++) + FN.WRAP_KEY;
			});
		}else{
			tween = _bool;
		}

		function _get (ratio, isWrapped){
			var value = null;
			ratio = ratio || 0;

			if (ratio === 0){
				value = isWrapped ? start : from;
			}else if (ratio === 1){
				value = isWrapped ? end : to;
			}else{
				ratio = args.easing(ratio);
				value = tween(ratio, isWrapped);
			}

			return value;
		}

		//console.log({type, from, to, values, template});
		
		_get.from = from;
		_get.to   = to;
		_get.type = type;

		return _get;
	};
	
	this.toKeyframes = function (keyframes, args){
		if (utils.is.str(args)){
			args = {'easing':args};
		}

		args        = args || {};
		args.easing = utils._easing('easing' in args ? args.easing : null);

		var self   = {};
		var frames = self.frames = [];

		utils.each(keyframes, function (value, keys, a){
			if (a.type === 'array'){
				keys = keys / (a.length-1);
			}

			if (utils.is.nbr(keys)){
				keys = [keys];
			}

			utils.each(keys, function (key){
				if (key === 'from'){
					key = 0;
				}else if (key === 'to'){
					key = 1;
				}else if (utils.is.percent(key)){
					key = parseFloat(key) / 100;
				}
				frames.push({
					'key'	: key,
					'value'	: value,
				});
			});
		});

		// re-order the frames
		frames.sort(function (a, b){ return a.key - b.key; });

		// first
		if (frames[0].key !== 0){
			frames.unshift({
				'key'	: 0,
				'value'	: frames[0].value
			});
		}
		// last
		var last = frames[frames.length-1];
		if (last.key !== 1){
			frames.push({
				'key'	: 1,
				'value'	: last.value
			});
		}

		function _get (r){
			var ratio = 0;

			var i=0, l=frames.length-1;
			for (;i<l;++i){
				var from = frames[i];
				var to   = frames[i+1];
				
				if (r >= from.key && r <= to.key){
					ratio = utils.math.toRatio(r, from.key, to.key);
					ratio = args.easing(ratio);
					
					// the tween are generated only when called
					if (!from.tween){
						if (from.value === to.value){
							from.tween = function (v){ return function (){ return v; }; }(from.value);
						}else{
							from.tween = utils.fn.toTween(from.value, to.value);
						}
					}
					
					ratio = from.tween(ratio);

					break;
				}
			}

			return ratio;
		};

		return _get;
	};

	this.toFrames = function (value, args, callback){
		if (utils.is.obj(value)){
			args  = value;
			value = 0;
		}

		args 			= args || {};
		args.auto 		= 'auto' in args ? args.auto : true;
		args.context	= args.context || null;
		args.easing 	= utils._easing(args.easing);
		args.callback 	= args.callback || callback || null;
		
		var isTransitioning = false;
		var self = {
			'from' : value,
			'to'   : value,
			'value': value,
		};

		var move, speed, duration, frames, start, frame;

		// move by pixel
		if ('move' in args){
			move = args.move;  
		// move by ratio speed
		}else if ('speed' in args){
			speed = args.speed; 
		// move by duration
		}else if ('duration' in args){
			start 	 = +new Date();
			duration = utils.string.toDuration(args.duration); 
		// move by frames (using the from/to)
		}else{
			frames = args.frames || 10;	
		}

		self.set = function (v, reset){
			self.to = v;

			if (reset){
				self.from  	= v;
				self.value 	= v;
			}

			if (!isTransitioning){
				self.from = self.value;
				start     = +new Date();
				frame     = 0;
			}
			
			_start();
		};

		self.add = function (v){
			self.to += v;
			_start();
		};

		self.get = function (r){
			if (r !== undefined){
				r = _ratio(r);
				return utils.math.lerp(self.from, self.to, r);
			}

			if (self.value === self.to){
				return self.value;
			}

			var v = self.value;
			if (move){
				var d1 = (self.to - v);
				var d2 = Math.abs(d1);
				var m = (d2 < move ? d2 : move) * utils.math.sign(d1);
				v += m;
			}else if (speed){
				var d1 = (self.to - v) * speed;
				var d2 = Math.abs(d1);
				var m  = d2 < speed ? (self.to - v) : d1;
				v += m;
			}else if (duration){
				var now  = +new Date();
				var time = now - start;
				r = _ratio(time / duration);
				v = utils.math.lerp(self.from, self.to, r);
			}else if (frames){
				r = _ratio(++frame / frames);
				v = utils.math.lerp(self.from, self.to, r);
			}


			self.value = v;

			return v;
		};

		function _ratio (r){
			r = utils.math.clamp(r, 0, 1);
			r = args.easing(r);
			return r;
		}

		function _start (){
			if (!args.auto || isTransitioning) return;
			_tick();
		}

		function _tick (){
			var value 	= self.get();
			var isStart = value === self.from;
			var isEnd 	= value === self.to;
			var isChange= !isStart && !isEnd;
			
			(self.from !== self.to) && utils.apply(args.callback, [{
				'value'   : value,
				'from'	  : self.from,
				'to'	  : self.to,
				'isStart' : isStart,
				'isChange': isChange,
				'isEnd'   : isEnd,
			}], args.context);

			isTransitioning = true;

			if (isEnd){
				isTransitioning = false;
			}else{
				utils.fn.requestFrame(_tick);
			}
		}

		return self;
	};

	this.toTransitions = function (args, props, globalTransition){
		// @todo add a getter function, for if the FROM value isn't set yet
		// @todo test setting the transition at FALSE/OFF midway through an animation
		// @todo ... maybe add a boomerang effect... or not
		// @todo have a way to inherit the global transitions

		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args 			= args || {};
		args.context  	= args.context || null;
		args.callback 	= args.callback || null;
		args.duration 	= utils.string.toDuration('duration' in args ? args.duration : 300);
		args.easing 	= null;

		var items           = {};
		var isPaused 		= false;
		var isTransitioning = false;

		function _set (id, props, transition, willUpdate){
			if (utils.is.obj(id)){
				willUpdate = transition;
				transition = props;
				props      = id;
				id         = '*';
			}

			var willTransition = transition !== false;
			willUpdate = willUpdate === undefined ? true : willUpdate;
			transition = transition === undefined ? globalTransition : transition;

			var item = items[id];
			if (!item){
				item = items[id] = {
					'props'      : props,   // final values of the props
					'meta'       : {},      // props to update
					'transitions': {},      // transition info
				};
			}
			
			if (transition){
				item.transitions = _transitions(transition);
			}

			// setup the transition
			var now = +new Date();
			for (var name in props){
				var transition  = item.transitions[name] || item.transitions.all || null;
				var meta 		= item.meta[name];
				var value 		= props[name];

				var operator = utils.is.str(value) ? [value.slice(0, 2), value.slice(2)] : false;
				// operator, should only with with numeric values
				if (operator && utils.is.nbr(meta.cache)){
					var v = parseFloat(operator[1]);
					var o = meta.cache || 0;
					switch (operator[0]){
						case '+=': value = o + v; break;
						case '-=': value = o - v; break;
						case '*=': value = o * v; break;
						case '/=': value = o / v; break;
						case '%=': value = o % v; break;
						case '++': value = o + 1; break;
						case '--': value = o - 1; break;
					}
				}
				
				if (!meta){
					meta = {
						'from'           : value,
						'to'             : value,
						'tween'          : null,
						'cache'          : null,	// current cached value (with var wraps if text)
						'start'          : null,
						'end'            : null,
						'isTransitioning': false,
					};
				}

				var isChanged = meta.to !== value;
				meta.from = isChanged ? (meta.cache !== null ? meta.cache : meta.to) : meta.from;
				meta.to   = value;

				if (isChanged && willTransition && transition){
					meta.easing 		 = transition.easing;
					meta.tween           = utils.fn.toTween(meta.from, meta.to, {'decimals':true});
					meta.start           = now + transition.delay;
					meta.end             = meta.start + transition.duration;
					meta.isTransitioning = true;
				}else if (!transition){
					meta.tween           = null;
					meta.start           = null;
					meta.end             = null;
					meta.isTransitioning = false;
				}

				item.meta[name] = meta;
			}

			if (willUpdate){
				_tick();
			}

			return _set;
		}

		function _get (id){
			id = id || '*';
			return items[id] ? items[id].props : null;
		}

		function _transitions (transition){
			if (!transition){
				return null;
			}
			
			if (transition === true){
				transition = {
					'all' : {
						'duration': args.duration,
						'easing'  : args.easing,
						'delay'   : 0
					}
				};
			}else if (utils.is.numeric(transition)){
				transition = {
					'all':{
						'duration': parseFloat(transition),
						'easing'  : args.easing,
						'delay'   : 0
					}
				};
			}else if (utils.is.either(transition, 'str,arr')){
				var transitions = {};

				utils.each(transition, {'separator':','}, function (value){
					var values 	= value.split(' ');
					var keys     = values[0].split('|');
					var duration = values[1] || args.duration;
					var easing   = values[2] || args.easing;
					var delay    = values[3] || 0;

					for (var i in keys){
						transitions[keys[i]] = {
							'duration'  : duration,
							'easing'	: easing,
							'delay'		: delay,
						};
					}
				});

				transition = transitions;
			}

			for (var i in transition){
				var t 	   = transition[i];
				t.duration = utils.string.toDuration(t.duration);
				t.easing   = utils._easing(t.easing);
				t.delay    = utils.string.toDuration(t.delay);
			}

			return transition;
		}

		function _pause (value){
			// @todo
			value 	 = value === undefined ? true : value;
			isPaused = value; 
			return _set;
		};

		function _tick (){
			var now      = +new Date();
			var updates  = null;
			var nextTick = false;

			function _s (id, prop, value){
				updates	   		 = updates || {};
				updates[id]		 = updates[id] || {};
				updates[id][prop]= value;
			}

			for (var i in items){
				var item = items[i];

				for (var name in item.meta){
					var meta = item.meta[name];

					// there's no transition to be done
					if (meta.cache === meta.to){
						continue;
					}

					// no transition, set the value
					if (!meta.isTransitioning){
						_s(i, name, meta.to);
						meta.from  		 = meta.cache = meta.to;
						item.props[name] = meta.to;
						continue;
					}

					// delay
					if (meta.start > now){
						nextTick = true;
						continue;
					}

					var ratio = (now - meta.start) / (meta.end - meta.start);
					ratio = utils.math.clamp(ratio, 0, 1);
					
					var r     = (ratio === 0 || ratio === 1) ? ratio : meta.easing(ratio);
					var cache = meta.tween ? meta.tween(r, true) : meta.from;
					var value = meta.tween ? meta.tween(r) : meta.from;

					// flag when there's at least 1 change
					if (cache !== meta.cache){
						_s(i, name, value);
					}

					meta.cache 			= cache;
					item.props[name] 	= value;

					if (now < meta.end){
						nextTick = true;
					}else{
						meta.isTransitioning = false;
					}
				}
			}

			// if none of the values have changed, don't update
			if (updates){
				utils.apply(args.callback, [updates['*'], {
					'timestamp'   : now,
					'updates'     : updates,
					'target'	  : _set,
				}], args.context);
			}

			isTransitioning = nextTick;

			// next tick
			if (nextTick){
				utils.fn.requestFrame(_tick);
			}
		}

		if (props){
			_set(props, undefined, false);
		}

		_set.items = items;
		_set.pause = _pause;
		_set.get   = _get;

		return _set;
	};
});
Utils.add('object', function (utils, OBJECT, RE){
    // consts ------------------------------------------------------------------
	RE.OBJECT_PATH = /((?:[^\.]+(?=\()\([^\)]+\))|[^.]+)/g;// match object path with function. ex.: value.value.function(a,b,c).value
	RE.OBJECT_PROP = /([^(]+)(?:\(([^(]+)\))?/;

    // methods -----------------------------------------------------------------
	this.resolve = function (obj, path, args){
		// transform form path to dotted ones (eg.: list[items][0][name] -> list.items.0.name)
		if (utils.is.str(path) && ~path.indexOf('[')){
			path = path.replace(/\]/g, '').replace(/\[/g, '.');
		} 

		path = path.toString().match(RE.OBJECT_PATH);

		if (!path || !obj){
			return;
		}

		args 		= args || {};
		args.value 	= 'value' in args ? args.value : undefined;
		args.context= 'context' in args ? args.context : undefined;

		var value;
		for (var i=0, l=path.length; i<l; ++i){
			var name 	= path[i];
			var match 	= name.match(RE.OBJECT_PROP);

			// couldn't match an attribute
			if (!match){
				break;
			}

			var prop 	= match[1];
			var params 	= utils.toValues(match[2]);
			var isLast  = i === l-1;
			var val 	= obj[prop];

			if (isLast){
				// set value to function
				if (args.value !== undefined && typeof current === 'function'){
					value = val.call(args.context || obj, args.value);
				// set value (need to use the obj, since it's HIS value that needs to be set)
				}else if (args.value !== undefined){
					value = obj[prop] = args.value;
				}else{
					value = val;
				}
			}else{
				val = typeof val === 'function' ? val.apply(args.context || obj, params) : val;

				if (val === undefined || val === null){
					break;
				}else{
					obj = val;
				}
			}
		}

		return value;
	};

	this.get = function (obj, path, fallback){
		var value = utils.object.resolve(obj, path);
		return value === undefined ? fallback : value;
	};

	this.set = function (obj, path, value){
		utils.object.resolve(obj, path, {
			'value' : value,
		});
	};

	this.has = function (obj, keys, all){
		if (!utils.is.obj(obj)){
			return false;
		}
		
		all = all === undefined ? true : all;

		var hasAll  = true;
		var hasSome = false;
		utils.each(keys, function (key){
			key = key.trim();

			var exists = key in obj;

			if (all && !exists){
				hasAll = false;
				return BREAK;
			}else if (!all && exists){
				hasSome = true;
				return BREAK;
			}
		});

		return all ? hasAll : hasSome;
	};

	this.first = function (obj, isKey){
		var v = null, i;
		for (i in obj){
			v = isKey ? i : obj[i];
			break;
		}
		return v;
	};

	this.last = function (obj, isKey){
		var v = null, i;
		for (i in obj){
			v = isKey ? i : obj[i];
		}
		return v;
	};

	this.inherit = function (obj, proto, props){
		if (proto === undefined){
			proto = obj;
			obj   = {};
		}

		props = props || {};

		obj.__proto__ = proto;

		for (var i in props){
			obj[i] = props[i];
		}

		return obj;
	};
    
    this.split = function (obj, callback){
		var keys   = [];
        var values = [];
        var i;

		for (i in obj){
			keys.push(i);
			values.push(obj[i]);
			utils.apply(callback, [i, obj[i]]);
		};

		return {
			'keys'  : keys,
			'values': values,
		}
	};

	this.keys = function (obj){
		return utils.object.split(obj).keys;
    };
    
    this.values = function (obj){
        return utils.object.split(obj).values;
    };

    this.combine = function (keys, values){
        keys   = utils.toArray(keys);
        values = utils.toArray(values);

        var obj   = {};
        var count = Math.min(keys.length, values.length);
        var i, l, key, value;

        for (i=0, l=count; i<l; ++i){
            key      = keys[i];
            value    = values[i];
            obj[key] = value;
        }

        return obj;
    };

	this.swap = function (obj){
		var swap = {};

		utils.object.split(obj, function (key, value){
			swap[value] = key;
		});

		return swap;
	};

    this.key = function (obj, value){
		if (obj instanceof Array){
			return obj.indexOf(value);
		}else if (typeof obj === 'object'){
			for (var i in obj){
				if (obj[i] === value) return i;
			}
		}
    };
    
	this.key.index = function (obj, key){
		var keys = utils.object.split(obj).keys;
		return keys.indexOf(key);
    };

	this.exists = function (obj, value){
        var key = utils.object.key(obj, value);
        
		if (obj instanceof Array){
			return !!~key;
		}else{
			return key !== undefined;
		}
	};

	this.pluck = function (obj, keys){
		var item = {};
		var keys = utils.toArray(keys);

		for (var i in keys){
			var key = keys[i];
			if (key in obj){
				item[key] = obj[key];
			}
		}

		return item;
	};

	this.diff = function (a, b){
		obj = {};

		for (var i in a){
			if (a[i] === b[i]) continue;
			obj[i] = a[i];
		}
		for (var i in b){
			if (a[i] === b[i]) continue;
			obj[i] = b[i];
		}

		return obj;
	};

	this.reindex = function (obj, key, context){
		var list = {};
		
		utils.each(obj, function (value, id, a){
			if (utils.is.fn(key)){
				id = utils.apply(key, [value, id, a.index], context || value);
			}else if (key in value){
				id = value[key];
			}
			list[id] = value;		
		});

		return list;
	};

	this.namespace = function (key, value, args){
		var obj = {};

		if (utils.is.either(key, 'arr,obj')){
			obj  = key;
			args = value;
		}else{
			obj[key] = value;
		}

		if (utils.is.str(args)){
			args = {'separator':args};
		}

		args 			= args || {};
		args.separator 	= 'separator' in args ? args.separator : '.';

		var isArrays = utils.is.arr(obj);
		var data 	 = {};
		for (var key in obj){
			var item = data;
			var value= obj[key];
			var path;

			// if it's a set of arrays
			if (isArrays && utils.is.arr(value)){
				key   = value[0];
				value = value[1];
			}

			path = key.replace(/\[/g, args.separator).replace(/\]/g, '');
			path = path.split(args.separator);
			
			for (var i=0, l=path.length; i<l; ++i){
				var index  = (path[i] || item.length.toString()).trim();
				var nIndex = (path[i + 1] || '0').trim();

				if (i === path.length - 1){
					item[index] = value;
				}else if (!isNaN(nIndex)){
					item = item[index] = item[index] || [];
				}else{
					item = item[index] = item[index] || {};
				}
			}
		}

		return data;
	};

	this.prop = function (obj, name, getter, setter){
		Object.defineProperty(obj, name, {
			get:getter && function (){ return getter.apply(this); },
			set:setter && function (){ setter.apply(this, arguments); }
		});
	};

	this.enum = function (obj, value, fallback){
		var first = null;

		for (var k in obj){
			var v = obj[k];

			if (!first){
				first = v;
			}

			if (v === value){
				return v;
			}
		}

		return fallback !== undefined ? fallback : first;
	};

    // casting -----------------------------------------------------------------		
	this.toString = function (obj, args){
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args 				= args || {};
		args.separator 		= 'separator' in args ? args.separator : '&';
		args.pairSeparator 	= 'pairSeparator' in args ? args.pairSeparator : '=';
		args.parentSeparator= 'parentSeparator' in args ? args.parentSeparator : '.';
		args.callback		= args.callback || null;

		// todo
		var string = [];
		function _walk (key, value, parentKey, parentValue){
			var response = utils.apply(args.callback, [key, value, parentKey, parentValue]);
			
			if (response){
				key = response;
			}else if (parentKey){
				key = parentKey + args.parentSeparator + key;
			}

			if (utils.is.obj(value, true) || utils.is.arr(value)){
				for (var i in value){
					_walk(i, value[i], key, value);
				}
			}else{
				string.push(key + args.pairSeparator + value);
			}
		}

		for (var i in obj){
			_walk(i, obj[i]);
		}

		return string.join(args.separator);
	};

	this.toQuery = function (obj){
		var strings = [];

		utils.object.toString(obj, function (i, v, pi, pv){
			if (utils.is.arr(pv)){
				i = pi + '[]';
			}else if (utils.is.obj(pv)){
				i = pi + '[' + i + ']';
			}

			if (typeof(v) !== 'object' && utils.is(v)){
				v = encodeURIComponent(v);			
				strings.push(i + '=' + v);
			}

			return i;
		});

		return strings.join('&');
	};

	this.toForm = function (obj){
		var	data = new FormData();
		
		utils.object.toString(obj, function (i, v, pi, pv){
			if (utils.is.arr(pv)){
				i = pi + '['+i+']';
			}else if (utils.is.obj(pv, true)){
				i = pi + '[' + i + ']';
			}

			if (!utils.is.def(v)){
				v = null;
			}

			if (!utils.is.obj(v, true) && !utils.is.arr(v, true)){
				data.append(i, v);
			}

			return i;
		});

		return data;
	};

	this.toClass = function (name, definition, init){
		var i = function (){ 
			if (this[init]){
				init = this[init];
			}
			if (utils.is.fn(init)){
				utils.apply(init, arguments, this); 
			}
		};
		var c = new Function('$init', 'return function '+name+'(){ return $init.apply(this, arguments); };')(i);
		var d = utils.is.fn(definition) ? definition() : definition;
		c.prototype             = d;
		c.prototype.constructor = c;
		return c;
	};
});
Utils.add('array', function (utils, ARRAY, RE){
    // consts ------------------------------------------------------------------
	RE.SORT_ITEMS 	= /(?:([a-z][a-z_0-9\-]+)((?:\s?(?:(?:\[[^\]]+\])|(?:[^,]+)))*))(?:,|$)/g;
	RE.SORT_FIELDS  = /\[([^\]]+)\]/;

    // methods -----------------------------------------------------------------
	function _sortNumeric (a, b){ return a - b; };
	function _sortRandom (){ return 0.5 - Math.random(); }
	
	function _index (arr, search, args){ 
		if (utils.is.bool(args)){
			args = {'single':args};
		}
			
		args        = args || {};
		args.single = 'single' in args ? args.single : false;
		args.key 	= args.key || false;

		var index = -1;

		// @todo add ":45" for ":index(45)"

		if (search === ':first'){
			index = 0;
		}else if (search === ':last'){
			index = arr.length - 1;
		}else if (search === ':random' || search === '?'){
			index = Math.round(Math.random() * (arr.length-1));
		}else if (utils.is.percent(search)){
			index = Math.round((arr.length-1) * (parseFloat(search) / 100));
		}else if (utils.is.str(search) && search.indexOf(':index(') === 0){
			index = parseFloat(search.replace(':index(', ''));
		}else if (utils.object.has(search, ':index')){
			index = search[':index'];
		}else{
			index = utils.array.filter(arr, search, {
				'single': args.single,
				'key'	: args.key,
				'index' : true,
			});
		}

		if (!args.single && !(index instanceof Array)){
			index = [index];
		}

		return index;
	};

	this.filter = function (arr, search, args){
		if (utils.is.bool(args)){
			args = {'single':args};
		}

		args        = args || {};
		args.trim   = 'trim' in args ? args.trim : true;  // trim the value
		args.single = args.single || false;               // only 1 item to return
		args.index  = args.index || false;                // return the index
		args.key    = args.key || false;                  // if the data to search is in a property

		var list    = [];
		var isValid = utils.is.valid(search);
		utils.each(arr, {'trim':args.trim}, function (v, i){
			if (args.key && args.key in v){
				v = v[args.key];
			}

			if (
				(!isValid && utils.is(v)) ||
				(isValid && utils.match(v, search, {'data':{'index':i}}))
			){
				if (args.index){
					list.push(i);
				}else{
					list.push(v);
				}
			}

			if (args.single && list.length >= 1){
				return BREAK;
			}
		});

		return args.single ? list[0] : list;
	};

	this.get = function (arr, search, args){
		args       = args || {};
		args.index = args.index || false;
		args.key   = args.key || false;

		// @todo change "args.index" to args.return, can be [false/value, index, object]

		var index = _index(arr, search, {
			'key'   : args.key,
			'single': true,
		});

		if (!(index in arr)){
			index = -1;
		}

		return args.index ? index : arr[index];
	};

	this.exists = function (arr, search){
		var index = utils.array.get(arr || [], search, {'index':true});
		return !!~index;
	};

	this.unique = function (arr){
		var list = [];

		utils.each(arr, {'trim':true}, function (value){
			if (utils.is.not(value)) return;
			if (!!~list.indexOf(value)) return;
			list.push(value);
		});

		return list;
	};

	this.reverse = function (arr, copy){
		copy = copy === undefined ? true : copy;		
		return (copy ? arr.slice() : arr).reverse();
	};

	this.loop = function (arr, index, fallback){
		if (!(arr instanceof Array)){
			return fallback;
		}

		if (index in arr){
			return arr[index];
		}else if (index % arr.length in arr){
			return arr[index % arr.length];
		}else if (0 in arr){
			return arr[0];
		}else{
			return fallback;
		}
	};

	this.join = function (arr, args){
		if (utils.is.str(args)){
			args = {'template':args};
		}

		args           = args || {};
		args.prefix    = args.prefix || '';
		args.suffix    = args.suffix || '';
		args.separator = 'separator' in args ? args.separator : ',';
		args.format    = args.format || null;
		args.template  = args.template || '';
		args.data      = args.data || {};

		var text = [];
		var v, s, d;
		utils.each(arr, function (item, i, a){
			s = utils.array.loop(args.separator, a.index, args.separator);
			
			if (utils.is.fn(item)){
				// @todo why is this using the function name?
				v = item.name;
			}else if (args.template && item !== null){
				d = utils.is.obj(item) ? utils.extend({}, args.data, item) : {'value':item};
				v = utils.string.replace(args.template, d);
			}else{
				v = utils.is(item) ? item.toString() : '';
			}

			v = utils.format(v, args.format);

			if (a.index > 0){
				text.push(s);
			}

			text.push(args.prefix + v + args.suffix);
		});

		return text.join('');
	};

	this.copy = function (arr){
		return Array.prototype.slice.call(arr);
	};

	this.random = function (arr, min, max){
		arr = utils.toArray(arr);

		if (max === undefined){
			max = min;
		}

		var keys=[];
		for (var i in arr){
			keys.push(i);
		}

		var isSingle = false;
		if (!min && !max){
			isSingle = true;
			min      = 1;
			max      = 1;
		}else if (min && !max){
			max = keys.length;
		}

		// sort randomly the array keys
		keys.sort(_sortRandom);

		var limit = Math.floor((max - min + 1) * Math.random());
		keys = keys.slice(0, min + limit);

		var list = [];
		for (var i=0, l=keys.length; i<l; ++i){
			var key   = keys[i];
			var value = arr[key];
			list.push(value);
		}

		return isSingle ? list[0] : list;
	};

	this.diff = function (arr1, arr2, reverse){
		arr1 = utils.toArray(arr1);
		arr2 = utils.toArray(arr2);

		var intersects = [];
		var diffs      = [];
		var length     = Math.max(arr1.length, arr2.length);
		var i=0, a, b;

		for (; i<length; ++i){
			a = arr1[i];
			b = arr2[i];

			if (a !== undefined){
				if (!~arr2.indexOf(a) && !~diffs.indexOf(a)){
					diffs.push(a);
				}else if (!~intersects.indexOf(a)){
					intersects.push(a);
				}
			}
			
			if (b !== undefined){
				if (!~arr1.indexOf(b) && !~diffs.indexOf(b)){
					diffs.push(b);
				}else if (!~intersects.indexOf(b)){
					intersects.push(b);
				}
			}
		}

		if (utils.is.fn(reverse)){
			reverse(diffs, intersects);
		}

		if (reverse === true){
			return intersects;
		}else{
			return diffs;
		}
	};

	this.intersect = function (arr1, arr2){
		return utils.array.diff(arr1, arr2, true);
	};

	// edit --------------------------------------------------------------------
	this.create = function (count, callback){
		var arr = [];
		for (var i=0; i<count; ++i){
			var value = i + 1;
			value = utils.apply(callback, [value, i], null, value);
			arr.push(value);
		}
		return arr;
	};

	this.repeat = function (value, count){
		var arr = [];
		for (var i=0, l=count; i<l; ++i){
			arr.push(value);
		}
		return arr;
	};

	this.insert = function (arr, items, args){
		items = items instanceof Array ? items :[items];
		
		if (utils.is.bool(args)){
			args = {'duplicate':args};
		}else if (!utils.is.obj(args)){
			args = {'index':args};
		}

		args           = args || {};
		args.duplicate = 'duplicate' in args ? args.duplicate : true;
		args.index     = 'index' in args ? args.index : arr.length;

		var index = utils.math.get(args.index, {
			'min'     : 0,
			'max'     : arr.length,
			'decimals': false,
			'overflow': false,
			'fallback': arr.length,
		});

		if (!args.duplicate){
			items = utils.array.filter(items, function (item){
				return !~arr.indexOf(item);
			});
		}

		arr.splice.apply(arr, [index, 0].concat(items));

		return arr;
	};

	this.remove = function (arr, items, replace){
		var removed = [];
		var indexes = [];
		var index 	= -1;
		
		items = items instanceof Array ? items : [items];

		// search through all the items to remove
		utils.each(items, function (search){
			var found = _index(arr, search);
			indexes = indexes.concat(found);
		});

		indexes.sort(_sortNumeric);

		utils.each(arr, {'reverse':true}, function (item, i){
			if (!~indexes.indexOf(i)) return;
			index = i;
			removed.unshift(item);
			arr.splice(i, 1);
		});

		if (replace){
			replace = replace instanceof Array ? replace : [replace];
			arr.splice.apply(arr, [index, 0].concat(replace));
		}

		return removed;
	};

	this.move = function (arr, search, index, loop){
		if (utils.is.nbr(index)){
			index = loop ? utils.math.loop(index, arr.length - 1) : index;
		}else{
			index = _index(arr, index);
		}
		
		var from = _index(arr, search);
		var item = arr[from];

		if (item){
			arr.splice(index, 0, arr.splice(from, 1)[0]);
		}

		return item;
	};

	this.shuffle = function (arr){
		var j, x, i;
	    for (i = arr.length; i; i--) {
	        j = Math.floor(Math.random() * i);
	        x = arr[i - 1];
	        arr[i - 1] = arr[j];
	        arr[j] = x;
	    }
		return arr;
	};

	this.sort = function (arr, orderBy, args){
		if (!arr || typeof(arr) !== 'object'){
			return arr;
		}
		
		var obj = utils.is.obj(arr, true) ? arr : null;
		if (obj){
			arr = [];
			for (var i in obj){
				arr.push({'key':i, 'value':obj[i]});
			}
		}

		args      = args || {};
		args.copy = args.copy || false;
		args.key  = args.key || false;
		args.order= (args.order || 'DESC').toUpperCase();
		args.case = 'case' in args ? args.case : true;
		args.null = (args.null || 'AFTER').toUpperCase();

		if ('get' in args){
			utils.deprecated('arrat.sort -> get', 'key');
			args.key = args.get;
		}

		if (args.copy){
			arr = utils.array.copy(arr);
		}

		// number array sort
		if (utils.is.nbr(arr[0])){
			arr.sort(_sortNumeric);

			if (orderBy === 'DESC'){
				arr.reverse();
			}

			return arr;
		// string array sort
		}else if (utils.is.str(arr[0])){
			arr.sort();

			if (orderBy === 'DESC'){
				arr.reverse();
			}

			return arr;
		}

		
		var sorting = {};
		if (utils.is.obj(orderBy)){
			for (var i in orderBy){
				sorting[i] = {
					'order' : (orderBy[i].order || args.order).toUpperCase(),
					'case'  : ('case' in orderBy[i] ? orderBy[i].case : args.case),
					'null'  : (orderBy[i].null || args.null).toUpperCase(),
					'fields': orderBy[i].fields || [],
				};
			}
		}else{
			orderBy = utils.string.match(orderBy, RE.SORT_ITEMS);

			// object array sort
			var i=0, l=orderBy.length, k, f, o;
			for (; i<l; ++i){
				o = orderBy[i];
				k = o[0];
				
				// skip repeated keys
				if (k in sorting) continue;

				f = utils.string.match(o[1], RE.SORT_FIELDS, true);
				f = utils.toArray(f);
				o = o[1].replace(RE.SORT_FIELDS, '').toUpperCase();

				sorting[k] = {
					'order' : !!~o.indexOf('DESC') ? 'DESC' : (~o.indexOf('ASC') ? 'ASC' : args.order),
					'case'  : !!~o.indexOf('CASE_INSENSITIVE') ? false : (!!~o.indexOf('CASE_SENSITIVE') ? true : args.case),
					'null'  : !!~o.indexOf('NULL_BEFORE') ? 'BEFORE': (!!~o.indexOf('NULL_AFTER') ? 'AFTER' : args.null),
					'fields': f,
				};
			}
		}

		function _sort (a, b){
			var compare = null;

			// the data is located elsewhere (different source)
			if (args.key){
				a = utils.get(a, args.key);
				b = utils.get(b, args.key);
			}
		
			for (var key in sorting){
				var sort   = sorting[key];
				var valueA = utils.is.valid(a[key]) ? a[key] : '';
				var valueB = utils.is.valid(b[key]) ? b[key] : '';

				if (sort.fields.length){
					valueA = sort.fields.indexOf(valueA);
					valueB = sort.fields.indexOf(valueB);
				}

				if (!sort.case && utils.is.str(valueA)){
					valueA = utils.string.removeAccents(valueA.toLowerCase());
				}
				if (!sort.case && utils.is.str(valueB)){
					valueB = utils.string.removeAccents(valueB.toLowerCase());
				}
				
				// same exact value OR already found an order
				if (valueA === valueB || compare !== null){
					continue;
				}

				if (!utils.is.valid(a[key])){
					compare = sort.null === 'BEFORE' ? -1 : 1;
				}else if (!utils.is.valid(b[key])){
					compare = sort.null === 'BEFORE' ? 1 : -1;
				}else{
					// check for number
					if (utils.is.numeric(valueA)){
						valueA = parseFloat(valueA);
						valueB = parseFloat(valueB);
					}

					if (utils.is.bool(valueA)){
						valueA = valueA ? 1 : 0;
						valueB = valueB ? 1 : 0;
					}
	
					if (valueA > valueB){
						compare = 1;
					}else if (valueA < valueB){
						compare = -1;
					}
					
					if (compare && sort.order === 'DESC'){
						compare *= -1;
					}
				}
				
				if (isNaN(compare)){
					compare = 0;
				}
			}

			if (compare === 0){
				compare = a > b;
			}

			return compare;
		}

		Array.prototype.sort.apply(arr, [_sort]);

		if (obj){
			var obj = {};
			for (var i=0, l=arr.length; i<l; ++i){
				obj[arr[i].key] = arr[i].value;
			}
			arr = obj;
		}

		return arr;
	};

	this.pluck = function (arr, keys, args){
		var items = [];
		var keys  = utils.toArray(keys);

		if (utils.is.fn(args)){
			args = {'many':args};
		}

		args      = args || {};
		args.key  = args.key || false;
		args.many = 'many' in args ? args.many : false;

		if (keys.length > 1){
			args.many = true;
		}

		utils.each(arr, function (item, i){
			item 	 = utils.get(item, args.key);
			item 	 = utils.object.pluck(item, keys);
			items[i] = args.many ? item : item[keys[0]];
		});

		return items;
	};

	/**
	 * Limit the number of items an array can have
	 * @param {array} arr 
	 * @param {number} limit if the limit is negative, the slicing will be made from the start of the array
	 * @returns arr
	 */
	this.limit = function (arr, limit){
		if (utils.is.nbr(limit) && arr.length > Math.abs(limit)){
			if (limit < 0){
				var index = arr.length - Math.abs(limit);
				arr.splice(0, index);
			}else{
				arr.splice(limit);
			}
		}
		return arr;
	};

	// grouping ----------------------------------------------------------------
	this.group = function (arr, key, args){
		if (utils.is.fn(args)){
			args = {'callback':args};
		}
	
		args             = args || {};
		args.callback    = args.callback || null;
		args.groupKey    = args.groupKey || 'id';
		args.childrenKey = args.childrenKey || 'children';
		args.countKey    = 'countKey' in args ? args.countKey : 'count';
		args.skipIds     = utils.toArray(args.skipIds || [null]);
		args.return      = args.return || '';
		
		if (!arr.length){
			return [];
		}
	
		var groups      = {};
		var packGroups  = [];  // when the group_id change, then we change packs
		var lastPackId  = null;
		var currentPack = null;
	
		utils.each(arr, function (item, i){
			var groupId = utils.get(item, key) || null;
			var group 	= groups[groupId];

			if (~args.skipIds.indexOf(groupId)){
				return;
			}
	
			// create group --------------------------------------------------------
			if (!group){
				group = utils.apply(args.callback, [item, groupId], null, {});
	
				// make sure the "groupKey" and "childKey" keys are set
				if (!group[args.groupKey]){
					group[args.groupKey] = groupId;
				}
				if (!group[args.childrenKey]){
					group[args.childrenKey] = [];
				}
			}

			if (args.countKey){
				group[args.countKey] = group[args.countKey] || 0;
				group[args.countKey]++;
			}
	
			group[args.childrenKey].push(item);
			groups[groupId] = group;
	
			// pack groups ---------------------------------------------------------
			// (group only when the previous item is the same)
	
			// current pack is finished
			if (groupId !== lastPackId && currentPack){
				packGroups.push(currentPack);
				currentPack  = null;
			}
	
			if (!currentPack){
				currentPack = utils.apply(args.callback, [item], null, {});
	
				// make sure the "group_key" and "child_key" keys are set
				if (!currentPack[args.groupKey]){
					currentPack[args.groupKey] = groupId;
				}
				if (!currentPack[args.childrenKey]){
					currentPack[args.childrenKey] = [];
				}
			}
	
			currentPack[args.childrenKey].push(item);
			lastPackId = groupId;
		});
	
		if (currentPack){
			packGroups.push(currentPack);
		}
	
		if (args.return === 'array'){
			groups = utils.object.values(groups);
		}else if (args.return === 'pack'){
			groups = packGroups;
		}
	
		return groups;
	};

	this.tree = function (arr, args){
		args             = args || {};
		args.itemKey     = args.itemKey || 'id';
		args.parentKey   = args.parentKey || 'parent';
		args.depthKey    = args.depthKey || 'depth';
		args.childrenKey = args.childrenKey || 'children';
		args.root        = args.root || null;
		args.filter      = args.filter || null;
		args.return      = args.return || null;

		var parents  = [];
		var children = {};
		var flatten  = [];

		utils.each(arr, function (item, i){
			if (utils.is.fn(args.filter)){
				var response = utils.apply(args.filter, [item, i]);

				if (!response){
					return;
				}
			}
	
			var parentId = utils.get(item, args.parentKey);
			if (!utils.is(parentId)){
				parentId = null;
			}

			if (parentId === args.root){
				parents.push(item);
			}else{
				if (!children[parentId]){
					children[parentId] = [];
				}
				children[parentId].push(item);
			}
		});

		function _walk (items, depth){
			depth = depth || 0;

			for (var i in items){
				var item         = items[i];
				var itemId       = utils.get(item, args.itemKey);
				var itemChildren = children[itemId] || null;

				if (args.return === 'flatten'){
					item[args.depthKey] = depth;
					flatten.push(item);
				}
	
				if (itemChildren){
					itemChildren = _walk(itemChildren, depth + 1);
				}
	
				if (args.return !== 'flatten'){
					item[args.childrenKey] = itemChildren || [];
				}
	
				items[i] = item;
			}
	
			return items;
		}

		var tree = _walk(parents);
		return args.return == 'flatten' ? flatten : tree;
	};

	this.traverse = function (arr, args){
		arr = utils.toArray(arr);

		if (utils.is.either(args, 'fn,arr')){
			args = {'callback':args};
		}

		args          = args || {};
		args.key      = args.key || 'children';
		args.callback = args.callback || null;
		args.context  = args.context || null;

		var callback1 = null;
		var callback2 = null;

		if (utils.is.arr(args.callback)){
			callback1 = args.callback[0];
			callback2 = args.callback[1];
		}else{
			callback1 = args.callback;
		}

		function _touch (item, index, siblings, parent, depth){
			index = parseFloat(index);
			depth = depth || 0;

			var a = {
				'index'   : index,
				'parent'  : parent,
				'siblings': siblings,
				'previous': siblings[index - 1],
				'next'    : siblings[index + 1],
				'depth'   : depth,
			};
	
			item = utils.apply(callback1, [item, a], args.context, item);
	
			var children = item[args.key] || [];
			var filtered = [];
	
			if (utils.is.arr(children)){
				for (var i in children){
					var response = _touch(children[i], i, children, item, depth + 1);
					if (utils.is(response)){
						filtered[i] = response;
					}
				}
			}
	
			item[args.key] = filtered;
			
			item = utils.apply(callback2, [item, a], args.context, item);
			
			return item;
		}

		var filtered = [];
		for (var i in arr){
			var response = _touch(arr[i], i, arr);

			if (utils.is(response)){
				filtered[i] = response;
			}
		}
	
		return filtered;
	};

	this.flatten = function (arr, args){
		if (utils.is.fn(args)){
			args = {'format':args};
		}

		args         = args || {};
		args.format  = args.format || null;
		args.context = args.context || null;
		args.key     = args.key || 'children';

		var flatten = [];
		utils.array.traverse(arr, {'key':args.key, 'callback':function (item){
			var item = utils.format(item, args.format, args.context);
			if (item){
				flatten.push(item);
			}
		}});

		return flatten;
	};

    // casting -----------------------------------------------------------------
	this.toKeys = function (arr, fallback){
		fallback = fallback === undefined ? true : fallback;

		var keys = {};
		utils.each(arr, function (v, i, a){
			if (a.type === 'object'){
				keys[i] = v;
			}else{
				keys[v] = fallback;
			}
		});

		return keys;
	};
	
	this.to4Values = function (arr, args){
		if (utils.is.str(args)){
			args = {'separator':args};
		}else if (utils.is.fn(args)){
			args = {'format':args};
		}

		args            = args || {};
        args.separator  = args.separator || null;
        args.format     = args.format || utils.fn.empty;
        args.fallback   = args.fallback || null;

		// auto detect the separator
		if (utils.is.str(arr) && !args.separator){
			if (~arr.indexOf(';')) 		args.separator = ';';
			else if (~arr.indexOf(',')) args.separator = ',';
			else if (~arr.indexOf('x')) args.separator = 'x';
			else 						args.separator = ' ';
		}

		function _get (options){
			var v = utils.defined(options);
			if (utils.is.fn(args.format)) v = args.format(v);
			if (utils.is.invalid(v))      v = args.fallback;
			return v;
		}

		arr = utils.toArray(arr, args.separator);

		return [
			_get([arr[0]]),
			_get([arr[1], arr[0]]),
			_get([arr[2], arr[0]]),
			_get([arr[3], arr[1], arr[0]])
		]
	};

	this.to2Values = function (arr, args){
		arr = utils.array.to4Values(arr, args);
		return arr.slice(0,2);
	};

	this.to4Numbers = function (arr, args){
		if (utils.is.str(args)){
			args = {'separator':args};
		}
		args          = args || {};
		args.format   = parseFloat;
		args.fallback = 'fallback' in args ? args.fallback : 0;
		return utils.array.to4Values(arr, args);
	};

	this.to2Numbers = function (arr, args){
		arr = utils.array.to4Numbers(arr, args);
		return arr.slice(0,2);
	};
});
Utils.add('el', function (utils, DOM, RE){
	// consts ------------------------------------------------------------------
	RE.DELEGATE_EVENT  = /([^:]+)\:(.+)/;
	RE.NAMESPACE_EVENT = /([^.]+)\.(.+)/;
	RE.CSS_VARS        = /(-{2}[^)]+)/i;
	RE.CSS_NUMBER 	   = /((?:^|\s|\()\-?[0-9]+(?:\.[0-9]+(?:e-[0-9]+)?)?(?=\)|\s|$))/g;
	//RE.CSS_URL 		   = /(?:^|\s)(?!url\(\")([^\s]+(?:(?:\/[^\s]+)|(?:\.[a-z]+)))(?:\s|$)/g;
	RE.CSS_URL 		   = /(?:^|\s)(?!url\(\"?)([^\s]+(?:(?:\/[^)]+)|(?:\.[a-z]+)))(?:\s|$)/g;
	RE.CSS_SELECTOR    = /(\#[a-z][\w-]*)|(\.[\-a-z][\w-]*)|(\[[^\]]+\])|(\{[^\]]+\})|(\=.+)|([a-z][\w-]*)/gi;

	DOM.CACHE = {
		SCROLL_TO : '__SCROLL_TO__',
		TRANSFORMS: '__TRANSFORMS__',
	};

	DOM.CANVAS = {};

	DOM.SVG_NAMESPACES = {
		'xlink:href' : 'http://www.w3.org/1999/xlink',
	};

	DOM.TRANSFORM_VALUES = [
		'translateX', 'translateY', 'translateZ',
		'scale', 'scaleX', 'scaleY', 'scaleZ',
		'rotate', 'rotateX', 'rotateY', 'rotateZ',
		'skewX', 'skewY',
		'perspective', 'perspectiveX', 'perspectiveY',
		'centerX', 'centerY',
	];

	DOM.PX_VALUES = [
		'top','right','bottom','left',
		'height','width','min-height','max-height','min-width','max-width',
		'border-top','border-right','border-bottom','border-left','border-top-width', 'border-right-width','border-bottom-width','border-left-width','border-radius',
		'border-spacing',
		'background-size', 'background-position', // @note do not put "background" in this, espacially when using rgba()
		'margin','margin-top','margin-right','margin-bottom','margin-left',
		'padding','padding-top','padding-right','padding-bottom','padding-left',
		'font-size',
	];

	DOM.URL_VALUES = [
		'background', 'background-image',
		'border', 'border-image', 'border-left',
		'cursor',
		'list-style',
	];

	DOM.PREFIXED_STYLE_NAMES = {};
	DOM.COMPUTED_STYLE       = null;

	DOM.EVENTS        = {};
	DOM.CUSTOM_EVENTS = {};

	DOM.ALT_DELEGATE_EVENTS = {
		'mouseenter'  : 'mouseover',
		'mouseleave'  : 'mouseout',
		'pointerenter': 'pointerover',
		'pointerleave': 'pointerout',
	};
	
	DOM.EVENT_CLASSES = {
		'click'		    : 'MouseEvent',
		'dblclick'		: 'MouseEvent',
		'mouseover'     : 'MouseEvent',
		'mouseout'	    : 'MouseEvent',
		'mouseenter'	: 'MouseEvent',
		'mouseleave'	: 'MouseEvent',
		'mousemove'	    : 'MouseEvent',
		'mousedown'	    : 'MouseEvent',
		'wheel'		    : 'MouseEvent',
		'select'	    : 'MouseEvent',
		'focus'	        : 'FocusEvent',
		'blur'	        : 'FocusEvent',
		'reset'	        : 'Event',
		'submit'	    : 'Event',
		'keydown'	    : 'KeyboardEvent',
		'keypress'	    : 'KeyboardEvent',
		'keyup'	        : 'KeyboardEvent',
		'change'	    : 'Event',
		'load'	        : 'ProgressEvent',
	};

	DOM.ELEMENT_DISPLAY = {};

	DOM.MOUSE_BUTTONS = {
		0 : null,
		1 : 'primary',
		2 : 'secondary',
		4 : 'auxiliary',
		8 : 'back',
		16: 'forward',
	};

    // methods -----------------------------------------------------------------
	this.is = function (el, selector){
		if (!el) return false;
		
		if (utils.is.el(selector, true)){
			selector = utils.dom.get(selector);
		}

		if (el === selector){
			return true;
		}else if (utils.is.fn(selector)){
			return !!selector(el);
		}else if (utils.is.obj(selector, true)){
			var i, values;

			if ('tag' in selector){
				if (el.tagName.toLowerCase() !== selector.tag.toLowerCase()){
					return false;
				}
			}			
			if ('html' in selector){
				if (el.innerHTML.trim() !== selector.html.trim()){
					return false;
				}
			}
			if ('text' in selector){
				if (el.innerText.trim() !== selector.html.trim()){
					return false;
				}
			}
			if ('contains' in selector){
				if (!~el.innerText.trim().indexOf(selector.contains.toString().trim())){
					return false;
				}
			}
			if ('style' in selector){
				values = utils.dom.style(el);
				for (i in selector.style){
					if (values[i] !== selector.style[i]){
						return false;
					}
				}
			}
			if ('attrs' in selector){
				values = utils.dom.attrs(el);
				for (i in selector.attrs){
					if (values[i] !== selector.attrs[i]){
						return false;
					}
				}
			}
			if ('classnames' in selector){
				// @todo check if the classnames are in the el
			}
			if ('value' in selector){
				// @todo
			}

			// @todo others match maybe... (:empty, :button, :checked, :disabled, ...)

			return true;
		}else if (utils.is.string(selector)){
			var match = (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector);
			var value = false;

            try{
				value = match && match.call(el, selector);
			}catch(e){
				// @info in IE11 and less, a selector starting with a dash isnt valid (eg.: classname "-test" will break)
			}

			return value;
		}else if (utils.is.dom(selector)){
            var compare = utils.dom.get(selector);
            // check if the element is the same OR if both ar Dom Roots (document, body, html)
			return el === compare || (utils.is.dom(selector, true) && utils.is.dom(compare, true));
		}else{
			return false;
		}
	};

	this.contains = function (el, child, includeSelf){
		child = utils.dom.get(child);

		if (includeSelf && el && el === child){
			return true;
		}

		return el && child && el.contains(child);
	};

	this.empty = function (el){
		while (el.childNodes.length){
            el.removeChild(el.childNodes[0]);
        }
        return el;
	};

	this.replace = this.swap = function (el, selector, args){
		if (args === undefined){
			args = true;
		}
		if (utils.is.bool(args)){
			args = {
				'attrs'   : true,
				'children': true,
			};
		}

		args 			= args || {};
		args.attrs 		= 'attrs' in args ? args.attrs : true;
		args.class 		= 'class' in args ? args.class : true;
		args.data 		= 'data' in args ? args.data : true;
		args.skip	    = 'skip' in args ? args.skip : '';
		args.cache 		= 'cache' in args ? args.cache : false;
		args.children 	= 'children' in args ? args.children : true;

		var target = utils.dom.get(selector);
		if (!target) return;

		el.parentNode.insertBefore(target, el);
		el.parentNode.removeChild(el);

		// move the children over
		if (args.children){
			var i=0, l=el.childNodes.length;
			for (;i<l;++i){
				target.appendChild(el.childNodes[i]);
			}
		}

		if (args.attrs){
			var skip  = utils.toArray(args.skip);
			var attrs = utils.el.attrs(el);
			for (var i in attrs){
				if (
					(skip.length && ~skip.indexOf(i)) ||
					(i === 'class' && !args.class) ||
					(i.indexOf('data') === 0 && !args.data)
				) continue;

				el.removeAttribute(i);
				target.setAttribute(i, attrs[i]);
			}
		}

		if (args.cache){
			var cache = utils.cache(el);
			utils.cache(target, cache);

			// @todo remove the cache of the old element
		}

		return target;
	};

	this.clone = function (el, args){
		if (utils.is.nbr(args)){
			args = {'times':args};
		}else if (utils.is.bool(args)){
			args = {'events':args, 'cache':args};
		}

		args 		= args || {};
		args.times 	= 'times' in args ? args.times : null;
		args.events = args.events || false;
		args.cache 	= args.cache || false;
		args.deep 	= 'deep' in args ? args.deep : true;

		var clones 	= [];
		var times 	= args.times === null ? 1 : args.times;

		utils.each(times, function (){
			var clone = el.cloneNode(args.deep);

			if (args.events){
				// @todo
			}
			if (args.cache){
				// @todo
			}

			clones.push(clone);
		});

		return args.times === null ? clones[0] : clones;
	};

	// visibility --------------------------------------------------------------
	this.isVisible = function (el){
		if (el === document || el === window || el === document.documentElement){
			return true;
		}

		if (!el){
			return false;
		}

		// svg element is checked differently
		if (utils.is.svg(el) && el.getBBox){
			var b = el.getBBox();
			return b.width > 0 || b.height > 0;
		}
		
		// if a text node, move to the parent
		if (el.nodeType === 3){
			el = el.parentElement;
		}
		
		return !!(el.offsetWidth || el.offsetHeight || (el.getClientRects && el.getClientRects().length));
	};

	this.inView = function (el, args){
		args = args || {};
		
		var bounds = utils.el.bounds(el, {'parent': args.parent || true});
		var scroll = utils.el.scroll(bounds.parent);
		var bounds = utils.math.toBounds(bounds.bbox);

		var inView = (
			(bounds.top >= scroll.top && bounds.top <= scroll.bottom) ||
			(bounds.bottom >= scroll.top && bounds.bottom <= scroll.bottom) ||
			(bounds.top <= scroll.top && bounds.bottom >= scroll.bottom)
		);

		var visibleH = Math.min(scroll.bottom, bounds.bottom) - Math.max(scroll.top, bounds.top);
		visibleH = visibleH < 0 ? 0 : visibleH;
		
		// var visibleW = 

		// if (viewRatio){
		// 	var visibleHeight 	= Math.min(scrollBottom, bounds.bottom) - Math.max(scrollTop, bounds.top);
		// 	var ratioVisible 	= visibleHeight / bounds.height;
		// 	var ratioScreen		= visibleHeight / window.innerHeight;

		// 	inView = ratioVisible >= this.props.inView || ratioScreen >= this.props.inView;
		// }


		// @todo optimize this with option of percentage in view

		return visibleH > 0;
	};

	// nodes -------------------------------------------------------------------
	this.children = function (el, args){
        if (utils.is.bool(args)){
            args = {'text':args};
        }else if (utils.is.str(args)){
			args = {'selector':args};
		}

		args          = args || {};
		args.text     = 'text' in args ? args.text : false;
		args.selector = 'selector' in args ? args.selector : null;

        var children = [];
		if (el.children && !args.text){
			children = el.children || [];
		}else{
			var nodes    = el.childNodes;
			var children = [];
			var i=0, node;
			while (node = nodes[i++]){
				if (node.nodeType === 1 || (args.text && node.nodeType === 3)){
					children.push(node);
				}
			}
		}
		
		children = utils.toArray(children);
		
		if (args.selector){
			children = utils.map(children, function (node){
				return utils.el.is(node, args.selector) ? node : undefined;
			});
		}

		return children;
	};

	this.siblings = function (el, args){
        if (utils.is.bool(args)){
            args = {'text':args};
        }else if (utils.is.str(args)){
			args = {'selector':args};
		}

		args          = args || {};
		args.text     = 'text' in args ? args.text : false;
		args.previous = 'previous' in args ? args.previous : true;
		args.next     = 'next' in args ? args.next : true;

		var els  = [];
		var node = el;
		if (args.previous){
			while (node = node.previousSibling){
				if (node.nodeType !== 1 && !(args.text && node.nodeType === 3)) continue;
				els.unshift(node);
			}
		}

		var node = el;
		if (args.next){
			while (node = node.nextSibling){
				if (node.nodeType !== 1 && !(args.text && node.nodeType === 3)) continue;
				els.push(node);
			}
		}

		els = utils.toArray(els);

		if (args.selector){
			els = utils.map(els, function (node){
				return utils.el.is(node, args.selector) ? node : undefined;
			});
		}
        
		return els;
	};

	this.parents = function (el, selector, untilSelector){
		var parents = [];

		if (!el){
			return parents;
		}

		while ((el = el.parentNode)){
			if (!selector || (selector && utils.el.is(el, selector))){
				parents.push(el);
			}
			if (utils.el.is(el, untilSelector)){
				break;
			}
		}

		return parents;
	};

	this.closest = function (el, selector, untilSelector){
		var isFound     = false;
		var untilParent = utils.dom.get(untilSelector);

		// @todo use utils.el.is() for the utilsSelector

		// check first if it's not already out of bounds
		if (untilParent && untilParent !== el && !utils.el.contains(untilParent, el)){
			return null;
		}

		while (el && !isFound){
			if (utils.dom.is(el, selector)){
				isFound = true;
			}
			if (isFound || el === untilParent){
				break;
			}
			el = el.parentNode;
		}

		return isFound ? el : null;
	};

	this.focusable = function (el, selector, args){
		if (utils.is.obj(selector, true)){
			args     = selector;
			selector = false;
		}

		if (utils.is.either(args, 'str,nbr')){
			args = {'index':args};
		}else if (args === true){
			args = {'self':args};
		}

		args       = args || {};
		args.index = 'index' in args ? args.index : null;
		args.self  = args.self || false;

		var ctx = el || document;
		var els = utils.dom.getAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])', {
			'context'       : ctx,
			'filter'		: selector,
			'includeContext': args.self,
		});

		if (args.index === ':first'){
			return els[0];
		}else if (args.index === ':last'){
			return els[els.length-1];
		}else if (utils.is.nbr(args.index)){
			return els[args.index];
		}

		return els;
	};

	this.scrollParent = function (el, args){
		args 			= args || {};
		args.fallback 	= 'fallback' in args ? args.fallback : window;
		args.direction 	= 'direction' in args ? args.direction : 'any';
		args.strict 	= 'strict' in args ? args.strict : false;		// strick = the scrollbar needs to be there (either SCROLL or the content is bigger than the container)
		args.all 		= args.all || false;

		var parents = [];
		var style, oWidth, sWidth, cWidth, oHeight, sHeight, cHeight, isScrollWidth, isScrollHeight;
		
		while (el && ((!parents.length && !args.all) || args.all)){
			//if (utils.is.dom(el, true)) break;

			style          = utils.is.el(el) ? window.getComputedStyle(el) : null;
			oWidth         = style ? style.getPropertyValue('overflow-x') : null;
			sWidth         = el.scrollWidth;
			cWidth         = el.clientWidth
			oHeight        = style ? style.getPropertyValue('overflow-y') : null;
			sHeight        = el.scrollHeight;
			cHeight        = el.clientHeight;
			isScrollWidth  = oWidth === 'scroll' || (oWidth === 'auto' && (!args.strict || sWidth > cWidth));
			isScrollHeight = oHeight === 'scroll' || (oHeight === 'auto' && (!args.strict || sHeight > cHeight));

			if (
				(args.direction === 'any' && (isScrollWidth || isScrollHeight)) ||
				(args.direction === 'both' && isScrollWidth && isScrollHeight) ||
				(args.direction === 'vertical' && isScrollHeight) ||
				(args.direction === 'horizontal' && isScrollWidth)
			){
				parents.push(el);
			}

			el = el.parentNode;
		}

		if (args.fallback){
			parents.push(args.fallback);
		}
		
		return args.all ? parents : parents[0];
	};
	
	this.offsetParent = function (el){
		if (el.offsetParent){
			return el.offsetParent;
		}else{
			// for some elements, the offsetParent is always null
			while (el && el !== document){
				el = el.parentNode;

				var style = window.getComputedStyle(el);
				if (style.position !== 'static'){
					return el;
				}
			}

			return window.body;
		}
	};

	this.extract = function (el, args){
		if (utils.is.str(args)){
			args = {'single':args};
		}
		
		args                = args || {};
		args.single         = 'single' in args ? args.single : 'element';
		args.group          = 'group' in args ? args.group : 'group';
		args.clean          = args.clean || false;                         // remove the attribute
		args.filter         = args.filter || null;
		args.context        = args.context || null;
		args.alias 			= args.alias || null;
		args.includeSelf 	= args.includeSelf || null;
		args.excludeClosest = args.excludeClosest || null;

		var elements 		= {'self':el};
		var selectorSingle 	= args.single ? '[' + args.single + ']' : null;
		var selectorGroup 	= args.group ? '[' + args.group + ']' : null;
		var selector		= '';

		if (selectorSingle && selectorGroup){
			selector = [selectorSingle, selectorGroup].join(',');
		}else if (args.single){
			selector = selectorSingle;
		}else if (args.group){
			selector = selectorGroup;
		}

		var children = utils.dom.getAll(selector, {
			'context'       : el,
			'includeContext': args.includeSelf,
			'excludeClosest': args.excludeClosest
		});

		for (var i=0, l=children.length; i<l; ++i){
			var child 	= children[i];
			var single  = args.single ? child.getAttribute(args.single) : null;
			var group 	= args.group ? child.getAttribute(args.group) : null;

			single = utils.format(single, args.filter, args.context);
			group  = utils.format(group, args.filter, args.context);

			_node(single, child);
			_node(group, child, true);
		}

		function _node (name, child, isArr){
			if (!name) return;

			// modifiers
			var remove = !!~name.indexOf('!remove');
			name = name.replace(/!.+/, '').trim();

			var attr = '';
			if (isArr){
				attr 		   = args.group;
				elements[name] = elements[name] || [];
				elements[name].push(child);
			}else{
				attr 		   = args.single;
				elements[name] = child;
			}

			if (args.clean){
				child.removeAttribute(attr);
			}

			// automaticly add a &--alias classname
			if (args.alias){
				utils.el.addClass(child, '&--' + name, args.alias);
			}

			if (remove){
				child.parentNode.removeChild(child);
			}
		}

		return elements;
	};

    // props/attrs/data --------------------------------------------------------
	var _to4Values = function (s, p){
		var d 	= ['top','right','bottom','left'];
		var vls = [];
		var i=0, l=d.length, k, v;

		for (; i<l; ++i){
			k = p.replace('{direction}', d[i]);
			v = parseFloat(s[k] || 0);
			vls.push(v);
		}

		vls.vertical 	= vls[0] + vls[2];
		vls.horizontal 	= vls[1] + vls[3];

		return vls;
	};
	
	this.tag = function (el, replace){
		var tag = (el.tagName || '').toLowerCase();

		if (replace === false){
			// move the child nodes out of the parent
			var children = document.createDocumentFragment();
			// var empty    = document.createTextNode('\xA0');
			// children.appendChild(empty);
			
			for (var i=0, l=el.childNodes.length; i<l; ++i){
				var c = el.childNodes[i];
				console.log(c);
				c && children.appendChild(c); 
			}
			// utils.each(el.childNodes, function (c){ 
			// 	console.log(c);

			// 	c && children.appendChild(c); 
			// });

			// console.log(children.childNode);
			
			el.parentNode.insertBefore(children, el);
			el.parentNode.removeChild(el);
		}else if (replace && replace !== tag){
			tag     = replace;
			replace = document.createElement(tag);

			var i=0, l=el.childNodes.length;
			for (;i<l;++i){
				replace.appendChild(el.childNodes[0]);
			}
			
			el.parentNode.insertBefore(replace, el);
			el.parentNode.removeChild(el);

			// attributes/events/...
			var attrs = utils.el.attrs(el);
			utils.el.attrs(replace, attrs);

			// @todo, add the events/props/cached data, ...

			el = replace;

			return replace;
		}
		return tag;
	};
	
	this.props = function (el, key, value){
        var values = utils.toSet(key, value);
        if (values){
            var i;
            for (i in values){
				if (utils.is.fn(el[i])){
                    el[i].apply(null, values[i]);
                }else{
                    el[i] = values[i];
                }
			}
        }else if (key){
            return el[key];
        }else{
            return null;
        }
    };
	
	this.attrs = function (el, key, value){
		var values = utils.toSet(key, value);
		
        if (values){
			var cache 		= utils.cache(el, '__ATTRS__') || {};
			var hasChanged 	= false;
			var clear 		= utils.is.obj(key) && value === true;
			var i, v, o;

			if (clear){
				cache = {};
				while (el.attributes.length > 0) {
					el.removeAttribute(el.attributes[0].name);
				}
			}
			
            for (i in values){
				v = values[i];
				o = cache[i];
				
				if (v === o) continue;
				
				// cache[i] = value;
				cache[i] = v;

				if (utils.is.not(v)){
					el.removeAttribute(i);
                }else{
					v = v === true ? '' : v;

					if (i in DOM.SVG_NAMESPACES){
						el.setAttributeNS(DOM.SVG_NAMESPACES[i], i, v);
					}else{
						el.setAttribute(i, v);	
					}
				}
				
				hasChanged = true;
			}

			utils.el.cache(el, '__ATTRS__', cache);

			return hasChanged;
        }else if (key){
            return el.getAttribute(key);
        }else{
            values = {};

            var i=0, l=el.attributes.length, k, v;
            for (;i<l;++i){
                k = el.attributes[i].name.toString();
                v = el.attributes[i].value.toString();
                values[k] = v;
            }

            return values;
        }
	};

	this.data = function (el, key, value, args){
		if (utils.is.bool(args)){
			args = {'json':args};
		}

		args      = args || {};
		args.json = 'json' in args ? args.json : true;
		args.cache= 'cache' in args ? args.cache : true;
		
		var values = utils.toSet(key, value);
		var json   = json !== undefined ? json : true;
		var cache  = args.cache && utils.cache(el, '__DATA__');

		
		if (!cache){
			// check for JSON data too
			var script = utils.dom.get('> script[type="json/data"]', {'context':el});
			var data   = script ? utils.toJson(script.innerHTML) : null;
			
			cache = data || {};
			
			var i=0, l=el.attributes.length, n, v;
			for (; i<l; ++i){
				n = el.attributes[i].name.toString();
				v = el.attributes[i].value.toString();

				if (n.indexOf('data-') !== 0) continue;

				n		 = utils.string.toCamelCase(n.replace('data-', ''));
				cache[n] = utils.toValue(v, {'json':args.json, 'clean':false});
			}

			utils.el.cache(el, '__DATA__', cache);
		}

		if (values){
			var hasChanged = false;
			for (n in values){
				v = values[n];
				o = cache[n];

				if (v === o) continue;
		
				cache[n] = v;

				if (typeof v === 'object'){
					v = JSON.stringify(v);
				}

				n = 'data-' + utils.string.toDashCase(n);

				if (v === null){
					el.removeAttribute(n);
				}else{
					el.setAttribute(n, v);
				}

				hasChanged = true;
			}
			return hasChanged;
		}else{
			return key !== undefined ? cache[key] : cache;
		}
	};
	
	this.cache = function (el, key, value){
		return utils.cache(el, key, value);
	};

	this.index = function (el, selector){
		var els = selector ? utils.dom.getAll(selector) : utils.toArray(el.parentNode.children);
		return els.indexOf(el);
	};

	this.bounds = function (el, args){
		if (utils.is.bool(args)){
			args = {'parent':args};
		}

		args         = args || {};
		args.offsetX = args.offsetX || 0;
		args.offsetY = args.offsetY || 0;
		args.parent  = args.parent || false;	// if parent=true, find the closest scrollable parent
		args.reflow  = args.reflow || false;

		if ('scrollParent' in args){
			utils.deprecated('utils.el.bounds -> args.scrollParent', 'args.parent');
			args.parent = args.scrollParent;
		}

		// @todo add args to compare the bounds of this element and another one (especially for a parent element)

		if (el !== window && utils.is.dom(el, true)){
			el = document.body;
		}

		var bounds = {
			'node'        : el,
			'visible'     : utils.el.isVisible(el),
			'fit'		  : null,
			'fitX' 		  : null,
			'fitY' 		  : null,
			'x'           : 0,
			'y'           : 0,
			'width'       : 0,
			'height'      : 0,
			'top'         : 0,
			'right'       : 0,
			'bottom'      : 0,
			'left'        : 0,
			'centerX'     : 0,
			'centerY'     : 0,
			'padding'     : [0,0,0,0],
			'border'      : [0,0,0,0],
			'margin'      : [0,0,0,0],
			'center'      : null,
			'scale'       : 0,
			'scrollTop'   : 0,
			'scrollLeft'  : 0,
			'scrollHeight': 0,
			'scrollWidth' : 0,
			'parent'      : null,
			'vbox'        : null, // view box
			'vrbox'		  : null, // relative view box (relative to the parent with scroll position)
			'cbox'		  : null, // content box
			'pbox'        : null, // padding box
			'bbox'        : null, // border box
			'mbox'        : null, // margin box
			'media'		  : null, // media box (if image or video) 
		};

		// TODO deal with image bg

		bounds.padding.horizontal = bounds.padding.vertical = 0;
		bounds.border.horizontal = bounds.border.vertical = 0;
		bounds.margin.horizontal = bounds.margin.vertical = 0;

		if (el === window){
			// this is the browser viewport width/height
			bounds.width  = window.innerWidth;
			bounds.height = window.innerHeight;
		// find dimension of text node
		}else if (el && el.nodeType === 3){
			var range, rect, r, p;

			p = el.parentElement;
			args.reflow && (p.offsetHeight);

			// the parent element will tell us of the textNode is visible
			bounds.visible = utils.el.isVisible(p);

			range = document.createRange();
			range.selectNodeContents(el);
			rect  = range.getClientRects();

			bounds.left = Infinity;
			bounds.top  = Infinity;

			var i=0, l=rect.length, r;
			for (; i<l; ++i){
				r 	 	 	  = rect[i];
				bounds.left   = Math.min(r.left, bounds.left);
				bounds.top    = Math.min(r.top, bounds.top);
				bounds.width  = Math.max(r.width, bounds.width);
				bounds.height = Math.max(r.height, bounds.height);
			}
		}else if (el && bounds.visible){
			args.reflow && (el.offsetHeight); // force a reflow

			var s     	   = window.getComputedStyle(el);
			var b 	  	   = el.getBoundingClientRect();
			bounds.left    = b.left;
			bounds.top 	   = b.top;
			bounds.width   = b.width;
			bounds.height  = b.height;
			bounds.padding = _to4Values(s, 'padding-{direction}');
			bounds.border  = _to4Values(s, 'border-{direction}-width');
			bounds.margin  = _to4Values(s, 'margin-{direction}');
		}

		// @info clientWidth/Height doesn't return floating points, so there's never any decimals (use getBoudingClientRect() for the real data)
		var x=0, y=0, h=0, w=0;
		
		if (el && bounds.visible){
			x = bounds.left;                              // this is the x with the border
			y = bounds.top;                               // this is the y with the border
			h = (el.clientHeight || bounds.height || 0);  // this is the inner height without the border
			w = (el.clientWidth || bounds.width || 0);    // this is the inner width without the border

			x += args.offsetX;
			y += args.offsetY;

			var parent = window;
			if (args.parent && utils.is.node(el)){
				parent = args.parent === true ? utils.dom.scrollParent(el) : args.parent;
			}
			
			var px = 0;
			var py = 0;
			
			// @todo verify this, so it doesn't break anything
			if (utils.is.dom(parent, true) && parent !== document.body){
				parent = window;
			}

			if (parent && parent !== window){
				args.reflow && parent.offsetHeight; // forced reflow

				var pb = parent.getBoundingClientRect();
				px = parent.scrollLeft - pb.left;
				py = parent.scrollTop - pb.top;				
			}else if (el !== window){
				px = (window.scrollX || window.pageXOffset || 0);
				py = (window.scrollY || window.pageYOffset || 0);
			}
		
			bounds.parent = bounds.scrollParent = parent;

			x += px;
			y += py;
		}

		var cBox = utils.math.toBounds([x, y, w, h], {'padding':bounds.padding, 'offsetX':bounds.border[3], 'offsetY':bounds.border[0]});
		var pBox = utils.math.toBounds(cBox, {'margin':bounds.padding});
		var bBox = utils.math.toBounds(pBox, {'margin':bounds.border});
		var mBox = utils.math.toBounds(bBox, {'margin':bounds.margin});
		var vBox = utils.math.toBounds([bounds.left, bounds.top, bounds.width, bounds.height]);
		var sBox = utils.math.toBounds([x, y, bounds.width, bounds.height]);

		bounds.x       = cBox.x;
		bounds.y       = cBox.y;
		bounds.width   = cBox.width;
		bounds.height  = cBox.height;
		bounds.top     = cBox.top;
		bounds.right   = cBox.right;
		bounds.bottom  = cBox.bottom;
		bounds.left    = cBox.left;
		bounds.centerX = cBox.centerX;
		bounds.centerY = cBox.centerY;
		bounds.center  = cBox.center;
		bounds.cbox    = bounds.contentBox  = cBox;
		bounds.pbox    = bounds.paddingBox  = pBox;
		bounds.bbox    = bounds.borderBox   = bBox;
		bounds.mbox    = bounds.marginBox   = mBox;
		bounds.vbox    = bounds.viewportBox = bounds.viewport = vBox;  			 // this consider the transform:scale()
		bounds.svbox   = bounds.vrbox = bounds.rbox = bounds.relativeBox = sBox; // scroll view box
		
		// if it's a media, it could use "object-fit", so we try getting the image position 
		if (el instanceof HTMLElement && (el instanceof Image || el.tagName.toLowerCase() === 'video')){
			var isVid = el.tagName.toLowerCase() === 'video';
			var style = window.getComputedStyle(el);
			var fit   = style.objectFit;
			var pos   = style.objectPosition.split(' ').map(function (v){ return parseFloat(v) / 100; });
			var x 	  = vBox.x;
			var y 	  = vBox.y;
			var w 	  = vBox.width;
			var h 	  = vBox.height;
			var ww    = isVid ? el.videoWidth : el.naturalWidth;
			var hh    = isVid ? el.videoHeight : el.naturalHeight;
			var rw    = w / ww;
			var rh    = h / hh;
			var r     = null;
			var xx    = x;
			var yy    = y;

			if (fit === 'cover'){
				r = Math.max(rw, rh); 
			}else if (fit === 'contain'){
				r = Math.min(rw, rh); 
			}else if (fit == 'fill'){
				ww = w;
				hh = h;
			}else if (fit === 'scale-down' && (ww > w || hh > h)){
				r = Math.max(rw, rh); 
			}

			// get the real size of the image
			if (r !== null){
				ww *= r;
				hh *= r;
				xx = x + ((w - ww) * pos[0]);
				yy = y + ((h - hh) * pos[1]);
			}

			bounds.media = utils.math.toBounds([xx, yy, ww, hh]);
			bounds.fit   = fit;
			bounds.fitX  = pos[0];
			bounds.fitY  = pos[1];
		}

		if (el === window){
			bounds.scrollTop    = (window.scrollY || window.pageYOffset || 0);
			bounds.scrollLeft   = (window.scrollX || window.pageXOffset || 0);
			bounds.scrollHeight = document.documentElement.scrollHeight || 0;
			bounds.scrollWidth  = document.documentElement.scrollWidth || 0;
		}else if (el){
			bounds.scale        = (Math.round(bounds.vbox.width) / el.offsetWidth) || 1;
			bounds.scrollTop    = el.scrollTop || 0;
			bounds.scrollLeft   = el.scrollLeft || 0;
			bounds.scrollHeight = el.scrollHeight !== el.clientHeight ? el.scrollHeight : 0;
			bounds.scrollWidth  = el.scrollWidth !== el.clientWidth ? el.scrollWidth : 0;
		}
		
		return bounds;
	};

	this.show = function (el, isForced){
		if (!el){
			return utils.fn.empty;
		}
		
		var isVisible  = utils.el.isVisible(el);
		var lastParent = null;
		
		function _display (el){
			var tag 	= el.tagName.toLowerCase();
			var display = DOM.ELEMENT_DISPLAY[tag];
			
			if (!display){
				var dummy = document.createElement(tag);

				document.body.appendChild(dummy);
				display = utils.el.style(dummy, 'display');
				document.body.removeChild(dummy);

				if (display === 'none'){
					display = 'block';
				}

				DOM.ELEMENT_DISPLAY[tag] = display;
			}

			return display;
		}

		function _show (el){
			var display = el.style.display || '';
			
			// @todo this is a quick fix
			if (el.__CACHE__ && el.__CACHE__.__STYLE__){
				el.__CACHE__.__STYLE__.display = '';
			}

			// first, try to show the element by removing the display value
			el.style.display = '';

			// if the element is still hidden (because of selector in the CSS)
			if (!utils.el.isVisible(el)){
				el.style.display = _display(el);
			}

			utils.cache(el, 'currentDisplay', display);
		}

		function _cancel (){
			if (lastParent){
				var e = el;
				while (e !== lastParent && (e = e.parentNode)){
					e.style.display = utils.cache(e, 'currentDisplay') || '';
				}
			}

			el.style.display = utils.cache(el, 'currentDisplay') || '';;
		}

		if (!isVisible){
			if (isForced){
				var e, p;
				e = el;

				while (!lastParent && e){
					p = e.parentNode;

					if (p && utils.el.isVisible(p)){
						lastParent = p;
					}else{
						_show(p);
					}

					e = p;
				}
			}

			_show(el);
		}

		return _cancel;
	};

	// html --------------------------------------------------------------------
	var _nodes = this._nodes = function (nodes, args){
		if (!nodes) return [];

		if (utils.is.str(nodes)){
			nodes = {'tag':nodes};
		}

		nodes = nodes instanceof Array ? nodes : [nodes];

		if (utils.is.fn(args) || utils.is.arr(args)){
			args = {'callback':args};
		}

		args          = args || {};
		args.alias    = args.alias || '';
		args.element  = args.element || null;
		args.callback = args.callback || null; // 

		args.replace  = args.replace || {};
		args.context  = args.context || null;
		
		var callback1 = null;
		var callback2 = null;
		if (utils.is.arr(args.callback)){
			callback1 = args.callback[0];
			callback2 = args.callback[1];
		}

		function _arr (list, clean){
			if (!utils.is(list)){
				list = [];
			}else if (!(list instanceof Array)){
				list = [list];
			}

			if (clean){
				list = utils.arr.filter(list, null, {'trim':false});
			}

			// @todo clean the list (remove null/undefined)
			var filtered = [];
			utils.each(list, function (v){
				if (utils.is.fn(v)){
					v = utils.apply(v, [args.alias, args.replace], args.context);
				}

				if (v in args.replace){
					v = args.replace[v];
				}

				if (v instanceof Array){
					filtered = filtered.concat(v);
				}else if (utils.is(v)){
					filtered.push(v);
				}
			});

			return filtered;
		}

		function _children (item, children, el, alias, depth){
			children = _arr(children);

			var childNodes1 = el && el.childNodes ? el.childNodes : [];  // live child nodes
			var childNodes2 = utils.toArray(childNodes1);                // cached child nodes (any chnages won't impact this)
			var nodes       = [];
			var index       = 0;
			var i=0, l=children.length, node;

			for (;i<l;++i){
				node = _node(
					children[i], 		// item
					childNodes1[index], // el
					item, 				// parent item
					el, 				// parent el
					childNodes2, 		// siblings
					index, 				// index
					alias, 				// alias
					depth || 0			// depth
				);

				if (node !== undefined){
					nodes.push(node);
					index++;
				}
			}

			return nodes;
		}

		function _node (item, el, parent, parentEl, siblings, index, alias, depth){
			var a = {
				'element'		: el,
				'parent' 		: parent, 
				'parentElement' : parentEl,
				'siblings'		: siblings,
				'index'			: index,
				'depth'			: depth,
				'alias'			: alias,
			};

			if (!utils.is(item)){
				return;
			}else if (utils.is.node(item)){
				utils.apply(callback1, [item, el, a]);
				return item;
			}else if (!utils.is.obj(item, true)){
				var value = item.toString();
				value = utils.string.replace(value, args.replace);

				// remove the "element" attribute since it's going to be inside a 
				if (utils.is.el(value)){
					value.removeAttribute('element');
				}

				utils.apply(callback1, [value, el, a]);
				return value;
			}

			var node = {
				'tag'    		 : item.tag in args.replace ? args.replace[item.tag] : item.tag || 'div',
				'key'    		 : utils.is(item.key) ? item.key : null,
				'el'     		 : el,
				'index'  		 : index,
				'depth'  		 : depth,
				'context'		 : item.context || null,
				// props
				'props'   		 : item.props || item.prop || {},
				'attrs'   		 : item.attrs || item.attr || {},
				'style'   		 : item.style || {},
				'class'   		 : item.class || item.classnames || item.classname || [],
				'data'    		 : item.data || {}, // might remove the "data"
				'meta'			 : item.meta || {},
				'events'  		 : item.events || item.event || {},
				'children'		 : item.children || item.html || [],
				// events
				'onMount'  		 : item.onMount || null,
				'onMounted'		 : item.onMounted || null,
				// meta
				'context' 		 : item.context || item,
				'isSingleParent' : false,
				'isDebug' 		 : !!item.debug,
			};

			node.children       = _arr(node.children);
			node.isSingleParent = node.children.length <= 1;

			if ('onUpdate' in item){
				utils.deprecated('utils.el => _nodes() -> args.onUpdate', 'args.onMount');
				node.onMounted = item.onUpdate;
			}

			// overwrite the alias with the items
			if ('alias' in item){
				alias = a.alias = item.alias.toString();
			}
			
			if (utils.is.str(node.class)){
				node.class = node.class.split(' ');
			}

			// decode the tag (with css, attrs, style, html)
			//eg.: div#id.classname.classname2[alt=image&title=title]{border:1px solid black}=the content
			if (utils.is.str(node.tag)){
				var tag = node.tag.replace(/&/g, args.alias).match(RE.CSS_SELECTOR) || [];
				var i=0, l=tag.length, prop, prefix, value;
				for (;i<l;++i){
					prop 	= tag[i];
					prefix 	= prop[0];
					value 	= prop.substr(1);

					// styles: {color:red, fontSize:14}
					if (prefix === '{'){
						value = value.substring(0, value.length-1);
						utils.string.decodeStyle(value, {'callback':function (i, v){
							node.style[i] = v;
						}});
					// attrs: [id=item, alt=image]
					}else if (prefix === '['){
						value = value.substring(0, value.length-1);
						utils.string.decodeQuery(value, {'callback':function (i, v){
							node.attrs[i] = v;
						}});
					// id: #itemId
					}else if (prefix === '#'){
						node.attrs.id = value;
					// classname: .class
					}else if (prefix === '.'){
						node.class.push(value);
					// html: =This is the html
					}else if (prefix === '='){
						node.children = value;
					// tag: div
					}else{
						node.tag = prop;
					}
				}
			}

			// the callback might create the element (if it wasn't created before)
			var response = utils.apply(callback1, [node, el, a]);
			if (response !== undefined){
				el = response;
			}

			node.el       = el;
			node.children = _children(node, node.children, el, alias, depth+1);

			utils.apply(callback2, [node, el, a]);

			return node;
		}

		nodes = _children({}, nodes, args.element, args.alias, 0);

		return nodes;
	};

	this.html = function (el, html, args){
		if (html === true){
			return el.outerHTML;
		}
		if (html === undefined || html === null || html === false){
			// @todo maybe cache the innerHTML when adding it...
			return el.innerHTML;
		}

		args          = args || {};
		args.cache    = 'cache' in args ? args.cache : false;
		args.alias    = args.alias || '';
		args.context  = args.context || null;
		args.replace  = args.replace || {};		// used to "replace" or function
		args.preload  = args.preload || false;	// preload content with images in another hidden div

		//args.append = 'append' in args ? args.append : false; // @todo 
		
		if (html in args.replace){
			html = args.replace[html];
			html = utils.is.str(html) ? html : [html];
		}

		if ('clean' in args){
			utils.deprecated('el.html()->args.clean', 'args.append');
			args.append = !args.clean;
		}

		// @todo cache only text, not obj maybe, or change to JSON the obj, to test
		if (args.cache){
			var old = utils.el.cache(element, '__HTML__');

			// it's the same, so skip
			if (html === old){
				return false;
			}
		}

		// preload the images, then add it to the element
		if (args.preload){
			var frag = document.createElement('div');
			_update(frag, html);

			utils.els.onMediaLoad(frag, function (medias){
				utils.dom.add(frag.childNodes, 'html', el);
				utils.apply(args.preload, [medias], args.context);
			});

			return;
		}

        function _html (el, value, isText, refresh){
            var old = utils.el.cache(el, '__HTML__');
            value = utils.is(value) ? value.toString() : '';

			if (!args.cache){
				refresh = true;
			}

			if (old !== value || refresh){	
				// replace the "&" in class with the alias
				var html = ~value.indexOf('&') ? value.replace(/class="[^"]+?"/g, function (m){
					return m.replace(/&/g, args.alias);
				}) : value;

                if (isText)	el.textContent = html;
                else 		el.innerHTML = html;
            }

            utils.el.cache(el, '__HTML__', value);
		}
		
		function _find (key, nodes){
			if (!key) return;

			var i=0, l=nodes.length;
			var node = null;
						
			for (;i<l;++i){
				if (nodes[i].key == key){
					node = nodes[i];
					break;
				}
			}

			return node;
		}		
		
		function _clean (el, count){
			var oldCount = el.childNodes.length;
			if (oldCount > count){
				var child;
				while ((child = el.childNodes[count])){
					utils.els.remove(child);
				}
			}
		}
		
		function _update (el, html){
			if (utils.is.object(html, true) || html instanceof Array){
				// add a way to know if anything has changed
				//var addedNodes   = [];
				//var deletedNodes = [];
				//var movedNodes   = [];
				var isFragment = el.childNodes.length === 0;
				var fragment   = isFragment ? document.createDocumentFragment() : el;
				
				var nodes = _nodes(html, {
					'alias'    : args.alias,
					'replace'  : args.replace,
					'element'  : fragment,
					'callback' : [function (node, el, a){
						var oEl       = _find(node.key, a.siblings);
						var isCreated = false;
						
						// @todo maybe switch 2 items... if found at future position, move the swap both items
						
						if (oEl && oEl !== el){
							if (el && el.parentNode){
								var p = el.parentNode;
								p.insertBefore(oEl, p.childNodes[node.index]);
							}

							el = oEl;
						}else if (el && el.key && el.key !== node.key){
							el.parentNode.removeChild(el);
							el = null;
						}else if (!node.key){
							oEl = el;
						}

						var type 	= utils.is.node(node) ? 'domNode' : (typeof node === 'string' ? 'textContent' : node.tag);
						var oldType = oEl && oEl.nodeType ? (oEl.nodeType === 1 ? oEl.tagName.toLowerCase() : 'textContent') : null;
						var isWrap  = false;
						
						// little fix for single string element
						if (type === 'textContent' && a.parent.isSingleParent){
							_html(a.parentElement, node, false);
							a.parent.isSingleParentWithText = true; // @todo .... maybe we don't need this var
							return false;
						}

						// @todo check, if the node is text, but has html in it, add a wrapper
						if (type === 'textContent' && (!!~node.trim().indexOf('<') || !!~node.trim().indexOf('&'))){
							type   = 'span';
							isWrap = true;
						}

						// if (node.key == '0-1-1-3-1-2:0:2'){
						// 	console.log(type, node);
						// }

						// create/switch
						if ((oldType && oldType !== type) || !oldType){
							isCreated = true;

							if (type === 'domNode'){
								el = node;
							}else if (type === 'textContent'){	
								el = document.createTextNode('');
							}else if (utils.is.el(type)){
								el   = type;
								type = 'domElement';
							}else{
								// TODO quick fix, try making this better for SVG elements
								if (node.context && node.context.svg){
									el = document.createElementNS('http://www.w3.org/2000/svg', type);
								}else{
									el = document.createElement(type);
								}
							}

							// @todo deal with SVG element
						}
						
						// update the node
						if (type === 'textContent'){
							_html(el, node, true);
						}else if (type !== 'domNode'){
							var cache = {
								'node': node,
								'meta': node.meta || node.data || {}
							};

							if (!node.isSingleParent){
								cache.html = null;
							}

							utils.el.update(el, {
								'attrs'    : node.attrs,
								'props'    : node.props,
								'style'    : node.style,
								'class'    : node.class,
								'events'   : node.events,
								'cache'	   : cache,
								'context'  : args.context || node.context,
								'alias'    : a.alias,
							});

							if (isWrap){
								el.setAttribute('raw-html', '');
								_html(el, node);
							}
						}

						// add to parent
						if (a.parentElement && (oEl !== el || !el.parentNode)){
							// switch element
							if (oEl && oEl.parentNode){
								oEl.parentNode.insertBefore(el, oEl.nextSibling);
								oEl.parentNode.removeChild(oEl);
							// append at end	
							}else{
								try{
									var p = a.parentElement;
									if (p.childNodes[a.index]){
										p.insertBefore(el, p.childNodes[a.index]);
									}else{
										p.appendChild(el);
									}
								}catch (e){
									console.log('[NodeAppend Error]', e); // @info seems like IE11 doens't like to append EmptyTextNode
								}
							}
						}else{
							addType = 'none';
						}

						if (node.isDebug){
							//console.log(node);
							// debug stuff...
						}

						el.key = node.key;
						if (el.setAttribute && utils.is(node.key)){
							el.setAttribute('key', node.key);
						}
						
						utils.apply(node.onMount, [el, node, isCreated], node.context);

						return el;				
					}, function (node, el, a){
						if (node.isSingleParentWithText) return;

						if (!utils.is.el(node.tag)){
							_clean(el, node.children.length);
						}
						
						utils.apply(node.onMounted, [el, node], node.context);
					}]
				});
				
				if (isFragment){
					el.appendChild(fragment);
				}

				_clean(el, nodes.length);

				utils.el.cache(el, '__HTML__', html);
			}else{
				_html(el, html);
			}

			if (args.cache){
				utils.el.cache(el, '__HTML__', html);
			}

			utils.el.triggerEvent(el, 'change-html');
		}

		_update(el, html);

		return true;
	};

	this.toHtml = function (nodes, args){
		if (typeof nodes === 'string') return nodes;

		args     = args || {};
		args.key = 'key' in args ? args.key : true;

		var html = [];
		nodes = _nodes(nodes, [function (node, el, a){
			var prefix = utils.string.repeat('\t', a.depth);

			if (typeof node === 'string'){					
				html.push(prefix + node);
				return;
			}else if (utils.is.node(node)){
				html.push(prefix + node.outerHTML);
				return;
			}		

			var style  = [];
			var attrs  = [];
			var i, name, value;

			for (i in node.style){
				name  = utils.el.toStyleName(i);
				value = utils.el.toStyleValue(i, node.style[i]);
				
				if (value !== ''){
					style.push(name + ':' + value);
				}
			}
			if (style.length){
				node.attrs['style'] = style.join('; ');
			}

			if (node.class.length){
				node.attrs['class'] = node.class.join(' ');
			}
			
			for (i in node.attrs){
				value = node.attrs[i];
				attrs.push(i + '="' + value + '"');
			}
			
			if (args.key && ('key' in node)){
				attrs.push('@key="'+node.key+'"');
			}

			attrs = attrs.join(' ');

			html.push(prefix + '<' + node.tag + (attrs ? ' ' + attrs : '') + '>\n');
		}, function (node, el, a){
			var prefix = utils.string.repeat('\t', a.depth);
			html.push(prefix + '</' + node.tag + '>\n');
		}]);

		return html.join('');
	};

	// value -------------------------------------------------------------------
	this.value = function (el, value, data){
		var type     = el.hasAttribute('contenteditable') ? 'html' : el.tagName.toLowerCase();
		var callback = utils.cache(el, 'value');

		if (type === 'input'){
			type = el.type || 'text';
		}

		if (value === undefined){
			value = utils.apply(callback, null, el);
			// value = value === undefined && el.get ? utils.apply(el.get, null, el) : value;

			if (!utils.is.valid(value)){
				if (type === 'file'){
					value = el.multiple ? utils.toArray(el.files) : (el.files[0] || '');
				}else if (type === 'radio' || type === 'checkbox'){
					if (el.checked){
						value = el.hasAttribute('value') ? el.value : true;
					}else{
						value = false;
					}
				}else if (type === 'html'){
					value = el.innerHTML;
				}else if (type === 'select'){
					var values  = [];
					var options = el.options;
					var i=0, l=options.length, option;

					for (; i<l; ++i){
						option = options[i];

						if (option.selected){
							values.push(option.value);
						}
					}

					if (el.multiple){
						value = values;
					}else{
						value = values[0] === undefined ? -1 : values[0];
					}
				}else{
					value = el.value;
				}
			}

			if (utils.is.str(value)){
				value = value.trim();
			}

			return utils.toValue(value);
		}else{
			if (type === 'file'){
				el.value = ''; // all that can be done for files is to be reset
			}else if (type === 'radio' || type === 'checkbox'){
				if (value instanceof Array){
					// the indexOf needs to be compared with strings
					el.checked = !!~value.join().split(',').indexOf(el.value);
				}else if (el.hasAttribute('value')){
					el.checked = el.value == value;
				}else{
					el.checked = !!value;
				}
			}else if (type === 'select'){
				var options = el.options || [];
				var values 	= value instanceof Array ? value : [value];
                var isSet 	= false;
                var i=0, l=options.length, option;

				for (; i<l; ++i){
					option = options[i];

					if (~values.indexOf(option.value)){
						option.selected = true;
						isSet = true;
					}else{
						option.selected = false;
					}
				}

				if (!isSet){
					el.selectedIndex = -1;
				}
			}else{
				if (utils.is.str(value) && data){
					value = utils.string.replace(value, data);
				}else if (utils.is.obj(value)){
					value = JSON.stringify(value);
				}
				
				if (type === 'html'){
					el.innerHTML = value;
				}else{
					el.value = value;
				}
			}

			// Set the value of the element "helper", but skip the loop that it can force
			if (!el.__setting_value__){
				el.__setting_value__ = true;
				utils.apply(callback, [value], el);
				utils.apply(el.set, [value], el);
				utils.el.triggerEvent(el, 'change-value');
				el.__setting_value__ = false;
			}
		}
	};

	this.values = function (el, key, value, setter){
		/*
		values($0);									// get all
		values($0, function (){});					// get all + getter
		values($0, 'name', function (){});			// get one + getter
		values($0, 'name', 'value');				// set 1
		values($0, {});								// set those
		values($0, {}, function (){});				// set those + setter
		values($0, 'name', 'value', function (){}); // set 1 + setter;
		*/

		var getter = null;
		if (utils.is.fn(key)){
			getter = key;
			setter = null;
			key    = undefined;
		}else if (utils.is.str(key) && utils.is.fn(value)){
			getter = value;
			value  = undefined;
		}else if (utils.is.obj(key) && utils.is.fn(value)){
			setter = value;
			value  = undefined;
		}

		var inputs 	 = utils.dom.getAll('input,textarea,select,[contenteditable]', {'context':el});
		var values   = utils.toSet(key, value);
		var isSet    = !!values;
		var toggles  = {};

		if (!getter) getter = utils.fn.empty;
		if (!setter) setter = utils.fn.empty;
		if (!isSet)  values = [];

		var i=0, l=inputs.length;
		//var input, name, isSkipped, value, type;
		for (; i<l; ++i){
			var input     = inputs[i];
			var name      = input.getAttribute('name');
			var isSkipped = input.hasAttribute('skip');

			if (!name || !name.trim() || isSkipped) continue;

			var type = input.hasAttribute('contenteditable') ? 'html' : input.tagName.toLowerCase();
			if (type === 'input'){
				type = input.type || 'text';
			}

			var isArray  = !!name.match(/\[\]$/);
			var isToggle = type === 'checkbox' || type === 'radio';
			var basename = name.replace(/\[\]$/, '');

			// setter ----------------------------------------------------------
			if (isSet){
				name  = name.replace(/\[\]$/, '');
				value = setter(values[name], name, input, values);
				
				// alernate name (if input name="item[val]")
				if (value === undefined){
					value = utils.object.get(values, name);

					// try to resole the path

					/*
					alt = utils.string.match(name, /^([^\[]+)\[(.+)\]$/);		

					if (alt.length === 2 && values[alt[0]]){
						name = alt[0];
						value= setter(values[name][alt[1]], name, input, values);
					}
					*/
				}

				
				if (value === undefined) continue;

				if (value === null){
					value = '';
				}
				
				if (isArray && !utils.is.arr(value)){
					value = [value];
				}

				utils.el.value(input, value);
			// getter ----------------------------------------------------------
			}else{
				// skip hidden that are checked
				if (type === 'hidden' && input.checked){
					continue;
				}

				value = utils.el.value(input);
				value = utils.toValue(value, {'json':true});

				if (isToggle && !toggles[name]){
					// default values
					if (isArray){
						values.push([basename, []]);
					}else{
						values.push([name, false]);
					}
					toggles[name] = true;
				}
				
				var isValid = utils.is(value);
				if (utils.is.arr(value) && utils.is.empty(value)){
					isValid = false;
				}
				if (type === 'file' && !isValid){
					continue;
				}

				if (
					(isArray && isValid) ||
					(!isArray && type === 'radio' && isValid) ||
					(!isArray && type !== 'radio') ||
					(type === 'file' && isValid)
				){
					value = getter(value, name, input);
					values.push([name, value]);
				}
			}
		};

		// format the values gotten from the fields into a object
		if (!isSet){
			values = utils.object.namespace(values, {
				'separator': '|',	// use a rare char that wouldn't be used in text (to separate the items in the path)
				'arraySets': true,
			});
		}
		
		return key ? values[key] : values;
	};

	// style -------------------------------------------------------------------
	this.style = function (el, key, value){
		var values = utils.toSet(key, value);

        if (values){
			var cache 		= utils.el.cache(el, '__STYLE__') || {};
			var hasChanged 	= false;
			var transform 	= null;
			var skipCache   = value === false;
			var i, o, v, t, isVar;
			
            for (i in values){
				isVar = i.indexOf('--') === 0;

				v = values[i] === null ? '' : values[i];
				i = isVar ? i : utils.el.toStyleName(i); // get the proper prop name
				o = skipCache ? null : cache[i];
				t = typeof(v);

				if (v === o){
					continue;
				}

				// @fix IE10 has a bug with NULL, so force ''
				if (v === null){
					value = '';
				}

				// is a transforms value
				if (~DOM.TRANSFORM_VALUES.indexOf(i)){
					transform 	 = transform || {};
					transform[i] = v;
					delete(cache.transform); // @info the transform cache needs to be cleared
					continue;
				}

				// clear the transforms
				if (i === 'transform'){
					transform = null;
					utils.el.cache(el, '__TRANSFORM__', {});
				}
				
				cache[i] = v;

                if (isVar){
				    el.style.setProperty(i, v);
                }else{
					v  = utils.el.toStyleValue(i, v);
                    el.style[i] = v;
				}
				
				hasChanged = true;
			}
			
			utils.el.cache(el, '__STYLE__', cache);

			if (transform){
				utils.el.transform(el, transform);
			}

			return hasChanged;
        }else{
            var style     = el.style ? window.getComputedStyle(el) : {};
            var isVar     = utils.is.fn(style.getPropertyValue) && utils.is.str(key) && key.indexOf('--') === 0;
            var transform = utils.el.transform(el) || {};

            if (isVar){
				return style.getPropertyValue(key).trim();
			}else if (key in style){
				return style[key];
			}else if (key in transform){
				return transform[key];
			}else if (utils.is.defined(key)){
				return null;
			}else{
                var i, values = {};
				for (i in style){
					if (!isNaN(i)) continue;
					values[i] = style[i];
				}
				for (i in transform){
					values[i] = transform[i];
				}

				// add the default transforms
				//values

				return values;
			}
		}
	};

	this.var = function (el, value, args){
		if (arguments.length === 1){
			value = el;
			el    = null;
		}

		args           = args || {};
		args.style     = args.style || null;		// computedStyle
		args.format    = args.format || null;
		args.falllback = args.falllback || null;

		el    = el || document.body;
		value = (value || '').toString();

		if (!!~value.indexOf('--')){
			var style 	 = args.style || (window.getComputedStyle ? window.getComputedStyle(el) : {});
			var pair 	 = (utils.string.match(value, RE.CSS_VARS, true) || '').trim().split(',');
			var name     = pair[0].trim();
			var fallback = pair[1] !== undefined ? pair[1].toString().trim() : args.falllback;
			
			value = style.getPropertyValue(name).trim();
			value = value === '' && fallback !== '' ? fallback : value;
			
			value = value ? utils.format(value, args.format) : value;
		}

		value = utils.toValue(value);

		return value;
	};

	this.transform = function (el, values, args){
		// @todo add way to have multiple translate, rotate, ...

		args          = args || {};
		args.decimals = 'decimals' in args ? args.decimals : true;

		var transforms 	= utils.el.cache(el, DOM.CACHE.TRANSFORMS) || {};
		var output 		= [];

		if (values === undefined){
			return utils.extend({}, {
				'translateX': 0,
				'translateY': 0,
				'translateZ': 0,
				'scaleX'    : 1,
				'scaleY'    : 1,
				'scaleZ'    : 1,
				'rotateX'   : 0,
				'rotateY'   : 0,
				'rotateZ'   : 0,
				'skewX'     : 0,
				'skewY'     : 0
			}, transforms);
		}else if (!values){
			values 		= {};
			transforms 	= {};
		}

		// remove the empty values
		for (var i in values){
			var value = values[i];
			if (value === ''){
				delete(transforms[i]);
			}else{
				transforms[i] = value;
			}
		}

		// shortcuts -----------------------------------------------------------
		if (values.translate === ''){
			delete(transforms.translateY);
			delete(transforms.translateX);
		}else if (values.translate !== undefined){
			transforms.translateX = values.translate;
			delete(transforms.translateY);
		}

		if (values.scale === ''){
			delete(transforms.scaleX);
			delete(transforms.scaleY);
		}else if (values.scale !== undefined){
			transforms.scaleX = values.scale;
			transforms.scaleY = values.scale;
		}

		if (values.rotate !== undefined){
			transforms.rotateZ = values.rotate;
		}

		// output --------------------------------------------------------------
		function _nbr (nbr, unit){
			unit = unit || 'px';
			
			if (typeof nbr === 'number' && nbr){
				// nbr = args.decimals ? nbr : parseInt(nbr, 10);
				nbr = nbr + unit;
			}

			return nbr;
		}

		if (transforms.perspective !== undefined){
			var p = _nbr(transforms.perspective || 0);
			output.push('perspective('+p+')');
		}

		if (transforms.perspectiveX !== undefined){
			var x = _nbr(transforms.perspectiveX || 0);
			var y = _nbr(transforms.perspectiveY || 0);
			el.style.perspectiveOrigin = x + ' ' + y;
		}

		if (transforms.translateX !== undefined || transforms.translateY !== undefined || transforms.translateZ !== undefined){
			var x = _nbr(transforms.translateX || 0);
			var y = _nbr(transforms.translateY || 0);
			var z = _nbr(transforms.translateZ || 0);

			if (z){
				output.push('translate3d('+x+','+y+','+z+')');
			}else{
				output.push('translate('+x+','+y+')');
			}
		}

		if (transforms.scaleX !== undefined || transforms.scaleY !== undefined || transforms.scaleZ !== undefined){
			var x = transforms.scaleX !== undefined ? transforms.scaleX : 1;
			var y = transforms.scaleY !== undefined ? transforms.scaleY : 1;
			var z = transforms.scaleZ !== undefined ? transforms.scaleZ : 1;
			output.push('scale3d('+x+','+y+','+z+')');
		}

		if (transforms.rotateX !== undefined){
			var r = _nbr(transforms.rotateX || 0, 'deg');
			output.push('rotateX('+r+')');
		}

		if (transforms.rotateY !== undefined){
			var r = _nbr(transforms.rotateY || 0, 'deg');
			output.push('rotateY('+r+')');
		}

		if (transforms.rotateZ !== undefined){
			var r = _nbr(transforms.rotateZ || 0, 'deg');
			output.push('rotateZ('+r+')');
		}

		if (transforms.skewX !== undefined || transforms.skewY !== undefined){
			var x = _nbr(transforms.skewX || 0, 'deg');
			var y = _nbr(transforms.skewY || 0, 'deg');
			output.push('skew('+x+','+y+')');
		}

		if (transforms.centerX !== undefined || transforms.centerY !== undefined){
			var x = _nbr(transforms.centerX || 0);
			var y = _nbr(transforms.centerY || 0);
			el.style.transformOrigin = x + ' ' + y;
		}

		el.style.transform = output.join(' ');

		// cache old transforms
		utils.el.cache(el, DOM.CACHE.TRANSFORMS, transforms);
	};

	this.toStyleName = function (name){
		if (name.indexOf('--') === 0){
			return name;
		}

		if (name in DOM.PREFIXED_STYLE_NAMES){
			return DOM.PREFIXED_STYLE_NAMES[name];
		}

		var styles 		= DOM.COMPUTED_STYLE || (DOM.COMPUTED_STYLE = window.getComputedStyle(document.documentElement, ''));
		var camelCase	= name.replace(/\-([a-z])/g, function (m){ return m[1].toUpperCase(); });
		var upperCase	= camelCase[0].toUpperCase() + camelCase.slice(1);
		var prefixed	= name;
		
		if (camelCase in styles)				prefixed = utils.string.toDashCase(name);
		else if ('webkit'+upperCase in styles)	prefixed = '-webkit-' + name;
		else if ('moz'+upperCase in styles)		prefixed = '-moz-' + name;
		else if ('ms'+upperCase in styles)		prefixed = '-ms-' + name;
		else if ('o'+upperCase in styles)		prefixed = '-o-' + name;

		DOM.PREFIXED_STYLE_NAMES[name] = prefixed;

		return prefixed;
	};

	this.toStyleValue = function (key, value){
		var isVar= !!key.match(/^\-\-/);
		if (isVar) return value;
		
		var name = utils.el.toStyleName(key);

		if (utils.is.either(value, 'number,string') && ~DOM.PX_VALUES.indexOf(name) && !value.toString().match(/(calc|var)\(/) ){
			// @todo make sure to skip when there's a calc() in the value (to keep value without units)
			value = value.toString().replace(RE.CSS_NUMBER, function (m, $1){
				var v = utils.number.decimals($1, 8);
				return ' ' + v + 'px';
			});
		}
		// format the URL to be well formated (with the "url(...)" wrapper)
		if (typeof value === 'string' && ~DOM.URL_VALUES.indexOf(key)){
			value = value.replace(RE.CSS_URL, 'url("$1")');
		}

		return value;
	};

	this.reflow = function (el){
		var reflow = el.offsetHeight;
	};

	// class -------------------------------------------------------------------
	var _classname = function (el, name, alias){
		if (utils.is.fn(name)){
			name = name(el, el.getAttribute('class'));
		}
        name = (name || '').toString().trim();
        return alias ? name.replace(/\&/g, alias) : name;
    };
    
    this.classnames = function (el, classnames, alias){
		function _get (){
			var cls = [];

			if (el.getAttribute){
				cls = el.getAttribute('class') || '';
				cls = utils.toArray(cls, {'separator':' ', 'unique':true});
			}

            return cls;
		}

        // getter
        if (classnames === undefined){
            return _get();
        }

		// setter
		var classnames = utils.is.str(classnames) ? utils.toArray(classnames, ' ') : classnames;
        var unique     = [];
        var i, c, idx, add;

		if (utils.is.obj(classnames, true)){
			var old = _get();
			for (i in old){
				c = old[i];
				if (c in classnames) continue;
				classnames[c] = true;
			}
		}

		for (i in classnames){
			add = true;
			c   = classnames[i];

			if (utils.is.bool(c)){
				add = c;
				c   = i;
			}

            c   = _classname(el, c, alias);
            idx = unique.indexOf(c);

			if (add && !~idx){
                unique.push(c);
            }else if (!add && ~idx){
				unique.splice(idx, 1);
			}
        }

		classnames = unique.join(' ');
		
		// @todo speed up stuff with caching...

		if (el.setAttribute){
			if (classnames){
				el.setAttribute('class', classnames);
			}else{
				el.removeAttribute('class');
			}
		}

        return el;
    };

	this.hasClass = function (el, classname){
		classnames = utils.el.classnames(el);

		if (~classnames.indexOf(classname)){
			return true;
		}

		return false;
	};

    this.addClass = function (el, classnames, alias, duration){
        var current = utils.el.classnames(el);
		// var old 	= current.join(' ');
		var i, c;

        classnames = utils.toArray(classnames, ' ');
		
		for (i in classnames){
            c = _classname(el, classnames[i], alias);
            current.push(c);
        }

		// duration
		duration = utils.string.toDuration(duration);
		if (duration){
			
			setTimeout(function (){
				utils.el.removeClass(el, classnames);
			}, duration);
		}
        
        return utils.el.classnames(el, current);
    };

    this.removeClass = function (el, classnames, alias){
        var current = utils.el.classnames(el);
        var i, c;
        
		classnames = utils.toArray(classnames, ' ');
		
		for (i in classnames){
			c = classnames[i];
			c = c instanceof RegExp ? c : _classname(el, c, alias);
			utils.array.remove(current, c);
		}
		
		//console.log(current, classnames);	
		
		return utils.el.classnames(el, current);
    };

    this.toggleClass = function (el, classnames, alias){
        var current = utils.el.classnames(el);
        var i, c, idx;
        
        classnames = utils.toArray(classnames, ' ');

        for (i in classnames){
            c   = _classname(el, classnames[i], alias);
            idx = current.indexOf(c);

            if (!~idx){
                current.push(c);
            }else{
                current.splice(idx, 1);
            }
        }

        return utils.el.classnames(el, current);
    };

	this.transitionClass = function (el, args, callback){
		if (utils.is.fn(args))	 		args = {'callback':args};
		else if (utils.is.str(args))	args = {'classname':args};
		else 							args = args || {};

		args.classname 			= args.class || args.classname || 'transition';
		args.startClassname 	= 'startClassname' in args ? args.startClassname : args.classname + '--start';
		args.activeClassname 	= 'activeClassname' in args ? args.activeClassname : args.classname;
		args.endClassname 		= 'endClassname' in args ? args.endClassname : args.classname + '--end';
		args.duration 			= 'duration' in args ? args.duration : 0;
		args.easing 			= 'easing' in args ? args.easing : null;
		args.context 			= 'context' in args ? args.context : null;
		args.callback 			= 'callback' in args ? args.callback : (callback || null);
		
		var _a = utils.dom.addClass;
		var _r = utils.dom.removeClass;

		// Cancel the previous transition if not finished
		var key        = 'transition';
		var transition = utils.cache(el, key);
		transition && transition(false);
		
		_a(el, args.startClassname);

		var reflow = el.offsetHeight; // force reflow...
		
		_a(el, args.activeClassname);

		// find the type of animation
		var styles 		 		= window.getComputedStyle(el);
		var transitionDuration 	= utils.string.toDuration(styles.transitionDuration);
		var animationName 		= styles.animationName;
		var animationDuration   = animationName !== 'none' ? utils.string.toDuration(styles.animationDuration) : 0;
		var eventName 			= null;
		var time 				= transitionDuration || animationDuration || args.duration || 0;
		var timeout 			= null;

		// cache the classnames
		utils.cache(el, key, _onComplete);

		function _onComplete (e){
			// some other elements inside has triggerd a similar event
			if (e && e.target !== el){
				return;
			}

			utils.cache(el, key, null);

			clearTimeout(timeout);

			_r(el, [args.startClassname, args.activeClassname, args.endClassname]);
			
			if (eventName){
				el.removeEventListener(eventName, _onComplete);
			}

			if (e !== false){
				utils.apply(args.callback, [el], args.context);
			}
		};

		if (args.duration){
			utils.fn.animate({'duration':args.duration, 'easing':args.easing}, function (e){
				if (e.isStart){
					_r(el, args.startClassname);
					_a(el, args.endClassname);
				}

				el.style.setProperty('--ratio', e.ratio);

				if (e.isEnd){
					_onComplete();
					el.style.setProperty('--ratio', '');
				}
			});

			return;
		}

		// no transition/animation found
		if (!transitionDuration && animationName === 'none'){
			_onComplete();
			return time;
		// css transition
		}else if (transitionDuration){
			eventName = 'transitionend';
		// css animation
		}else if (animationName){
			eventName = 'animationend';
		}

		// TODO add a "now" attribute, to delay the action

		utils.fn.requestFrame(function (){			
			_r(el, args.startClassname);
			_a(el, args.endClassname);
			el.addEventListener(eventName, _onComplete);
		}, true);

		// add a fail-safe, to remove the event (if for some reason it didn't trigger)
		if (time){
			timeout = setTimeout(_onComplete, time + 500);
		}

		return time;
	};
	
	// events ------------------------------------------------------------------
	var _nearestDelegate = function (el, callbacks){
		var found = null;

		for (var selector in callbacks){
			var callback = callbacks[selector];
			var target 	 = utils.dom.closest(el, selector);
			var item  	 = target ? {
				'target' 	: target,
				'selector'	: selector,
				'depth'	 	: utils.dom.parents(target).length,
				'callback' 	: callback,
			} : null;

			if (item && (!found || item.depth > found.depth)){
				found = item;
			}
		}
	
		return found;
	};

	var _toDeprecatedEvent = this._toDeprecatedEvent = function (names){
		if (utils.is.str(names) && ~names.replace(/^[^\:]+\:/, '').replace(/,\s+/g, ',').indexOf(' ')){
			console.error('Need to change the event name separator from space to coma in "'+names+'"');
		}
	}
	
	var _events = function (el, names, args, isRemove){
		// multiple set of events
		if (utils.is.obj(names)){
			var name, a;
			for (name in names){
				a = names[name];

				if (utils.is.obj(a)){
					a = utils.extend({}, args, a);
				}else if (utils.is.fn(a)){
					a = utils.extend({}, args, {'callback':a});
				}

				_events(el, name, a, isRemove);
			}
			return;
		}

		if (utils.is.fn(args) || utils.is.array(args)){
			args = {'callback':args};
		}

		args 			= args || {};
		args.callback 	= args.callback || null;	// can be a function or an array of functions
		args.delegate 	= args.delegate || null;	// sub-element delegation
		args.context 	= args.context || null;		
		args.namespace 	= args.namespace || '';		// @todo maybe a good way to differentiate types of events
		args.alias 		= args.alias || '';			// when event names uses the "&" it will be replaced by ".{name}...."
		args.capture 	= 'capture' in args ? args.capture : false;
		args.passive 	= 'passive' in args ? args.passive : null;
		args.once 		= 'once' in args ? args.once : false;
		args.debounce 	= args.debounce || false;
		args.throttle 	= args.throttle || false;
		args.data 		= args.data || {};

		if (utils.is.obj(args.delegate)){
			args.delegate = utils.dom.get(args.delegate);
		}

		_toDeprecatedEvent(names);

		var scope         = utils.string.random();
		var scopeSelector = '[scope="'+scope+'"]';

		utils.each(names, {'separator':','}, function (eName){
			var eDelegate = args.delegate;
			var eNamespace= args.namespace;
			// refresh the eventname if the delegate is in it's name (eg.: .my-class:click)
			if (!!~eName.indexOf(':')){
				var pair  = utils.string.match(eName, RE.DELEGATE_EVENT);
				eName     = pair[1];
				eDelegate = pair[0];
			}
			if (utils.is.string(eDelegate) && args.alias){
				eDelegate = eDelegate.replace(/&/g, '.' + args.alias);
			}

			var prevent    = !!~eName.indexOf('!prevent');
			var stop       = !!~eName.indexOf('!stop');
			var isScopable = utils.is.str(eDelegate) && !!eDelegate.trim().match(/^[+~>]/);
			
			eName = eName.replace('!prevent', '').replace('!stop', '');

			if (eDelegate && isScopable){
				eDelegate = scopeSelector + ' ' + eDelegate;
			}

			// check for namespaced event
			if (!!~eName.indexOf('.')){
				var pair   = utils.string.match(eName, RE.NAMESPACE_EVENT);
				eName      = pair[0];
				eNamespace = pair[1];
			}

			// make sure it's a lowercase event name
			eName = eName.toLowerCase();

			// custom events (more complex events)
			if (eName in DOM.CUSTOM_EVENTS){
				var cEvent = DOM.CUSTOM_EVENTS[eName];

				if (!isRemove && utils.is.fn(cEvent.on)){
					cEvent.on(el, eDelegate, args);
				}else if (isRemove && utils.is.fn(cEvent.off)){
					cEvent.off(el, eDelegate, args);
				}

				return;
			}

			var oName = eName;
			var isAlt = (oName in DOM.ALT_DELEGATE_EVENTS);
			eName 	  = isAlt && eDelegate ? DOM.ALT_DELEGATE_EVENTS[oName] : oName;

			var cacheKey = [args.context, oName, eDelegate, eNamespace, args.callback, args.capture];
			var bind 	 = utils.cache(DOM.EVENTS, cacheKey);

			if (!bind){
				bind = function (e){
					if (prevent){
						e.preventDefault();
					}
					if (stop){
						e.stopPropagation();
					}

					var target   = e.target;
					var related  = e.relatedTarget;
					var callback = args.callback;
					
					// find the right delegate target

					if (eDelegate){
						var isMatch = true;

						if (isScopable && el.setAttribute) el.setAttribute('scope', scope);
						target = utils.dom.closest(target, eDelegate);

						if (!target){
							isMatch = false;
						}else if (isAlt && (related === target || target.contains(related))){
							isMatch = false;
						}else if (!utils.dom.is(target, eDelegate)){
							isMatch = false;
						}

						if (isScopable && el.setAttribute) el.removeAttribute('scope');

						if (!isMatch){
							return;
						}
					}else{
						// the related has been deleted
						if (args.debug){
							//console.log(e.type, el, related);
						}

						if (utils.is.el(this)){
							target = this;
						}

						target = target || this;
					}

					//if (e.type === 'keyup') console.log(e.target, target);
					var x = e.clientX;
					var y = e.clientY;
					var w = 0;
					var h = 0;
					var s = 1; // scale

					// TODO maybe have this calculation on request
					if (target && target.getBoundingClientRect){
						var b = target.getBoundingClientRect();
						w = b.width;
						h = b.height;
						s = w / target.offsetWidth;
						x = e.pageX - b.left;
						y = e.pageY - b.top;

						if (x < 0) 		x = 0;
						else if (x > w) x = w;

						if (y < 0) 		y = 0;
						else if (y > h) y = h;
					}

					var event = {
						'originalEvent'           : e,
						'originalTarget'          : e.target,
						'originalType'            : e.type,
						'type'                    : oName,
						'target'                  : target,
						'ctx'					  : e.ctx || target,
						'timestamp'               : new Date(),
						'details'                 : e.details || null,                          // coming from the event (if CustomEvent)
						'data'                    : args.data,
						'cache'					  : utils.cache(target),
						'meta'                    : utils.el.cache(target, 'meta'),	// used in events.... not sure if it's a good idea
						'size'	   				  : {'width':w, 'height':h, 'scale':s},
						'point'    				  : {'x':x, 'y':y, 'scaleX':x/s, 'scaleY':y/s, 'ratioX':x/w, 'ratioY':y/h},
						'pageX'                   : e.pageX,
						'pageY'                   : e.pageY,
						'clientX'                 : e.clientX,
						'clientY'                 : e.clientY,
						'offsetX'                 : e.offsetX,
						'offsetY'                 : e.offsetY,
						'button'				  : DOM.MOUSE_BUTTONS[e.buttons] || null,
						'touches'                 : e.touches,
						'keyAlt'                  : e.altKey,
						'keyCtrl'                 : e.ctrlKey,
						'keyShift'                : e.shiftKey,
						'keyCommand'              : e.metaKey,
						'keyWindow'               : e.metaKey,
						'keyMeta'                 : e.metaKey,
						'key'                     : e.key === undefined ? null : e.key,
						'keyCode'                 : e.keyCode === undefined ? null : e.keyCode,
						'which'                   : e.which,
						// functions -------------------------------------------
						'preventDefault'          : function (){ e.preventDefault(); this.isDefaultPrevented = true; },
						'stopPropagation'         : function (){ e.stopPropagation(); this.isPropagationStopped = true; },
						'stopImmediatePropagation': function (){ e.stopImmediatePropagation(); this.isPropagationStopped = true; },
						'stop'                    : function (){ this.preventDefault(); this.stopPropagation(); this.stopImmediatePropagation(); },
					};

					// list of delegates, find the nearest
					if (utils.is.object(callback)){
						eDelegate = _nearestDelegate(e.target, callback);

						if (eDelegate){
							target   = event.target = eDelegate.target;
							callback = eDelegate.callback;
						}else{
							callback = null;
						}
					}
					
					if (utils.is.fn(callback)){
						callback.call(args.context || target, event);
					}
				};

				if (args.debounce){
					bind = utils.fn.debounce({'wait':args.debounce}, bind);
				}else if (args.throttle){
					bind = utils.fn.throttle({'wait':args.throttle}, bind);
				}
			}

			bind.eventname = eName;
			bind.namespace = eNamespace;
			bind.capture   = args.capture;

			// cache the events
			var elEvents  = utils.cache(el, '__EVENTS__') || [];
			var bindIndex = elEvents.indexOf(bind);
			var bindExists= !!~bindExists;

			if (bindExists && isRemove){
				el.removeEventListener(bind.eventname, bind, {
					'capture' : args.capture,
					'passive' : args.passive,
					'once'    : args.once,
				});
				
				utils.cache(DOM.EVENTS, cacheKey, null);
				elEvents.splice(bindIndex, 1);				
			}else if (bindExists){
				el.addEventListener(bind.eventname, bind, {
					'capture' : args.capture,
					'passive' : args.passive,
					'once'    : args.once,
				});

				utils.cache(DOM.EVENTS, cacheKey, bind);
				elEvents.push(bind);
			}

			utils.cache(el, '__EVENTS__', elEvents);
		});
	};

	var _addEvent = function (el, names, args){
		_events(el, names, args);
	}

	var _removeEvent = function (el, names, args){
		// remove all events
		if (names === true){
			// @todo add namespace to remove
			var events 		= utils.cache(el, '__EVENTS__') || [];
			var namespace 	= utils.is.str(args) ? args : '';
			var keep 		= [];
			var i=0, l=events.length, bind;
			
			for (;i<l;++i){
				bind = events[i];

				if (namespace && bind.namespace !== namespace){
					keep.push(bind);
					continue;
				}

				el.removeEventListener(bind.eventname, bind, {'capture' : bind.capture});
			}

			utils.cache(el, '__EVENTS__', keep);
			utils.cache(el, '__EVENTS_BATCH__', {});
		}else{
			_events(el, names, args, true);
		}
	}

	var _triggerEvent = function (el, names, args){
		args            = args || {};
		args.bubbles    = 'bubbles' in args ? args.bubbles : true;
		args.cancelable = args.cancelable || false;
		args.details 	= args.details || args.data || {};

		_toDeprecatedEvent(names);

		utils.each(names, {'separator':',', 'lowercase':true}, function (eventname){
			// get the alternate delegate event
			if (eventname in DOM.ALT_DELEGATE_EVENTS){
				eventname = DOM.ALT_DELEGATE_EVENTS[eventname];
			}

			var eClass = DOM.EVENT_CLASSES[eventname] || 'CustomEvent';
			var event  = null;
			
			if (utils.is.fn(window[eClass])){
				event = new window[eClass](eventname, args);
			}else{
				event = document.createEvent(eClass);

				if (!event.initCustomEvent){
					event = document.createEvent('CustomEvent');
				}

				event.initCustomEvent(eventname, args.bubbles, args.cancelable, args.data);
			}

			// add custom data
			event.details = args.details;

			el.dispatchEvent(event);
		});
	}

	var _addCustom = function (name, on, off){
		if (name in DOM.CUSTOM_EVENTS){
			return utils.error('Custom events "{name}" already exists', {'name':name});
		}
		DOM.CUSTOM_EVENTS[name] = {'on':on, 'off':off};
	}
	
	this.events = function (el, args, events){
		if (events === undefined){
			events = args;
			args   = {};
		}
	
		args 		 = args || {};
		args.context = args.context || null;
	
		var cache 		= utils.cache(el, '__EVENTS_BATCH__') || {};
		var hasChanged 	= false;
		var name, nEvent, oEvent;
	
		for (name in events){
			nEvent 		= events[name];
			oEvent 		= cache[name];
			cache[name] = nEvent;

			// skip if same
			if (
				nEvent === oEvent ||
				(oEvent && nEvent.key === oEvent.key) // alternative version to check if an event is the same, probably wont be used
			) continue;
			
			// remove old event
			if (oEvent){
				_removeEvent(el, name, {'callback':oEvent, 'context':args.context});
			}
			// add new one, if set
			if (nEvent){
				_addEvent(el, name, {'callback':nEvent, 'context':args.context});
			}

			hasChanged = true;
		}

		utils.cache(el, '__EVENTS_BATCH__', cache);

		return hasChanged;
	};

	this.addEvent = this.addEvents = function (el, names, args){
		_addEvent(el, names, args);

		// remove
		return function (){
			_removeEvent(el, names, args);
		}
	};

	this.removeEvent = this.removeEvents = function (el, names, args){
		_removeEvent(el, names, args);
	};

	this.triggerEvent = function (el, names, args){
		_triggerEvent(el, names, args);
	};

	this.addCustomEvent = function (name, on, off){
		_addCustom(name, on, off);
	};

	// custom event ------------------------------------------------------------
	// This is an accessible "click", also works with pressing enter on the keyboard when then selected element has "tabindex=0"
	_addCustom('hit', function (el, delegate, args){
		utils.el.addEvent(el, 'click, keyup', {'delegate':delegate, 'callback':function (e){
			if (e.type === 'keyup'){
				var input 	 = utils.dom.is(e.target, 'button, [href], input, select, textarea');
				var tabindex = e.target.getAttribute('tabindex');
				if (e.key !== 'Enter' || input || tabindex === null || tabindex == -1){
					return;
				}
			}

			e.type = 'hit';
			utils.apply(args.callback, [e], args.context);
		}});
	}, function (el, delegate, args){

	});

	this.onOutside = function (els, args){
		if (utils.is.fn(args)){
			args = {'outside':args};
		}else if (utils.is.arr(args)){
			args = {'inside':args[0], 'outside':args[1]};
		}

		args 			= args || {};
		args.context 	= 'context' in args ? args.context : null;
		args.delayed 	= 'delayed' in args ? args.delayed : false;
		args.now 		= 'now' in args ? args.now : true;
		args.inside 	= 'inside' in args ? args.inside : null;
		args.outside 	= 'outside' in args ? args.outside : null;

		// @todo why is it not in "els" instead??

		els = utils.dom.getAll(els);

		var self 		= {};
		var isDelayed   = false;
		var isListening = false;
		
		function _click (e){
			var isOutside = true;
			var i=0, l=els.length;

			for (; i<l; ++i){
				if (utils.dom.contains(els[i], e.target)){
					isOutside = false;
					break;
				}
			}

			if (isOutside && !isDelayed){
				utils.apply(args.outside, [e], args.context);
			}else if (!isOutside){
				utils.apply(args.inside, [e], args.context);
			}
		}

		self.on = function (){
			if (isListening) return;
			document.addEventListener('click', _click);
			isListening = true;
		}

		self.off = function (){
			document.removeEventListener('click', _click);
			isListening = false;
		}

		self.delay = function (time){
			isDelayed = true;
			setTimeout(function (){ isDelayed = false; }, time || 30);
		}

		if (args.now){
			self.on();
		}

		return self;
	};
	
	_addCustom('click-outside', function (el, delegate, args){
		if (!el.OUTSIDE_CLICK){
			el.OUTSIDE_CLICK = utils.dom.onOutside(el, {
				'outside': args.callback,
				'context': args.context,
				'now'    : false,
			});
		}

		el.OUTSIDE_CLICK.on();
	}, function (el, delegate, args){
		if (el.OUTSIDE_CLICK){
			el.OUTSIDE_CLICK.off();
		}
	});

	this.onMutation = function (el, args){
		var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
		if (!MutationObserver) return;

		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		// @todo add condition to match (eg.: if you only fetch the children of specific parents)

		args         = args || {};
		args.props   = utils.toArray(args.props || 'attributes,subtree,childList'); // @info list of options: https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe
		args.callback= args.callback || null;
		args.context = args.context || null;
		args.now 	 = 'now' in args ? args.now : true;

		var self   = {};
		var config = {};

		for (var i in args.props){
			// @todo add alias
			config[args.props[i]] = true;
		}

		var observer = new MutationObserver(function (mutations){
			utils.apply(args.callback, [{
				'target'	: el,
				'mutations' : mutations,
			}], args.context);
		});

		self.on = function (){
			observer.observe(el, config);
		};

		self.off = function (){
			observer.disconnect();
		};

		if (args.now){
			self.on();
		}

		return self;
	};
	
	_addCustom('mutation', function (el, delegate, args){
		if (!el.MUTATION){
			el.MUTATION = utils.dom.onMutation(el, {
				'callback': args.callback,
				'context' : args.context,
				'now'     : false,
			});
		}
		el.MUTATION.on();
	}, function (el, delegate, args){
		if (el.MUTATION){
			el.MUTATION.off();
		}
	});

	this.format = function (el, args){
		args         = args || {};
		args.type    = args.type || 'number';
		args.default = 'default' in args ? args.default : 0;
		args.now     = 'now' in args ? args.now : true;

		var self     = {};
		var template = null;

		if (args.type === 'percent'){
			template = '{{ value }}%';
		}

		function _render (){
			var pos   = utils.el.selection(el, true);
			var value = el.value;
			var count = value.length;
	
			value = utils.number.format(value || args.default, {
				'decimals': {'empty':true},
				'template': template,
				'zeros'   : true,
			});
			
			// the offset can go off if there's extra values at the end
			var offset = value.length - count;
			el.value = value;
			utils.el.selection(el, pos + offset);
		}

		self.on = function (){
			_render();
			utils.el.addEvent(el, 'input', _render);
		};

		self.off = function (){
			utils.el.removeEvent(el, 'input', _input);
		};

		self.render = _render;

		if (args.now){
			self.on();
		}

		return self;
	};

	_addCustom('hover', function (el, delegate, args){
		function _mouse (e){
			var enter = e.type === 'mouseenter'; 
			e.type    = enter ? 'hover-in' : 'hover-out';
			e.isEnter = enter;
			utils.apply(args.callback, [e], args.context);
		};
		return utils.el.addEvent(el, 'mouseenter, mouseleave', {'delegate':delegate, 'callback':_mouse});	
	});

	/*
	this.onDeferClick = function (el, args){
		var isPreClicked = false;
		var isClicked    = false;
		var isTouch 	 = false;

		utils.el.addEvent(element, 'click', function (e){
			if (!isTouch){
				isClicked = isPreClicked;
			}
			if (!isClicked){
				e.preventDefault();
			}
			if (isPreClicked){
				isClicked = true;
			}

			isTouch = false;
		});
		utils.el.addEvent(element, 'mouseenter', function (e){
			isPreClicked = true;
		});
		utils.el.addEvent(element, 'mouseleave', function (e){
			isPreClicked = false;
			isClicked    = false;
		});
		utils.el.addEvent(element, 'touchend', function (e){
			isTouch = true;
		});
	};
	*/

	// shotcuts ----------------------------------------------------------------
    this.update = function (el, args){
        args          = args || {};
        args.id       = 'id' in args ? args.id : null;
        args.class    = args.class || args.classname || args.classnames || null;
        args.class    = utils.is.str(args.class) ? utils.toArray(args.class) : args.class;
        args.props    = args.props || null;
        args.attrs    = args.attrs || null;
        args.style    = args.style || null;
        args.data     = args.data || null;
        args.value    = 'value' in args ? args.value : null;
        args.cache    = args.cache || null;
        args.events   = args.events || null;
        args.children = args.children || args.html;
        args.parent   = args.parent || null;
        args.alias    = args.alias || '';
        args.context  = args.context || null;
		args.replace  = args.replace || {};

		args.allowedTags = args.allowedTags || true;  // strip tags that
		args.clean       = args.clean || false;  	  // clean up the HTML (convert style to proper tags), remove empties

		if (utils.is(args.id)){
			args.attrs    = args.attrs || {};
			args.attrs.id = args.id;
		}

		if (args.props !== null) 	 utils.el.props(el, args.props);
        if (args.attrs !== null) 	 utils.el.attrs(el, args.attrs);
        if (args.class !== null) 	 utils.el.classnames(el, args.class, args.alias);
        if (args.style !== null) 	 utils.el.style(el, args.style);
        if (args.data !== null)      utils.el.data(el, args.data); 			
		if (args.value !== null)	 utils.el.value(el, args.value);
		if (args.cache !== null) 	 utils.el.cache(el, args.cache); 
		if (args.events !== null)	 utils.el.events(el, {'alias':args.alias, 'context':args.context}, args.events);
        if (args.children !== null)  utils.el.html(el, args.children, {'alias':args.alias, 'context':args.context, 'replace':args.replace});

		if (args.allowedTags === false || utils.is.str(args.allowedTags)){

		}

		if (args.clean){
			// if using <template>, the document context is in the .content property
			var ctx      = el.content ? el.content : el;
			var stylized = utils.dom.getAll('[style]', {'context':ctx});
			
			utils.each(stylized, function (child){
				var tag    = utils.dom.tag(child);
				var style  = child.style;
				var italic = style.fontStyle === 'italic';
				var weight = style.fontWeight === 'bold' || (+style.fontWeight >= 700) ? 'bold' : 'normal';

				// switch back to normal tag
				// standerize the tags
				if (weight === 'normal' && (tag === 'strong' || tag === 'b')){
					child = utils.el.tag(child, 'span');
				}else if (tag === 'b' || (tag !== 'strong' && weight === 'bold')){
					child = utils.el.tag(child, 'strong');
				}else if (tag === 'i' || (tag !== 'em' && italic)){
					child = utils.el.tag(child, 'em');
				}

				// remove styles
				child.removeAttribute('style');
				child.removeAttribute('id');
				child.removeAttribute('class');

				// tag
				tag = utils.dom.tag(child);
				if (tag === 'span'){
					// 	utils.dom.tag(child, false);
				}
			});

			// remove empty nodes
			var empties = utils.dom.getAll('p,div,span,ol,ul,li', {'context':ctx});
			utils.each(empties, function (child){
				if (child.textContent.trim()) return;
				var empty = document.createTextNode(' ');
				child.parentNode.insertBefore(empty, child);
				child.parentNode.removeChild(child);
			});

			// remove <br> right after <p>
			var br = utils.dom.getAll('p + br', {'context':ctx});
			utils.dom.remove(br);
		}
		
        var parent = args.parent && utils.dom.get(args.parent);
        if (parent && parent !== el.parentNode){
            parent.appendChild(el);
        }

        return el;
    };

	// action ------------------------------------------------------------------
	this.selectText = function (el, args){
		// @info https://javascript.info/selection-range
		if (utils.is.bool(args)){
			args = {'focus':args};
		}

		args       = args || {};
		args.focus = 'focus' in args ? args.focus : false;
		args.text  = args.text || '';

		function _select (){
			var range  = document.createRange();
			var select = window.getSelection();
			var child  = el.childNodes[0];

			// simple way of selecting text
			if (args.text && child && child.nodeType === Node.TEXT_NODE){
				var length 	   = child.textContent.length;
				var startIndex = child.textContent.indexOf(args.text);
				var lastIndex  = startIndex + args.text.length;

				if (startIndex > -1 && lastIndex <= length){
					range.setStart(child, startIndex);
					range.setEnd(child, lastIndex);
				}
			}else{
				range.selectNodeContents(el);
			}

			select.removeAllRanges();
			select.addRange(range);
		}

		if (args.focus){
			el.focus();
			utils.fn.requestFrame(_select); // need a delay to work properly
		}else{
			_select();
		}
	};

	function _range (node, chars, range){
		if (!range){
			range = document.createRange();
			range.selectNode(node);
			range.setStart(node, 0);
		}
	
		if (chars.count === 0){
			range.setEnd(node, chars.count);
		}else if (node && chars.count >0){
			if (node.nodeType === Node.TEXT_NODE){
				if (node.textContent.length < chars.count){
					chars.count -= node.textContent.length;
				}else{
					range.setEnd(node, chars.count);
					chars.count = 0;
				}
			}else{
				for (var lp = 0; lp < node.childNodes.length; lp++){
					range = _range(node.childNodes[lp], chars, range);
	
					if (chars.count === 0){
					   break;
					}
				}
			}
	    } 
		return range;
	};
	
	this.selection = function (el, args){
		if (utils.is.nbr(args)){
			args = {'offset':args};
		}else if (args === true){
			args = {'return':'offset'};
		}else if (utils.is.str(args)){
			args = {'return':args};
		}

		args        = args || {};
		args.offset = 'offset' in args ? args.offset : null;
		args.return = 'return' in args ? args.return : null;

		var tag 	= (el.tagName || '').toLowerCase();
		var isInput = tag === 'input' || tag === 'textarea';

		if (utils.is.nbr(args.offset)){
			var offset = args.offset >= 0 ? args.offset : 0; 
			
			if (isInput){
				el.selectionStart = offset;
				el.selectionEnd   = offset;
			}else{
				// @source Set Caret position https://stackoverflow.com/questions/4811822/get-a-ranges-start-and-end-offsets-relative-to-its-parent-container/4812022#4812022
				var selection = window.getSelection();
				var range     = _range(el, {'count':offset});
		
				if (range) {
					range.collapse(false);
					selection.removeAllRanges();
					selection.addRange(range);
				}
			}
		}else if (isInput){
			offset = el.selectionStart;

			if (args.return === 'offset'){
				return offset;
			}else{
				return {
					'node'	   : el,
					'start'    : el.selectionStart,
					'end'      : el.selectionEnd,
					'text'     : el.value.slice(el.selectionStart, el.selectionEnd),
					'offset'   : offset,
				};
			}
		}else{
			// @source Get Caret position https://stackoverflow.com/questions/3972014/get-contenteditable-caret-position
			var offset = 0;
			var doc    = el.ownerDocument || el.document;
			var win    = doc.defaultView || doc.parentWindow;
			var sel, range;

			if (typeof win.getSelection != "undefined"){
				sel = win.getSelection();

				if (sel.rangeCount > 0){
					range = win.getSelection().getRangeAt(0);

					var preCaretRange = range.cloneRange();
					preCaretRange.selectNodeContents(el);
					preCaretRange.setEnd(range.endContainer, range.endOffset);
					offset = preCaretRange.toString().length;
				}
			}else if ((sel = doc.selection) && sel.type != "Control"){
				range = sel.createRange();

				var preCaretTextRange = doc.body.createTextRange();
				preCaretTextRange.moveToElementText(el);
				preCaretTextRange.setEndPoint("EndToEnd", range);
				offset = preCaretTextRange.text.length;
			}

			if (args.return === 'offset'){
				return offset;
			}else{
				return {
					'selection': sel,
					'range'    : range,
					'node'	   : range.endContainer,
					'start'    : range.startOffset,
					'end'      : range.endOffset,
					'text'     : range.endContainer.textContent.slice(0, range.endOffset),
					'offset'   : offset,
				};
			}
		}
	};

	// animation ---------------------------------------------------------------
	this.scroll = function (el, args){
		if (utils.is.str(args)){
			args = {'key':args};
		}else if (args === true){
			args = {'parent':true};
		}

		args        = args || {};
		args.key    = args.key || null;
		args.parent = args.parent || false;

		if (args.parent){
			el = utils.dom.scrollParent(el);
		}

		// size.contentWidth  = Math.max(html.clientWidth, body.scrollWidth, html.scrollWidth, body.offsetWidth, html.offsetWidth);
        // size.contentHeight = Math.max(html.clientHeight, body.scrollHeight, html.scrollHeight, body.offsetHeight, html.offsetHeight);

		var win 		 = window;
		var html 		 = document.documentElement;
		var body 		 = document.body;
		var screenWidth  = Math.max(0, html.clientWidth, win.innerWidth); //Math.max(html.clientWidth, body.scrollWidth, html.scrollWidth, body.offsetWidth, html.offsetWidth);
		var screenHeight = Math.max(0, html.clientHeight, win.innerHeight); //body.scrollHeight, html.scrollHeight, body.offsetHeight, html.offsetHeight);

		var isRoot = !utils.is.el(el);
		var data = {
			'node'        : el,
			'x'           : 0,
			'y'           : 0,
			'top'         : isRoot ? window.pageYOffset : el.scrollTop,
			'right'       : 0,
			'bottom'      : 0,
			'left'        : isRoot ? window.pageXOffset : el.scrollLeft,
			'width'       : isRoot ? document.documentElement.scrollWidth : el.scrollWidth,
			'height'      : isRoot ? document.documentElement.scrollHeight : el.scrollHeight,
			'clientWidth' : isRoot ? screenWidth : el.offsetWidth,
			'clientHeight': isRoot ? screenHeight : el.offsetHeight,
			'maxX'    	  : 0,
			'maxY'   	  : 0,
			'ratioX'      : 0,
			'ratioY'      : 0,
			'isStartX'    : false,
			'isStartY'    : false,
			'isEndX'      : false,
			'isEndY'      : false,
			'isStart'     : false,
			'isEnd'       : false,
		};

		data.x          = data.left;
		data.y          = data.top;
		data.bottom     = data.top + data.clientHeight;
		data.right      = data.left + data.clientWidth;
		data.maxX   	= data.width - data.clientWidth - (isRoot ? 0 : 1);
		data.maxY  		= data.height - data.clientHeight - (isRoot ? 0 : 1);
		data.ratioX     = utils.math.clamp(Math.round(data.left) / data.maxX) || 0;
		data.ratioY     = utils.math.clamp(Math.round(data.top) / data.maxY) || 0;
		data.hasScrollX = data.maxX > 0;
		data.hasScrollY = data.maxY > 0;
		data.isStartX   = data.left === 0;
		data.isStartY   = data.top === 0;
		data.isEndX     = data.ratioX === 1 || (data.width <= data.clientWidth);
		data.isEndY     = data.ratioY === 1 || (data.height <= data.clientHeight);
		data.isStart    = data.isStartX && data.isStartY;
		data.isEnd      = data.isEndX && data.isEndY;

		return args.key ? data[args.key] : data;
	};
	
	this.scrollTo = function (el, args){
		if (arguments.length > 2 || utils.is.nbr(args)){
			utils.deprecated('utils.el.scrollTo(el, x, y, scrollParent)', 'utils.el.scrollTo(el, args...)');

			args = {
				'x'           : arguments[1],
				'y'           : arguments[2],
				'scrollParent': arguments[3],
			};
		}

		if (utils.is.arr(args)){
			args = {'x':args[0], 'y':args[1]};
		}

		args                   = args || {};
		args.x                 = 'x' in args ? args.x : null;
		args.y                 = 'y' in args ? args.y : null;
		args.duration          = "duration" in args ? args.duration : 0;
		args.easing            = args.easing || null;
		args.context           = args.context || null;
		args.onComplete        = args.callback || args.onComplete || null;
		args.scrollParent      = args.scrollParent || false;
		args.scrollRestoration = 'scrollRestoration' in args ? args.scrollRestoration : true;

		if (!args.scrollRestoration){
			history.scrollRestoration = 'manual';
		}

		// format
		args.duration 	= utils.string.toDuration(args.duration);
		args.easing 	= utils._easing(args.easing);

		if (args.scrollParent){
			el = utils.el.scrollParent(el);
		}

		var isRoot  = !el || utils.is.dom(el, true) && el !== document.body;
		var s  		= utils.el.scroll(el);
		var from    = {'x':s.x, 'y':s.y};
		var to 		= {'x':args.x, 'y':args.y};

		// calculate the percent x/y
		if (utils.is.str(to.x) || utils.is.str(to.y) || args.duration){

			// scroll from the current X position
			if (utils.is.str(to.x, /^\+\=/)){
				to.x = from.x + (+to.x.replace('+=', '') || 0);
			}else{
				to.x = utils.calculate(to.x, s.maxX);	
			}

			// scroll from the current Y position
			if (utils.is.str(to.y, /^\+\=/)){
				to.y = from.y + (+to.y.replace('+=', '') || 0);
			}else{
				to.y = utils.calculate(to.y, s.maxY);	
			}
		}

		function _scroll (x, y){
			if (from.x === to.x) x = null;
			if (from.y === to.y) y = null;

			if (isRoot){
				if (!utils.is.nbr(x)) x = window.pageXOffset;
				if (!utils.is.nbr(y)) y = window.pageYOffset;
				window.scrollTo(x, y);
			}else{
				if (utils.is.nbr(x)) el.scrollLeft = x;
				if (utils.is.nbr(y)) el.scrollTop = y;
			}
		}
		
		function _tick (r){
			var x = from.x + ((to.x - from.x) * r);
			var y = from.y + ((to.y - from.y) * r);
			_scroll(x, y);
			(r === 1) && _done();
		}

		function _done (){
			// clear the animation
			utils.cache(el, DOM.CACHE.SCROLL_TO, null);

			// action at the end
			utils.apply(args.onComplete, null, args.context);
		}

		var animation = utils.cache(el, DOM.CACHE.SCROLL_TO);
		utils.fn.cancel(animation);

		if (args.duration){
			animation = utils.fn.animate({'duration':args.duration, 'easing':args.easing}, _tick);
		}else{
			_scroll(to.x, to.y);
			_done();
		}

		utils.cache(el, DOM.CACHE.SCROLL_TO, animation);

		return animation;
	};
	
	this.scrollIntoView = function (el, args){
		args            = args || {};
		args.ratio      = 'ratio' in args ? args.ratio : 0;		// if ratio:false, then the element just try to stay in view
		args.offset     = args.offset || 0;
		args.offsetX	= args.offsetX || 0;
		args.offsetY	= args.offsetY || 0;
		args.double 	= args.double || false;
		args.parent 	= args.parent || true;
		args.direction  = 'direction' in args ? args.direction : true;
		
		if (!utils.el.isVisible(el)){
			return console.warn('[utils.el.scrollIntoView] The element needs to be visible to be scrolled into view');
		}

		if (args.direction === 'y'){
			args.direction = 'vertical';
		}else if (args.direction === 'x'){
			args.direction = 'horizontal';
		}

		var bounds  = utils.dom.bounds(el, {'parent':args.parent});
		var parent  = utils.is.dom(bounds.scrollParent, true) && bounds.scrollParent !== document.body ? window : bounds.scrollParent;
		var offsetX = args.offsetX;
		var offsetY = args.offsetY;

		if (utils.is.nbr(args.offset)){
			offsetX += args.offset;
			offsetY += args.offset;
		}		

		function _scroll (){
			var eBounds = utils.dom.bounds(el, true).bbox;
			var pBounds = utils.dom.bounds(parent);
			var h       = pBounds.pbox.height - eBounds.height;
			var w       = pBounds.pbox.width - eBounds.width;
			var x 		= null;
			var y 		= null;

			if (args.ratio === false){
				if (eBounds.top - pBounds.scrollTop < 0) 		y = eBounds.top - offsetY;
				else if (eBounds.top - pBounds.scrollTop > h)	y = eBounds.top - h + offsetY;

				// @todo test the horizontal scrolling
				if (eBounds.left - pBounds.scrollLeft < 0) 		x = eBounds.left - offsetY;
				else if (eBounds.left - pBounds.scrollLeft > w)	x = eBounds.left - w + offsetY;
			}else{
				x = eBounds.left - (args.ratio * w) + offsetX;
				y = eBounds.top - (args.ratio * h) + offsetY;				
			}

			return {
				'x' : x,
				'y' : y,
			};
		}

		var s = _scroll();
		var c = args.onComplete;
		var x = args.direction === true || args.direction === 'horizontal';
		var y = args.direction === true || args.direction === 'vertical';

		if (x) args.x = s.x;
		if (y) args.y = s.y;

		args.onComplete = function (){
			if (args.double){
				s = _scroll();
				utils.el.scrollTo(parent, {
					'x': x && s.x,
					'y': y && s.y,
				});
			}
			utils.apply(c, null, this);
		};

		return utils.el.scrollTo(parent, args);
	};

	// helpers -----------------------------------------------------------------
	this.toFullscreen = function (el, args){
		args         = args || {};
		args.context = args.context || null;
		args.onOpen  = args.onOpen || null;
		args.onClose = args.onClose || null;

		var isFullscreen = false;
		
		var props = {
			'fullscreenEnabled' : '',
			'fullscreenElement' : '',
			'requestFullscreen'	: '',
			'exitFullscreen'    : '',
			'fullscreenchange'	: '',
		};

		if ('fullscreenEnabled' in document){
			props.fullscreenEnabled = 'fullscreenEnabled';
			props.fullscreenElement = 'fullscreenElement';
			props.requestFullscreen = 'requestFullscreen';
			props.exitFullscreen    = 'exitFullscreen';
			props.fullscreenchange  = 'fullscreenchange';
		}else if ('webkitFullscreenEnabled' in document){
			props.fullscreenEnabled = 'webkitFullscreenEnabled';
			props.fullscreenElement = 'webkitFullscreenElement';
			props.requestFullscreen = 'webkitRequestFullScreen';
			props.exitFullscreen    = 'webkitExitFullscreen';			
			props.fullscreenchange  = 'webkitfullscreenchange';
		}else if ('mozFullscreenEnabled' in document){
			props.fullscreenEnabled = 'mozFullScreenEnabled';
			props.fullscreenElement = 'mozFullScreenElement';
			props.requestFullscreen = 'mozRequestFullScreen';
			props.exitFullscreen    = 'mozCancelFullScreen';
			props.fullscreenchange  = 'mozfullscreenchange';
		}else if ('msFullscreenEnabled' in document){
			props.fullscreenEnabled = 'msFullscreenEnabled';
			props.fullscreenElement = 'msFullscreenElement';
			props.requestFullscreen = 'msRequestFullscreen';
			props.exitFullscreen    = 'msExitFullscreen';
			props.fullscreenchange  = 'MSFullscreenChange';
		}else{
			return;
		}


		if (!document[props.fullscreenEnabled]){
			return false;
		}

		utils.el.addEvent(document, props.fullscreenchange, function(e){
			if (!document[props.fullscreenElement]){ 
				_close();
			}
		});

		function _open (){
			if (isFullscreen) return;
			
			el[props.requestFullscreen]();
			utils.apply(args.onOpen, [el], args.context);

			isFullscreen = true;
		}

		function _close (){
			if (!isFullscreen) return;

			if (document[props.fullscreenElement]){
				document[props.exitFullscreen]();
			}
			
			utils.apply(args.onClose, [el], args.context);

			isFullscreen = false;
		}

		function _toggle (){
			if (isFullscreen){
				_close();
			}else{
				_open();
			}
		}

		return {
			'open'  : _open,
			'close' : _close,
			'toggle': _toggle,
		}
	};
});

Utils.add('els', function (utils, DOM, RE){
    // consts ------------------------------------------------------------------
	
    // methods -----------------------------------------------------------------
	this.remove = function (els){
        var isSingle = false;

		if (!(els instanceof Array)){
			els      = [els];
			isSingle = true;
		}

        var i=0, l=els.length;
		for (; i<l; ++i){
			if (els[i].parentNode){
				els[i].parentNode.removeChild(els[i]);
			}
		}
		
		return isSingle ? els[0] : els;
	};
	
	this.add = function (els, position, selector){
		// @todo add isSingle (like remove()). To return only 1 element

		if (selector === undefined){
			selector = position;
			position = null;
		}
		if (utils.is.invalid(position)){
			position = 'append';
        }
		
		var target = utils.dom.get(selector);
		if (!target || els === target) return;
        
		var parent = target.parentNode;
		var frag   = null;

		if (els instanceof DocumentFragment){
			frag = els;			
		}else{
			frag = document.createDocumentFragment();
			els  = utils.dom.getAll(els);

			var i=0,l=els.length;
			for (;i<l;++i){
				frag.appendChild(els[i]);
			}
		}
		
		// keep the first element for return
		var el = frag.childNodes[0];

        if (parent){
            if (position === 'before'){
                parent.insertBefore(frag, target);
            }else if (position === 'after'){
                parent.insertBefore(frag, target.nextSibling);
            }else if (position === 'replace'){
                parent.insertBefore(frag, target);
			    parent.removeChild(target);
            }else if (position === 'wrap'){
                parent.insertBefore(frag, target);
            }
        }
        
        if (position === 'wrap'){
			var deep = el;
			while (deep.children.length){ deep = deep.children[0]; }
			deep.appendChild(target);
        }else if (position === 'prepend'){
            target.insertBefore(frag, target.childNodes[0]);
        }else if (position === 'append'){
            target.appendChild(frag);
		}else if (position === 'html' || position === 'children'){
			target.innerHTML = '';
			target.appendChild(frag);
        }else if (utils.is.nbr(position)){
            if (target.children[position]){
				target.insertBefore(frag, target.children[position]);
				//target.insertBefore(frag, target.children[position].nextSibling);
			}else{
				target.appendChild(frag);
			}
        }
        
        return el;
	};

	// style -------------------------------------------------------------------
	this.style = function (els, key, value){
		var response = null
		utils.each(els, function (el){
			response = utils.el.style(el, key, value);
		});
		return response;
	};

	this.equalize = function (els, args){
		args      = args || {};
		args.type = 'type' in args ? args.type : true;
		args.key  = 'key' in args ? args.key : true;  // [true, attr key], if TRUE for all elements to be in the same "width/height"

		var indexes 	= {};
		var heights		= [];
		var widths 		= [];
		var totalHeight = 0;
		var totalWidth  = 0;
		var heightCount = 0;
		var widthCount  = 0;

		// reset the width/height first (doing this separately makes it faster)
		utils.each(els, function (el, i){
			el.style.height = '';
			el.style.width  = '';
		});

		utils.each(els, function (el, i){
			if (!utils.el.isVisible(el)){
				return;
			}

			var index  = args.key ? el.getAttribute(args.key) : utils.el.index(el);
			var bounds = utils.el.bounds(el);
			var height = bounds.bbox.height; //el.clientHeight;
			var width  = bounds.bbox.width;  //el.clientWidth;

			if (args.key === ':row'){
				index = bounds.bbox.y;
			}

			if (index in heights){
				height = Math.max(heights[index], height);
				heightCount++;
			}
			if (index in widths){
				width = Math.max(widths[index], width);
				widthCount++;
			}

			indexes[i] 		= index;
			heights[index] 	= height;
			widths[index] 	= width;
		});

		utils.each(els, function (el, i){
			if (!(i in indexes)) return;

			var index  = indexes[i];
			var height = heights[index];
			var width  = widths[index];

			if (heightCount > 0 && (args.type === true || args.type === 'height')){
				el.style.height = height + 'px';
			}
			if (widthCount > 0 && (args.type === true || args.type === 'width')){
				el.style.width  = width + 'px';
			}
		});

		utils.each(heights, function (v){ totalHeight += (v || 0); });
		utils.each(widths, function (v){ totalWidth += (v || 0); });

		return {
			'height': totalHeight,
			'width' : totalWidth,
		}
	};

    // events ------------------------------------------------------------------
	this.onMediaLoad = function (els, args, callback){
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args 			= (typeof args === 'function' ? {'onComplete':args} : args) || {};
		// args.types 		= 'types' in args ? args.types : 'img,video,audio,iframe';
		args.types 		= 'types' in args ? args.types : 'img';
		args.context 	= 'context' in args ? args.context : null;
		args.callback 	= 'callback' in args ? args.callback : callback;
		
		var medias     = utils.dom.getAll(args.types, {'context':els, 'includeContext':true});
		var isComplete = false;
		
		var i=0, l=medias.length; 
		for (;i<l;++i){
			medias[i].addEventListener('load', _check);
			medias[i].addEventListener('error', _check);
		}

		function _check (){
			var readyCount = 0;

			var i=0, l=medias.length, m, t;
			for (;i<l;++i){
				m = medias[i];
				t = m.tagName.toLowerCase();

				if (t === 'img'){
					(m.complete) && (readyCount++);
				}else if (t === 'video' || t === 'audio'){
					// @todo test this
					(m.readyState === 4 || m.error) && (readyCount++);
				}else if (t === 'iframe'){
					// @todo
				}
			}

			// @todo sometimes this is called twice or more (something with the events and the _check.... or something like that)
			if (readyCount >= medias.length && !isComplete){
				isComplete = true;
				utils.apply(args.callback, [medias], args.context);
			}
		}

		_check();
	}; 

	// sortcuts ----------------------------------------------------------------
	utils.el.remove = this.remove;
	utils.el.add    = this.add;
});

Utils.add('support', function (utils, SUPPORT, RE, CONSTS){
	this.webp = function (){
		if ('WEBP' in SUPPORT) return SUPPORT.WEBP;

		var s = false;
		var c = document.createElement('canvas');
		if (!!(c.getContext && c.getContext('2d'))){
			s = c.toDataURL('image/webp').indexOf('data:image/webp') == 0;
		}else{
			s = false; // very old browser like IE 8, canvas not supported
		}

		SUPPORT.WEBP = s;

		return s;
	};
});

Utils.add('dom', function (utils, DOM, RE, CONSTS){
	// @todo add function "el.add" to use multiple elements, instead of only 1

    // consts ------------------------------------------------------------------
    RE.NUMBER_UNITS		= /(\-?\d+(?:\.\d+)?(?:em|rem|%|vh|vw|px|sw|sh|cw|ch|w|h))/g;
	RE.STYLE_KEY_VALUE  = /([a-z-]+)\:([^\:\;\}]+)/gm;

	DOM.IS_READY         = false;
	DOM.IS_LOADED        = false;
	DOM.ON_READY         = [];
	DOM.ON_LOAD          = [];

	DOM.HEAD_STYLE       = null;
	DOM.ADDED_STYLES     = {};
	DOM.CUSTOM_STYLES 	 = {};

	DOM.GLOBAL_SVG       = null;
	DOM.GLOBAL_SVG_DEFS  = null;
	DOM.GLOBAL_SVG_ITEMS = {};

	DOM.CURSORS			 = {};
	DOM.CURSOR_TYPES 	 = [
		'auto','default','none','context-menu','help','pointer',
		'progress','wait','cell','crosshair','text','vertical-text',
		'alias','copy','move','no-drop','not-allowed','all-scroll',
		'col-resize','row-resize','n-resize','e-resize','s-resize',
		'w-resize','ns-resize','ew-resize','ne-resize','nw-resize',
		'se-resize','sw-resize','nesw-resize','nwse-resize',
	];

	// el/els ------------------------------------------------------------------
	for (var i in utils.el){
		this[i] = (function (name){
			return function (el){
				arguments[0] = utils.dom.get(el);
				return utils.el[name].apply(this, arguments);
			}
		}(i));
	};

	for (var i in utils.els){
		this[i] = (function (name){
			return function (els){
				arguments[0] = utils.dom.getAll(els);
				return utils.els[name].apply(this, arguments);
			}
		}(i));
	};

    // methods -----------------------------------------------------------------
	this.isReady = function (){
        if (document.readyState === 'complete' || (document.readyState !== "loading" && !document.documentElement.doScroll)){
			DOM.IS_READY = true;
        }
		return DOM.IS_READY === true;
    };
    
    this.isLoaded = function (){
        if (document.readyState === 'complete'){
			DOM.IS_LOADED = true;
		}
		return DOM.IS_LOADED === true;
	};
	
	this.ready = function (context, callback, priority){
		if (utils.is.fn(context)){
			priority = callback;
			callback = context;
			context  = null;
		}

		if (!utils.is.fn(callback)) return;

		if (context){
			callback = callback.bind(context);
		}

		priority = priority || 0;

		if (utils.dom.isReady()){
			callback();
		}else{
			DOM.ON_READY[priority] = DOM.ON_READY[priority] || [];
			DOM.ON_READY[priority].push(callback);

			if (DOM.IS_READY === false){
                DOM.IS_READY = 'loading';
                
                function _done (e){
					DOM.IS_READY = true;                    
					utils.each(DOM.ON_READY, function (v, i){ 
						utils.each(v, function (c){ c(); });
					});
                    DOM.ON_READY = [];
                }

				document.addEventListener('website-ready', _done);	// connected to the Web.ready() function
				document.addEventListener('DOMContentLoaded', _done);
				window.addEventListener('load', _done);
			}
		}
    };

    this.load = function (context, callback, priority){
		if (utils.is.fn(context)){
			priority = callback;
			callback = context;
			context  = null;
		}
		
		if (!utils.is.fn(callback)) return;

		if (context){
			callback = callback.bind(context);
		}

		priority = priority || 0;

		if (utils.dom.isLoaded()){
			callback();
		}else{
			DOM.ON_LOAD[priority] = DOM.ON_LOAD[priority] || [];
			DOM.ON_LOAD[priority].push(callback);

			if (DOM.IS_LOADED === false){
                DOM.IS_LOADED = 'loading';
                
                function _done (){
                    DOM.IS_LOADED = true;
                    utils.each(DOM.ON_LOAD, function (v, i){ 
						utils.each(v, function (c){ c(); });
					});
                    DOM.ON_LOAD = [];
                }

				window.addEventListener('load', _done);
			}
		}
	};

	// quick shortcut
	if (window.onready){
		this.ready(window.onready);
	}
	if (window.onload){
		this.load(window.onload);
	}

	// elements ----------------------------------------------------------------
	this.get = function (selector, args){
		if (utils.is.dom(args, false, false)){
			args = {'context':args};
		}else if (utils.is.bool(args)){
			args = {'create':args};
		}
		
		args 				= args || {};
		args.create 		= 'create' in args ? args.create : true;	// check if the get can create an DOM from a plainObject
		args.single 		= 'single' in args ? args.single : true;
		args.alias			= args.alias || '';
		args.filter 		= args.filter || null;
		args.text 			= args.text || false;
		args.includeContext = 'includeContext' in args ? args.includeContext : false;
        args.onlyElements 	= 'onlyElements' in args ? args.onlyElements : false;
		args.excludeClosest	= 'excludeClosest' in args ? args.excludeClosest : false;
		// args.excludeContext = 'excludeContext' in args ? args.excludeContext : false;

		// @todo if the selector is a string, have a way to skip the context (go back to :root)...
		// @todo deal with :scope properly

        // var context = utils.is(args.context) ? args.context : document;
		var context = 'context' in args && args.context ? args.context : document;

		if (utils.is.str(context) && !!~context.indexOf('<')){
			// @source jQuery code
			var doc = document.implementation.createHTMLDocument("");
			doc.body.innerHTML = context;
			context = doc.body;
		}

		// var context = 'context' in args ? args.context : document;
        if (!Array.isArray(context)){
            context = [context];
        }
        
		var _alias = function (s, withPrefix){
			if (!utils.is.str(s) || !args.alias) return s;
			return s.replace(/&--/g, (withPrefix ? '.' : '') + args.alias + '--'); // @todo make this better, to target only when in between parentheses
		}

		var elements = [];
		var contexts = [];
        var i=0, l=context.length, s, ctx, children;
        
        // validate the contexts
		for (;i<l; ++i){
            ctx = context[i];

            if (ctx && !utils.is.dom(ctx, false, false) && !(ctx instanceof DocumentFragment)){
				ctx = utils.dom.get(ctx);
			}           
			if (ctx instanceof Document){
				ctx = ctx.documentElement;
			}

			if (!ctx) continue;
            contexts.push(ctx);
            
			// include the current context if it's the same thing as the selector
			if (args.includeContext && utils.el.is(ctx, selector)){
				elements.push(ctx);
			}
		}

		// domElement
		if (utils.is.dom(selector)){
			elements.push(selector);
		// nodeElement
		}else if (utils.is.node(selector)){
			elements.push(args.onlyElements ? selector.parentNode : selector);
		// object contains an "element" node
		}else if (utils.is.obj(selector) && utils.is.either(selector.element, 'el,query')){
			if (utils.is.el(selector.element)){
				elements.push(selector.element);
			}else if (utils.is.query(selector.element)){
				elements = elements.concat(utils.toArray(selector.element));	
			}
		// jQuery or other types of Query object
		}else if (utils.is.query(selector)){
			elements = elements.concat(utils.toArray(selector));
		// create element with an object
		}else if (args.create && utils.is.obj(selector, true)){
			var node = utils.dom.create(selector);
			elements.push(node);
		// create html
		}else if (utils.is.str(selector) && selector.trim()[0] === '<'){
			// @todo add alias to attributes
			var html 	   = _alias(selector);
			var frag 	   = document.createElement('template');
			frag.innerHTML = html;
			children 	   = utils.toArray(frag.content ? frag.content.children : frag.children, {'filter':function (c){ c.parentNode.removeChild(c); return c; }});  // detach the children from the temporary parent
            elements 	   = elements.concat(children);
		// create text node
		}else if (args.text && utils.is.str(selector) && (~selector.indexOf('&') || ~selector.indexOf(' '))){
			var frag = document.createElement('div');
			frag.innerHTML = selector;

			var i=0, l = frag.childNodes.length;
			for (; i<l; ++i){
				elements.push(frag.childNodes[i]);
			}
		// find elements by string OR function
		}else if (utils.is.either(selector, 'string,function')){
			i = 0;
            l = contexts.length;

            var attr;
			for (; i<l; ++i){
				attr 	 = null;
				ctx      = contexts[i];
				children = [];

				try{
                    if (utils.is.fn(selector)){
                        children = selector.call(ctx, ctx);
                    }else if (ctx && utils.is.fn(ctx.querySelectorAll)){
						s = _alias(selector, true);
						s = s.replace(/(?:(?:^|\s)#([^\s]+))/g, '[id="$1"]'); // selector for ID that starts with a number breaks, so instead we convert them to attribute selector

						// scope fix (add a custom attribute as a prefix) @polyfill https://github.com/jonathantneal/element-qsa-scope/blob/master/index.js
						if (ctx !== document && !(ctx instanceof DocumentFragment)){
							attr = utils.string.random('attr');
                            ctx.setAttribute(attr, '');
                            children = ctx.querySelectorAll('['+attr+'] ' + s);
						}else{
							children = ctx.querySelectorAll(s);
						}
					}
				}catch (e){
					children = [];
				}

				// remove the temporary attr for scope
				if (ctx && typeof(ctx.removeAttribute) === 'function' && attr){
					ctx.removeAttribute(attr);
				}

				children = utils.toArray(children);
				elements = elements.concat(children);
			}
		// is an array
		}else if (utils.is.enumerable(selector)){
            i = 0;
            l = selector.length;

            for (;i<l; ++i){
				s 		 = _alias(selector[i], true);
				children = utils.dom.getAll(s, {'context':args.contexts, 'alias':args.alias, 'onlyElements':args.onlyElements});
				elements = elements.concat(children);
			}
		}

		if (args.excludeClosest){
			var ctx = contexts[0];

			elements = elements.filter(function (el){
				var parent = utils.el.closest(el, args.excludeClosest, ctx);
				return !parent || parent === ctx;
			});
		}
		if (args.filter && utils.is.str(args.filter)){
			elements = elements.filter(function (el){
				return utils.dom.is(el, args.filter);
			});
		}

		if (args.single){
			return elements[0];
		}else{
			return utils.toArray(elements);
		}
	};

	this.getAll = function (selector, args){
		args        = (utils.is.dom(args, false, false) ? {'context':args} : args) || {};
		args.single = false;
		return utils.dom.get(selector, args);
	};
	
	this.create = function (tag, args){
		if (utils.is.obj(tag, true)){
			args = utils.extend({}, args || {}, tag);
			tag  = args.tag || 'div';
		}

		if (utils.is.str(tag)){
			tag = tag.trim();
		}

		if (utils.is.str(args)){
			args = {'html':args};
		}

		args           = args || {};
		args.svg       = args.svg || false;
		args.namespace = args.namespace || null;
		args.extract   = args.extract || false;
		args.clone     = args.clone || false;
		args.alias     = args.alias || '';
		args.attrs     = args.attrs || {};
		args.clone     = args.clone || false;
		args.text      = args.text || false;      // option to create a text node
		args.return    = args.return || false;    // [null, wrap]

		function _create (tag){
			if (tag === 'svg'){
				args.svg 					= true;
				args.attrs['xmlns'] 		= 'http://www.w3.org/2000/svg';
				args.attrs['xmlns:xlink'] 	= 'http://www.w3.org/1999/xlink';
			}
			if (args.svg){
				args.namespace = 'http://www.w3.org/2000/svg';
			}

			if (args.namespace){
				return document.createElementNS(args.namespace, tag);
			}else{
				return document.createElement(tag);
			}
		}

		tag = tag || args.tag || 'div';

		if (utils.is.str(tag) && args.text && tag[0] !== '<'){
			var node = document.createTextNode(tag);
			return node;
		}

		var el = null;
		if (utils.is.el(tag)){
			if (args.clone){
				el = utils.el.clone(tag);
			}else{
				el = tag;
			}
		}else if (utils.is.str(tag) && tag[0] === '<'){
			if (args.alias){
				tag = tag.replace(/\&/g, args.alias);
			}

			var fragment = _create(args.tag || 'div');
			fragment.innerHTML = tag;

			if (args.return === 'wrap'){
				el = fragment;
			}else{
				el = fragment.children[0];
			}
		}else if (utils.is.str(tag)){
			args.tag = tag;

			var node = utils.el._nodes(args)[0];

			el 		   = _create(node.tag);
			args.attrs = node.attrs;
			args.props = node.props;
			args.class = node.class;
			args.style = node.style;
		}

		utils.el.update(el, args);

		if (args.extract){
			return utils.el.extract(el, {'single':args.extract, 'clean':true});
		}else if (args.return === 'html'){
			return el.innerHTML;
		}else{
			return el;
		}
	};

	this.svg = function (args, item){
		if (arguments.length === 1){
			item = args;
			args = {};
		}

		args 		= (typeof args === 'boolean' ? {'defs':args} : args) || {};
		args.defs 	= 'defs' in args ? args.defs : false;
		args.update = 'update' in args ? args.update : true;

		var svg  = DOM.GLOBAL_SVG;
		var defs = DOM.GLOBAL_SVG_DEFS;

		// create the global SVG 
		if (!svg){
			svg = DOM.GLOBAL_SVG = utils.dom.create('svg', {
				'svg'	: true,
				'style' : {
					'opacity'   : 0,
					'position'  : 'absolute',
					'top'		: 0,
					'left'		: 0,
					'width'		: 0,
					'height'	: 0,
				},
				'children':[defs = DOM.GLOBAL_SVG_DEFS = utils.dom.create('defs', {'svg':true})]
			});
			utils.dom.add(svg, 'prepend', document.body);
		}

		var id 	  = item.id || utils.string.random();
		var meta  = DOM.GLOBAL_SVG_ITEMS[id];
		
		if (!meta){
			var parent = args.defs ? defs : svg;
			var url     = 'url(#'+id+')';
			var el 	    = utils.dom.create(item, {'id':id, 'svg':true, 'parent':parent});
			meta 		= DOM.GLOBAL_SVG_ITEMS[id] = {'url':url, 'element':el};
			args.update = true;
		}

		if (args.update){
			delete(meta.id);
			delete(meta.tag);
			utils.el.update(meta.element, item);
		}

		return meta;
	};

	this.canvas = function (args){
		args        = args || {};
		args.size   = utils.array.to2Numbers(args.size || '100x100');
		args.cache  = args.cache || null;
		args.return = args.return || 'ctx'; 
		
		var canvas = (args.cache && DOM.CANVAS[args.cache]) || document.createElement('canvas');
		canvas.width  = args.size[0];
		canvas.height = args.size[1];
	
		if (args.cache){
			DOM.CANVAS[args.cache] = canvas;
		}

		return args.return === 'ctx' ? canvas.getContext('2d') : canvas;
	};
	
	this.lazy = function (selector, args){
		if (typeof selector === 'function'){
			args     = selector;
			selector = null;
		}

		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args             = args || {};
		args.context     = 'context' in args ? args.context : null;
		args.callback    = 'callback' in args ? args.callback : null;
		args.onLoad      = 'onLoad' in args ? args.onLoad : null;
		args.visibleOnly = 'visibleOnly' in args ? args.visibleOnly : false;
		args.clean       = 'clean' in args ? args.clean : true;               // remove the ratio added by the PHP
		args.separator   = 'separator' in args ? args.separator : '|';        // separator to use multiple images (for webp)
		args.transition  = 'transition' in args ? args.transition : false;    // add a transition class when it appears
		//args.cache 		 = 'cache' in args ? args.cache : true;				  // cache the elements
		
		var context  = selector ? utils.dom.getAll(selector) : null;
		var elements = utils.dom.getAll('[lazy-src], [lazy-bg]', {'context':context, 'includeContext':true});
		var queue 	 = utils.fn.queue(function (){ utils.apply(args.callback, [elements], args.context); });

		if (!utils.media){
			return utils.error('"utils.media" is necessary to use "utils.dom.lazy"');
		}

		utils.each(elements, function (el){
			if (args.visibleOnly && !utils.el.isVisible(el)){
				return;
			}
			
			var isIFrame = el.tagName.toLowerCase() === 'iframe';
			var bg       = el.getAttribute('lazy-bg');
			var src      = el.getAttribute('lazy-src');
			var srcs     = ((isIFrame ? src : utils.toSrc(bg || src)) || '').split(args.separator);
			var done     = queue.add();

			// remove .webp if not supported
			srcs = srcs.filter(function (s){
				if (~s.indexOf('.webp') && !utils.support.webp()){
					return false;
				}
				return true;
			});

			if (isIFrame){
				src[0] && el.setAttribute('src', src[0]);
				el.removeAttribute('lazy-src');
				el.removeAttribute('lazy-bg');
				return;
			}

			// @todo check all images in the list
			utils.media.image(srcs[0], function (img){
				if (args.clean){
					el.style.maxWidth   = '';
					el.style.paddingTop = '';
				}
				if (bg){
					el.style.backgroundImage = 'url('+img.src+')';
				}
				if (src){
					el.setAttribute('src', img.src);
				}

				el.removeAttribute('lazy-src');
				el.removeAttribute('lazy-bg');

				if (args.transition){
					utils.el.transitionClass(el, args.transition);
				}

				utils.apply(args.onLoad, [el, img], args.context);

				done();
			});
		});
	};

	// events ------------------------------------------------------------------

	// screen ------------------------------------------------------------------
	this.screenSize = function (refresh){
		var w = window.innerWidth;
		var h = window.innerHeight;

		if (((DOM.SCREEN_W !== w || DOM.SCREEN_H !== h) || refresh) && document.body){
			var dummy = DOM.DUMMY;
			
			if (!dummy){
				dummy = DOM.DUMMY = document.createElement('div');
				dummy.setAttribute('dummy', 'viewport');
			}

			dummy.style = 'position:fixed; width:100vw; height:100vh;';
            document.body.appendChild(dummy);
			
			var vw = dummy.clientWidth;
			var vh = dummy.clientHeight;

			dummy.style = 'position:fixed; width:100%; height:100%;';
			var fw = dummy.clientWidth;
			var fh = dummy.clientHeight;

			// window size
			DOM.SCREEN_W   = w;
			DOM.SCREEN_H   = h;
			// fullscreen, no scrollbar
			DOM.VIEWPORT_W = vw;
			DOM.VIEWPORT_H = vh;
			// fixed width/height
			DOM.FIXED_W    = fw;
			DOM.FIXED_H    = fh;
			// content size - scrollbar (if active)
			DOM.CLIENT_W   = document.documentElement.clientWidth;
			DOM.CLIENT_H   = document.documentElement.clientHeight;
			// scroll size
			DOM.SCROLL_W   = document.documentElement.scrollWidth;
			DOM.SCROLL_H   = document.documentElement.scrollHeight;
			// rem size
			DOM.REM        = parseInt(window.getComputedStyle(document.documentElement).fontSize, 10);

			// calculate the size of a scrollbar
			dummy.style.overflow = 'scroll';
			DOM.SCROLLBAR_SIZE = DOM.CLIENT_W - dummy.clientWidth;

			document.body.removeChild(dummy);
		}

		return {
			'width'         : DOM.SCREEN_W || w,
			'height'        : DOM.SCREEN_H || h,
			'viewportWidth' : DOM.VIEWPORT_W || w,
			'viewportHeight': DOM.VIEWPORT_H || h,
			'fixedWidth'    : DOM.FIXED_W || w,
			'fixedHeight'   : DOM.FIXED_H || h,
			'clientWidth'   : DOM.CLIENT_W || w,
			'clientHeight'  : DOM.CLIENT_H || h,
			'scrollWidth'   : DOM.SCROLL_W || w,
			'scrollHeight'  : DOM.SCROLL_H || h,
			'scrollbarSize' : DOM.SCROLLBAR_SIZE || 0,
			'remSize'       : DOM.REM || 0,
		};
	};	
	
	// style -------------------------------------------------------------------
	this.addStyle = function (args, text){
		if (text === undefined){
			text = args;
			args = {};
		}

		args         = args || {};
		args.name    = 'name' in args ? args.name : null;
		args.once    = 'once' in args ? args.once : true;
		args.element = 'element' in args ? args.element : null;
		args.insert	 = 'insert' in args ? args.insert : 'prepend';
		args.vars 	 = 'vars' in args ? args.vars : null;
		args.alias 	 = 'alias' in args ? args.alias : '';
		args.format  = args.format || null;
		args.context = args.context || null;

		if ('root' in args){
			args.alias = args.root;
			utils.warn('"root" argument is deprecated, use "alias" instead');
		}

		// no duplicates
		if (args.once && args.name && args.name in DOM.ADDED_STYLES){
			return;
		}

		// make sure the text is a string
		if (utils.is.obj(text)){
			var props = [];
			for (var i in text){
				props.push(i + '{ '+text[i]+' }');
			}
			text = props.join('\n');
		}

		text = (args.name ? '/* ------------------------------------------------ \n' + 
			args.name + 
			'\n ------------------------------------------------ */\n' : '\n') + text
			.replace(/\t|\n/g, ' ')
			.replace(/\s{2,}/g, ' ')
			.replace(/\}\s+/g, '}\n')
			.trim() + '\n\n';

		// parse the variables in the text
		if (args.vars){
			// make sure the vars that have variables are parsed
			for (var i in args.vars){
				args.vars[i] = utils.string.replace(args.vars[i], args.vars);
			}
			for (var i in args.vars){
				var re = utils.string.toRegExp(['\{\{\\s*', i ,'\\s*\}\}']);
				text = text.replace(re, args.vars[i]);
			}
		}

		text = utils.apply(args.format, [text], args.context, text);

		if (args.alias){
			text = text.replace(/\&/g, '.' + args.alias);
		}

		function _v (name, value){
			value = utils.el.toStyleValue(name, value);
			name  = utils.el.toStyleName(name);
			return name + ':' + value;
		}
		
		// @todo validate all the props/values
		text = text.replace(RE.STYLE_KEY_VALUE, function (m, $1, $2){
			var name  = $1.trim();
			var value = $2.trim();

			if (name in DOM.CUSTOM_STYLES){
				value = utils.toValues(value, false);
				value = DOM.CUSTOM_STYLES[name].apply(null, value);

				if (utils.is.obj(value)){
					var add = [];
					for (var i in value){
						add.push(_v(i, value[i]));
					}

					return add.join('; ');
				}else if (utils.is.either(value, 'str,nbr')){
					return value.toString();
				}else{
					utils.error('The Custom Style "{name}" didn\'t return a valid value', {'name':name});
					return '';
				}
			}else{
				return _v(name, value);
			}
		});

		text = document.createTextNode(text);
		
		var style;
		if (args.element){
			var wrap = utils.dom.create('<div class="style-custom" style="display:none;">\
				&shy;<style element="style"></style>\
			</div>', {'extract':'element'});

			style = utils.dom.add(wrap.style, args.insert, args.element);
		}else if (!DOM.HEAD_STYLE){
			style = DOM.HEAD_STYLE = utils.dom.create('<style type="text/css" class="style-custom"></style>');
			utils.dom.add(style, args.insert, 'head');
		}else{
			style = DOM.HEAD_STYLE;
		}
	
		style.appendChild(text);

		if (args.once && args.name){
			DOM.ADDED_STYLES[args.name] = true;
		}

		return text;
	};

	this.addCustomStyle = function (name, callback){
		if (name in DOM.CUSTOM_STYLES){
			return utils.error('Custom style "{name}" already exists', {'name':name});
		}
		DOM.CUSTOM_STYLES[name] = callback;
	};
	
	this.flip = function (items, args){
		if (!utils.is.arr(items)){
			items = [items];
		}
		if (utils.is.el(items[0])){
			items = [{'selector':items}];
		}

		if (utils.is.str(args)){
			args = {'classname':args};
		}else if (utils.is.fn(args)){
			args = {'onStart':args};
		}

		args = utils.args(args, {
			// transition ------------------------------
			'context'        : null,
			'delay'          : 0,
			'onBefore'       : false,
			'onAfter'        : false,
			'onComplete'     : false,
			'onEach'         : false,
			'onCalculate'    : false,
			'onPlay'		 : false,
			'transitionClass': 'is-transitioning',
			// item ------------------------------------
			'classname'	 : '',
			'duration'	 : 500,
			'easing'	 : null,
			// item props and events
			'props'      : '',
			'translate'  : true,
			'scale'      : false,   // @todo maybe
			'visibility' : true,
			'fill'       : false,   // [forward, backward, false]
			'onShow'     : false,
			'onHide'     : false,
			'onMove'     : false,
			'onEnter'    : false,
			'onLeave'    : false,
			'onClean'	 : false,
			'onCancel'	 : false,
		});

		var duration   = utils.string.toDuration(args.duration);
		var elements   = [];
		var countDone  = 0;
		var isComplete = false;

		function _props (props){
			if (!props) return false;

			var data = {};

			utils.each(props, function (v, i, a){
				if (a.type !== 'object'){
					i = v;
					v = true; // true means use the current value
				}
				if (!Array.isArray(v)){
					v = [v, v];
				}

				data[i] = v;
			});

			return data;
		}

		function _cache (el, item, index){
			index = index || 0;

			var cache  = utils.el.cache(el, '__FLIP__');
			var old    = cache;
			var isFrom = index === 0;

			if (!cache || isFrom){
				cache = {
					'el'        : el,
					'parentNode': el.parentNode,
					'item'		: item,
					'timeout'   : null,
					'x'         : [0,0],
					'y'         : [0,0],
					'w'         : [0,0],
					'h'         : [0,0],
					'visible'	: [false,false],
					'display'	: '',
					'transform' : '',
					'dx'        : 0,
					'dy'        : 0,
					'sw'		: 1,
					'sh'		: 1,
					'props'     : {},
					'styleFrom' : {},	
					'styleTo'	: {},
					'cssText'	: '',
					'isShowing' : false,
					'isHiding'  : false,
					'isEntering': false,
					'isLeaving' : false,
					'isMoving'  : false,
				};
			}

			var visible = cache.visible[index] = utils.el.isVisible(el);
			var style   = window.getComputedStyle(el);

			// visibility fixes
			if (isFrom){
				cache.display = style.display;
			}else{
				if (cache.visible[0] !== cache.visible[1]){
					if (cache.visible[1]){
						cache.isShowing = true;
					}else{
						cache.isHiding = true;
					}
				}

				if (!el.parentNode){
					cache.isLeaving = true;
				}else if (!cache.parentNode){
					cache.isEntering = true;
				}

				if (cache.isHiding || cache.isLeaving){
					// @todo re-add the element to it's parent

					// make sure the element is visible
					_style(el, {
						'display'   : cache.display || 'block',
						'overflow'  : 'hidden',
						'position'	: item.translate ? 'absolute' : '',
						'left'		: item.translate ? 0 : '',
						'top'		: item.translate ? 0 : '',
						'width'		: cache.w[0],
						'height'	: cache.h[0],
					//	'zIndex'	: 0,
					});
				}else{
					_style(el, {
					//	'zIndex'  : 1,
					});
				}
			}

			//*
			var bounds = el.getBoundingClientRect();
			var x      = cache.x[index] = bounds.left;
			var y      = cache.y[index] = bounds.top;
			var w      = cache.w[index] = bounds.right - bounds.left;
			var h      = cache.h[index] = bounds.bottom - bounds.top;

			if (cache.isHiding){
				if ('height' in cache.props) h = 0;
				if ('width' in cache.props)  w = 0;
			}
			
			if (item.props){
				utils.each(item.props, function (values, key){
					var v = values[index];

					if (v === true && key === 'height'){
						v = h;
					}else if (v === true && key === 'width'){
						v = w;
					}else if (v === true){
						v = key in style ? style[key] : 0;
					}
					
					if (cache.props[key] === undefined){
						cache.props[key] = [];
					}

					cache.props[key][index] = v;
				});
			}

		
			if (isFrom){
				_clean(old, true);
			}else{
				var dx = cache.dx = cache.x[0] - cache.x[1];
				var dy = cache.dy = cache.y[0] - cache.y[1];
				var sw = cache.sw = cache.w[0] / cache.w[1];
				var sh = cache.sh = cache.w[0] && cache.w[1] ? (cache.h[0] / cache.h[1]) : (cache.h[1] ? 1 : 0);

				if (cache.isHiding || cache.isLeaving){
					item.translate && _style(el, {
						'left'   : dx,
						'top'    : dy,
					});
				}else if ((!cache.isShowing && !cache.isShowing) && (dx || dy)){
					cache.isMoving = true;

					var t = [];
					if (item.translate && (dx || dy)){
						t.push('translate('+dx+'px, '+dy+'px)');
					}
					if (item.scale && (sw !== 1 || sh !== 1)){
						t.push('scale('+sw+', '+sh+')');
					}
					
					if (el.style.transform){
						t.unshift(el.style.transform);
					}

					cache.transform = t.join(' ');
				}

				cache.transition = 'all ' + item.duration + 'ms ' + item.easing + (item.delay ? ' ' + item.delay + 'ms' : '');
			}

			utils.cache(el, '__FLIP__', cache);
			
			return cache;
		}

		function _style (el, style){
			utils.el.style(el, style, false);
			return el.style.cssText;
		}

		function _clean (element, cancel){
			if (!element) return;

			element.el.style = element.cssText || '';
			element.el.style.transition         = '';

			_style(element.el, element.styleClean);
			utils.el.removeClass(element.el, args.transitionClass);

			utils.cache(element.el, '__FLIP__', null);
			utils.apply(args.onClean, [element], args.context);

			if (cancel){
				utils.apply(args.onCancel, [element], args.context);
			}

			clearTimeout(element.timeout);

			countDone++;

			if (countDone === elements.length){
				_complete();
			}
		}

		function _complete (){
			if (isComplete) return;
			isComplete = true;

			//utils.each(elements, _clean);
			utils.apply(args.onComplete, [elements], args.context);
		}

		// (F)irst - save the positions ----------------------------------------
		items = utils.each(items, function (item, i){
			if (utils.is.str(item))		item = {'selector':item};
			else if (utils.is.el(item))	item = {'selector':[item]};

			// shortcut to "selector"
			if ('el' in item){
				item.selector = item.el;
			}

			// fetch the elements
			item.elements = utils.dom.getAll(item.selector);

			// item
			item = utils.args(item, {
				'selector'   : false,
				'elements'   : [],
				'classname'	 : args.classname,
				'delay'		 : args.delay,
				'duration'	 : duration,
				'easing'	 : args.easing,
				'ratio'		 : [0, 1],
				// item props and events
				'props'      : args.props,
				'translate'  : args.translate,
				'scale'      : args.scale,        // maybe
				'visibility' : args.visibility,
				'fill'       : args.fill,         // [forward, backward, false]
				'onBefore'	 : null, //args.onBefore,
				'onEach'	 : null, //args.onEach,
				'onAfter'	 : null, //args.onAfter,
				'onCalculate': null, //args.onCalculate,
			});

			var totalDuration= utils.string.toDuration(item.duration);
			var itemDelay    = totalDuration * item.ratio[0];
			var itemDuration = totalDuration * (item.ratio[1] - item.ratio[0]);

			itemDelay    = utils.number.decimals(itemDelay, 5);
			itemDuration = utils.number.decimals(itemDuration, 5);

			item.delay         = itemDelay;
			item.duration      = itemDuration;
			item.totalDuration = totalDuration;
			item.easing        = utils._easing(item.easing, true, 'linear');
			item.props         = _props(item.props);
	
			// @todo deal with ratio

			// cached elements that will transition
			item.cache = utils.each(item.elements, function (el, i){
				// find the css to set in FROM and TO
				var from = {};
				var to   = {};
				utils.each(item.props, function (values, key){
					if (values[0] !== true) from[key] = values[0];
					if (values[1] !== true) to[key] = values[1];
				});

				var element 	   = _cache(el, item);
				element.styleFrom  = from;
				element.styleTo    = to;
				element.visible[0] = utils.el.isVisible(el);

				el.style.transition         = 'none';
				el.style.transitionDuration = 0;

				elements.push(element);
				return element;
			});

			return item;
		});
		//console.log('first');

		// (L)ast - change the props -------------------------------------------
		utils.apply(args.onBefore, [elements, items], args.context);
		utils.each(items, function (item, i){
			var cacheElements = item.cache;

			utils.apply(item.onBefore, [item.elements, items], args.context);
			
			// @todo check if there's new elements with the selector ?
			// @todo deal with entering/leaving elements
			
			// cached elements
			utils.each(cacheElements, function (element){
				// toggle classname
				if (item.classname) utils.el.toggleClass(element.el, item.classname);

				// call onEach
				utils.apply(args.onEach, [element.el, element], args.context);
				utils.apply(item.onEach, [element.el, element], args.context);

				// reflow
				//element.cssText = element.el.style.cssText;

				// props
				//_style(element.el, element.styleTo);
			});

			utils.apply(item.onAfter, [item.elements, items], args.context);
		});
		utils.apply(args.onAfter, [elements, items], args.context);

		//console.log('last');

		// calculate movement --------------------------------------------------
		utils.each(elements, function (element){
			// cache the cssText (for the clean function), save it after all the onBefore, onEach, onAfter that could change the 
			element.cssText = element.el.style.cssText;

			// cache the data
			_style(element.el, element.styleTo);
			_cache(element.el, element.item, 1);

			utils.apply(args.onCalculate, [element], args.context);
			utils.apply(element.item.onCalculate, [element], args.context);

			// refresh the FROM and TO style
			var from  = {};
			var to    = {};
			var clean = {};

			utils.each(element.props, function (values, key){
				from[key] = values[0];
				to[key]   = values[1];

				// clean end value
				var v = element.item.props[key] && element.item.props[key][2]; 
				if (v !== undefined){
					if (v === true){
						clean[key] = values[1];
					}else if (v !== false){
						clean[key] = v;	
					}
				}else{
					v = '';
				}
			});


			if (!element.visible[0]){
				if ('padding' in from) 		from.padding = 0;
				if ('paddingTop' in from) 	from.paddingTop = 0;
				if ('paddingRight' in from) from.paddingRight = 0;
				if ('paddingBottom' in from)from.paddingBottom = 0;
				if ('paddingLeft' in from) 	from.paddingLeft = 0;
				if ('margin' in from)  		from.margin = 0;
				if ('marginTop' in from)  	from.marginTop = 0;
				if ('marginRight' in from)  from.marginRight = 0;
				if ('marginBottom' in from) from.marginBottom = 0;
				if ('marginLeft' in from)  	from.marginLeft = 0;
			}

			if (!element.visible[1]){
				if ('padding' in to) 		to.padding = 0;
				if ('paddingTop' in to) 	to.paddingTop = 0;
				if ('paddingRight' in to) 	to.paddingRight = 0;
				if ('paddingBottom' in to)	to.paddingBottom = 0;
				if ('paddingLeft' in to) 	to.paddingLeft = 0;
				if ('margin' in to)  		to.margin = 0;
				if ('marginTop' in to)  	to.marginTop = 0;
				if ('marginRight' in to)  	to.marginRight = 0;
				if ('marginBottom' in to) 	to.marginBottom = 0;
				if ('marginLeft' in to)  	to.marginLeft = 0;
			}

			element.styleFrom  = from;
			element.styleTo    = to;
			element.styleClean = clean;

		});
		//console.log('calculate');

		//return elements;

		// (I)nverse -----------------------------------------------------------
		utils.each(elements, function (element){
			// if (element.item.totalDuration){
				element.el.style.transition 	 = 'none';
				element.el.style.transformOrigin = 'top left';
				element.el.style.transform 		 = element.transform || '';
				_style(element.el, element.styleFrom);
			// }

			// start animation
			utils.el.addClass(element.el, args.transitionClass);
		});
		//console.log('inverse');


		// (P)lay --------------------------------------------------------------
		utils.apply(args.onPlay, [elements, items], args.context);

		utils.fn.requestFrame(function (){
			utils.each(elements, function (element){
				element.timeout 				  = setTimeout(function (){ _clean(element); }, element.item.totalDuration);
				element.el.style.transition 	  = element.transition;
				element.el.style.transform  	  = '';
				element.el.style.transformOrigin  = '';
				_style(element.el, element.styleTo);
			});
		}, true);

		return elements;
	};

	// actions -----------------------------------------------------------------
	this.cursor = function (id, cursor, args){
		if (cursor === undefined){
			cursor = id;
			id 	   = '*';
		}else if (args === undefined){
			args   = cursor;
			cursor = id;
			id     = '*';
		}
		
		var item = DOM.CURSORS[id] || {};
		if (item.cursor === cursor){
			return item;
		}
		
		cursor 		= cursor === true ? 'pointer' : cursor;
		
		args          = args || {};
		args.x        = 'x' in args ? args.x : null;
		args.y        = 'y' in args ? args.y : null;
		args.offset   = 'offset' in args ? args.offset : null;
		args.anchor   = 'anchor' in args ? args.anchor : null;
		args.parent   = 'parent' in args ? args.parent : document.documentElement;
		args.callback = args.callback || null;

		var src    = utils.toSrc(cursor, 'image');
		var offset = args.offset ? utils.array.to2Numbers(args.offset) : null;
		var anchor = args.anchor ? utils.array.to2Values(args.anchor) : null;
		
		if (anchor){
			anchor[0] = utils.is.nbr(anchor[0]) ? anchor[0] + 'px' : anchor[0];
			anchor[1] = utils.is.nbr(anchor[1]) ? anchor[1] + 'px' : anchor[1];
		}
				
		function _update (x, y){
			if (!item.element) return;

			if (x === null || y === null){
				item.element.style.display = 'none';
				return;
			}else{
				item.element.style.display = '';
			}

			var translate = [];

			translate.push('translate('+x+'px, '+y+'px)');

			if (offset){
				translate.push('translate('+offset[0]+'px, '+offset[1]+'px)');
			}
			if (anchor){
				translate.push('translate('+anchor[0]+', '+anchor[1]+')');
			}

			item.element.style.transform = translate.join(' ');

			utils.apply(args.callback, [{
				'node': item.element,
				'x'   : x,
				'y'   : y,
			}]);
		}

		function _move (e){
			_update(e.clientX, e.clientY);
		};

		function _leave (e){
			_update(null, null);
		}

		// clear the current cursor
		if (item.removeEvents){
			item.removeEvents();
		}

		if (item.element){
			utils.el.remove(item.element);
		}

		if (!cursor){
			cursor = null;
			document.body.style.cursor = '';
		}else if (!!~DOM.CURSOR_TYPES.indexOf(cursor)){
			document.body.style.cursor = cursor;
		}else{
			var inner = null;

			if (src){
				inner = '<img src="'+src+'" />';
			}else{
				inner = cursor;
			}

			item.element = utils.dom.create('div', {
				'parent'  : args.parent,
				'children': inner,
				'attrs'   : {'cursor':true},
				'style'   : {
					'position'	     : 'fixed',
					'top'			 : 0,
					'left'			 : 0,
					'z-index'	     : 99999999,
					'pointer-events' : 'none',
					'user-select'    : 'none',
				}
			});	

			
			document.body.style.cursor = 'none';

			item.removeEvents = utils.el.addEvent(document.body, {
				'mousemove' : _move,
				'mouseleave': _leave,
			});

			_update(args.x, args.y);
		}

		item.cursor = cursor;

		DOM.CURSORS[id] = item;

		return item;
	};

	this.copyToClipboard = function (text, callback){
		if (utils.is.input(text)){
			text = utils.dom.val(text);
		}else if (utils.is.node(text)){
			text = utils.string.trim(text.textContent);
		}

		callback = callback || null;

		if (!navigator.clipboard) {
			var clipboard = document.createElement('textarea');
			var success   = false;
			
			clipboard.value 		 = text;
			clipboard.style.top      = 0;
			clipboard.style.left     = 0;
			clipboard.style.position = 'fixed';
			
			document.body.appendChild(clipboard);
			clipboard.focus();
			clipboard.select();
			
			try {
				success = document.execCommand('copy');
			}catch (err){}

			document.body.removeChild(clipboard);

			utils.apply(callback, [success]);
		}else{
			navigator.clipboard.writeText(text).then(function() {
				utils.apply(callback, [true]);
			}, function (){
				utils.apply(callback, [false]);
			});
		}
	};

	// casting -----------------------------------------------------------------
	this.toPx = function (nbr, args){
		if (!nbr){
			return 0;
		}else if (typeof nbr === 'number'){
			return nbr;
		}

		if (utils.is.numeric(args)){
			args = {'size':parseFloat(args)};
		}

		args 		 = args || {};
		args.size 	 = 'size' in args ? args.size : 0;
		args.element = 'element' in args ? args.element : null;

		var element       = args.element ? utils.dom.get(args.element) : null;
		var screenSize    = utils.dom.screenSize();
		var elementWidth  = screenSize.clientWidth;
		var elementHeight = screenSize.clientHeight;
		var contentSize   = args.size;
		var emSize        = screenSize.remSize;

		if (element){
			var bounds 		= element.getBoundingClientRect();
			elementWidth 	= bounds.width;
			elementHeight	= bounds.height;
			emSize 			= parseInt(window.getComputedStyle(element).fontSize, 10);
		}

        // if the nbr is a CSS variable (eg.: --number);
		nbr = utils.el.var(element, nbr);

		nbr = nbr.toString().replace(RE.NUMBER_UNITS, function (m, number){
			var unit 	= number.replace(/[0-9\.\-]/g, '').toLowerCase();
            var number  = parseFloat(number);
    
			if (unit === 'vh'){
				number = number/100 * screenSize.viewportHeight;
			}else if (unit === 'vw'){
				number = number/100 * screenSize.viewportWidth;
			}else if (unit === 'ch'){
				number = number/100 * screenSize.clientHeight;
			}else if (unit === 'cw'){
				number = number/100 * screenSize.clientWidth;
			}else if (unit === 'h'){
				number = number/100 * elementHeight;
			}else if (unit === 'w'){
				number = number/100 * elementWidth;
			}else if (unit === '%'){
				number = number/100 * (contentSize || elementWidth);
			}else if (unit === 'rem'){
				number = number * screenSize.rem;
			}else if (unit === 'em'){
				number = number * emSize;
			}else if (unit !== 'px'){
				utils.warn('Unit {unit} isnt\'t supported', {'unit':unit});
			}

			return number;
		});

		nbr = utils.calculate(nbr);

        return nbr;
	};
	
	// layout ------------------------------------------------------------------
	this.masonry = function (el, args){
		el = utils.dom.get(el);

		args = utils.args(args, {
			'selector'	  : null,
			'spanAttr'	  : null,
			'columns'     : 2,
			'gutter'      : 0,
			'gutterBottom': null,
		});

		var children = utils.dom.getAll(args.selector || '> *', {'context':el});
		var bounds 	 = utils.el.bounds(el);
		
		// @todo if already "absolute,relative or fixed", let it be
		utils.el.style(el, {
			'position' : 'relative',
		});

		// prepare the items
		var items = utils.map(children, function (el, i){
			var colSpan = el.getAttribute(args.spanAttr) || 1;

			utils.el.style(el, {
				'position': 'absolute',
				'left'    : 0,
				'top'     : 0,
			});

			return {
				'el'     : el,
				'colSpan': colSpan,
			};			
		});
		
		// calculate the item position
		var masonry = utils.layout.masonry(bounds.width, items, {
			'columns'     : args.columns,
			'gutter'      : args.gutter,
			'gutterBottom': args.gutterBottom,
			'onItem'	  : function (item){
				utils.el.style(item.el, {
					'width': item.width
				});
				
				var iBounds = utils.el.bounds(item.el);

				item.height = iBounds.bbox.height;
			}
		});

		utils.each(masonry.items, function (item){
			utils.el.style(item.el, {
				'left': item.x,
				'top' : item.y,
			});
		});

		utils.el.style(el, {'height':masonry.height});
			
	};
});


Utils.add(function (utils, CONSTS){
    var DOM = this.DOM = {
		// constants -----------------------------------------------------------
		NAMESPACES : {
			'xlink:href' : 'http://www.w3.org/1999/xlink',
		},
		RE : {
		//	DELEGATE_EVENT 	: /([^:]+)\:(.+)/,
			CSS_SELECTOR 	: /(\#[a-z][\w-]+)|(\.[\-a-z][\w-]+)|(\[[^\]]+\])|(\{[^\]]+\})|(\=.+)|([a-z][\w-]+)/gi,
		},
		HEAD_STYLE 			 : null,
		ADDED_STYLES 		 : {},
		SVG 			 	 : null,
		SVG_DEFS 			 : null,
		SVG_ITEMS 		 	 : {},
		CURSOR 				 : {},
		
		SUPPORTS : {
			WEBP : (function (){
				var isSupported = null;

				return function (){
					if (isSupported !== null){
						return isSupported;
					}

					var c = document.createElement('canvas');
					if (!!(c.getContext && c.getContext('2d'))){
						isSupported = c.toDataURL('image/webp').indexOf('data:image/webp') == 0;
					}else{
						isSupported = false; // very old browser like IE 8, canvas not supported
					}

					return isSupported;
				}
			}())
		},
		// props ---------------------------------------------------------------
		
		// functions -----------------------------------------------------------

	};
	
	// events ----------------------------------------------------------------





	// actions -----------------------------------------------------------------

	this.el.stopMedias = function (element){
		element = utils.dom.get(element);

		var iframes = utils.dom.getAll('iframe', {'context':element, 'includeContext':true});
		var videos 	= utils.dom.getAll('video,audio', {'context':element, 'includeContext':true});
		// @todo audio
		var i, src;

		for (i in iframes){
			src = iframes[i].src;
			iframes[i].src = src;
		}
		for (i in videos){
			videos[i].pause();
		}
	};

	// style -------------------------------------------------------------------



	// other ---------------------------------------------------------------------
	this.el.offsetPosition = function (element, parent){
		var parent   = parent ? utils.dom.get(parent) : utils.el.offsetParent(element);
		var pBounds  = utils.el.bounds(parent).viewport;
		var bounds 	 = utils.el.bounds(element).viewport;

		return {
			'offsetX'		: bounds.x - pBounds.x,
			'offsetY' 		: bounds.y - pBounds.y,
			'element' 		: element,
			'parent' 		: parent,
			'elementBounds' : bounds,
			'parentBounds' 	: pBounds,
		};
	};

	this.el.getPointInPage = function (element, pageX, pageY){
		var bounds = utils.el.bounds(element);
		var x      = pageX - bounds.paddingBox.left + bounds.scrollLeft;
		var y      = pageY - bounds.paddingBox.top + bounds.scrollTop;

		return {
			'x' : x,
			'y' : y,
		}
	};

	this.el.reposition = function (element, args){
		args 			     = args || {};
		args.target 	     = 'target' in args ? args.target : null;
		args.contained 		 = 'contained' in args ? args.contained : null;

		args.position 	     = args.position || null;
		args.padding 	     = utils.array.to4Numbers(args.padding || 0);	// use negative padding for margin
		args.screenPadding 	 = utils.array.to4Numbers(args.screenPadding || 0);	// use negative padding for margin
		args.offset 	     = utils.array.to2Numbers(args.offset || 0);
		args.anchor 	     = 'anchor' in args ? args.anchor : 'top left';
		args.origin 	     = 'origin' in args ? args.origin : 'top left';
		args.resize 	     = 'resize' in args ? args.resize : false;
		args.fixed 		     = 'fixed' in args ? args.fixed : false;
		args.rotate 	     = 'rotate' in args ? args.rotate : false;
		args.reverseOverflow = 'reverseOverflow' in args ? args.reverseOverflow : false;	// reverse position to the alternative postion if overflowing
		args.cursor 	     = args.cursor || null;

		// @todo deal with padding overflow

		var target;
		var screenWidth = document.documentElement.clientWidth;
		var screenHeight= document.documentElement.clientHeight;

		// element -------------------------------------------------------------
		utils.el.style(element, {
			'position'		: args.fixed ? 'fixed' : 'absolute',
			'width' 		: '',
			'translateX'	: '',
			'translateY'	: '',
			'left'			: '',
			'right'			: '',
			'top'			: '',
			'bottom'		: '',
		});

		// @info use the viewport, the CSS attribute doenst give the real raw data (with decimals)
		var eBounds = utils.el.bounds(element).viewport;

		// @todo deal with element that has a vertical scrollbar
		
		// target --------------------------------------------------------------
		if (utils.isPlainObject(args.target)){
			target = utils.math.toBounds(args.target);
		}else if (target = utils.dom.get(args.target)){
			target = utils.el.bounds(target);
			target = args.fixed ? target.viewport : target.borderBox;
		}else{
			target = utils.math.toBounds({
				'x'		: 0,
				'y'		: 0,
				'width' : screenWidth,
				'height': screenHeight,
			});
		}

		var tBounds = utils.math.toBounds(target, {'padding':args.padding});

		// add a "positioning" feature in the target
		if (args.position){
			if (args.position === 'inside'){
				tBounds.width -= eBounds.width;
				tBounds.height-= eBounds.height;
			}else if (args.position === 'outside'){
				tBounds.x 	  -= eBounds.width;
				tBounds.y 	  -= eBounds.height;
				tBounds.width += eBounds.width;
				tBounds.height+= eBounds.height;
			}
		}
		
		// container -----------------------------------------------------------
		var container, cBounds;
		
		// if contained = true, then it's the screen
		if (args.contained === true){
			cBounds = {
				'width' : screenWidth,
				'height': screenHeight,
			};
		}else if (args.contained && (container = utils.dom.get(args.contained))){
			cBounds = utils.el.bounds(cBounds).paddingBox;
		}
		cBounds = cBounds ? utils.math.toBounds(cBounds, {'padding':args.screenPadding}) : null;

		// element -------------------------------------------------------------

		// parent offset fix
		//var parent	  = utils.el.offsetParent(element); //.offsetParent;
		var parent	  = element.offsetParent;
		var pBounds   = utils.el.bounds(parent).paddingBox;
		var parentX   = parent === document.body ? 0 : pBounds.x;
		var parentY	  = parent === document.body ? 0 : pBounds.y;

		var style 	  = {};
		var width 	  = eBounds.width;
		var height	  = eBounds.height;
		var maxWidth  = tBounds.width;
		var maxHeight = tBounds.height;
		var anchor    = utils.math.toPointInRect(tBounds, args.anchor);
		var origin    = utils.math.toPointInRect({'width':width, 'height':height}, args.origin);

		var x1 		  = anchor.x - origin.x + args.offset[0];
		var y1 		  = anchor.y - origin.y + args.offset[1];
		var x2 		  = x1 + maxWidth;
		var y2 		  = y1 + maxHeight;

		// with a cursor, the item will move with the cursor, contained in the target
		var xy = args.cursor;
		if (xy && ('x' in xy) && ('y' in xy)){
			if (xy.x > x2) 		x1 = x2;
			else if (xy.x > x1) x1 = xy.x;

			if (xy.y > y2) 		y1 = y2;
			else if (xy.y > y1)	y1 = xy.y;
		}

		// rotate element according to center of target
		if (args.rotate){
			var center 	 = [x1 + width/2, y1 + height/2]
			var angle 	 = utils.math.angle(tBounds.center, center);
			style.rotate = angle + (typeof args.rotate === 'number' ? args.rotate : 0);
		}

		// resize
		if (args.resize){
			if (cBounds){
				maxWidth 	= cBounds.width < maxWidth ? cBounds.width : maxWidth;
				maxHeight 	= cBounds.height < maxHeight ? cBounds.height : maxHeight;
			}

			width  = maxWidth < width ? maxWidth : width;
			height = maxHeight < height ? maxHeight : height;
		}

		// contained
		if (cBounds && args.fixed){
			var x2 	= x1 + width;
			var y2 	= y1 + height;

			// reverse position
			if (args.reverseOverflow){
				if (x1 < cBounds.left)			x1 -= (x1 - tBounds.right + args.offset[0]);
				else if (x2 > cBounds.right)	x1 -= (x2 - tBounds.left + args.offset[0]);

				if (y1 < cBounds.top)			y1 -= (y1 - tBounds.bottom + args.offset[1]);
				else if (y2 > cBounds.bottom)	y1 -= (y2 - tBounds.top + args.offset[1]);
			}else{
				if (x1 < cBounds.left)			x1 = cBounds.left;
				else if (x2 > cBounds.right)	x1 += cBounds.right - x2;

				if (y1 < cBounds.top)			y1 = cBounds.top;
				else if (y2 > cBounds.bottom)	y1 += cBounds.bottom - y2;
			}
		}

		// resize
		if (args.resize){
			width  = maxWidth < width ? maxWidth : width;
			height = maxHeight < height ? maxHeight : height;
		}

		style.left  = x1 - parentX;
		style.top   = y1 - parentY;

		if (args.resize){
			style.width = width;
		}

		utils.el.style(element, style);
		utils.el.attrs(element, {'xy':'['+x1+','+y1+']'});

		/*
		'maxWidth' : maxWidth,
		'maxHeight': maxHeight,
		*/

		return utils.math.toBounds({
			'x'        : x1,
			'y'        : y1,
			'width'    : width,
			'height'   : height,
		});
	};

	this.el.moveTo = function (element, target, args){
		args 		 	= args || {};
		args.origin  	= 'origin' in args ? args.origin : 'right middle';
		args.anchor  	= 'anchor' in args ? args.anchor : 'left middle';
		args.offset  	= 'offset' in args ? args.offset : 0;

		args.duration 	= utils.string.toDuration(args.duration || 0);
		args.easing		= 'easing' in args ? args.easing : 'linear';
		args.skipInit 	= 'skipInit' in args ? args.skipInit : true;
		args.skipSame 	= 'skipSame' in args ? args.skipSame : true;
		args.onComplete = 'onComplete' in args ? args.onComplete : null;

		var beforeBounds = utils.el.bounds(element);

		var afterBounds  = utils.el.reposition(element, {
			'target' : target,
			'origin' : args.origin,
			'anchor' : args.anchor,
		});

		// cache the element, to check if the animation is necessary
		var cacheId 	= 'moveToTarget';
		var oldTarget 	= utils.el.cache(element, cacheId);
		if ((!oldTarget && args.skipInit) || (oldTarget === target && args.skipSame)){
			args.duration = 0;
		}
		utils.el.cache(element, cacheId, target);

		var diffX = beforeBounds.x - afterBounds.x;
		var diffY = beforeBounds.y - afterBounds.y;
		var style = {
			'translateX' : [diffX, 0],
			'translateY' : [diffY, 0],
		};

		utils.el.transition(element, style, {
			'duration' 	: args.duration,
			'easing'	: args.easing,
			'onComplete': function (){
				utils.el.style(element, {'translateX':'', 'translateY':''});
				utils.call(args.onComplete);
			},
		});
	};

	this.el.swapElement = function (from, to, args){
		to 				= utils.dom.get(to);

		args 			= args || {};
		args.duration 	= utils.string.toDuration('duration' in args ? args.duration : 1000);
		args.animation 	= 'animation' in args ? args.animation : 'cross-fade';
		args.remove 	= 'remove' in args ? args.remove : false;
		args.onComplete	= 'onComplete' in args ? args.onComplete : utils.fn.empty;
		args.easing 	= 'easing' in args ? args.easing : null;
		args.context	= 'context' in args ? args.context : null;

		var fOffset 	= utils.el.offsetPosition(from);
		from.style.display = '';
		to.style.display   = '';
		var tBounds 	= utils.dom.bounds(to);

		var fProps       = {};
		var tProps       = {};
		var fDuration    = args.duration;
		var tDuration    = args.duration;
		var fPause 	 	 = 0;
		var tPause 		 = 0;

		if (args.animation === 'fade' || args.animation === 'cross-fade'){
			fProps = {
				'opacity'  :[1,0],
				'!position':'absolute',
				'!top'     : fOffset.offsetY,
				'!left'	   : fOffset.offsetX,
				'!width'   : fOffset.elementBounds.width,
			};

			tProps = {
				'opacity'	: [0, 1],
				'height'	: [fOffset.element.height, tBounds.height]
			};

			if (args.animation === 'fade'){
				fDuration 	/= 2;
				tDuration 	/= 2;
				tPause 		= fDuration;
			}
		}else if (args.animation === 'scale'){
			fProps = {
				'scale' 	: [1, 0.5],
				'opacity'	: [1,0],
				'!position'	: 'absolute',
				'!top'      : fOffset.offsetY,
				'!left'	   	: fOffset.offsetX,
				'!width'	: fOffset.elementBounds.width,
			};
			tProps = {
				'scale' 	: [1.5, 1],
				'opacity'	: [0,1],
			};
		}else{
			_done();
			return;
		}

		utils.dom.transition(from, fProps, {
			'easing'	: args.easing,
			'duration'	: fDuration,
		});

		utils.dom.transition(to, tProps, {
			'easing'	: args.easing,
			'duration'	: tDuration,
			'pause'		: tPause,
			'clean' 	: true,
			'onComplete': _done
		});


		function _done (){
			if (args.remove){
				utils.dom.remove(from);
			}else{
				from.style.display = 'none';
			}

			args.onComplete.apply(args.context, [from, to]);
		}
	};

	this.el.zoom = function (element, args){
		if (!args){
			 return;
		}

		args 	   = args || {};
		args.type  = 'type' in args ? args.type : null;
		
		var width  = args.width || 0;
		var height = args.height || 0;		

		// check if it's a background image...

		if (!args.width || !args.height){
			if (utils.el.is(element, 'video')){
				width  = element.videoWidth;
				height = element.videoHeight;
			}else if (utils.el.is(element, 'iframe')){
				// @todo
			}else if (utils.el.is(element, 'img')){
				width  = element.naturalWidth;
				height = element.naturalHeight;
			}else{
				// @todo ... what other types
			}

			// fallback to the width/height attributes
			if (width === 0 && height === 0){
				width  = parseFloat(element.getAttribute('width')) || 0;
				height = parseFloat(element.getAttribute('height')) || 0;
			}
		}

		var focus = utils.layout.focus(width, height, args);
		
		element.style.transform 		= focus.transform;
		element.style.transformOrigin 	= focus.transformOrigin;
		element.style.width				= focus.elementWidth + 'px';
		element.style.height 			= focus.elementHeight + 'px';
	
		return focus;
	};

	this.el.splitText = function (element, args){
		element.innerHTML = utils.string.splitText(element.innerHTML, args);
	};

	this.el.hoverParts = function (element, partSelector, args){
		args 			= args || {};
		args.classname 	= 'classname' in args ? args.classname : 'is-hovered';

		utils.el.addEvent(element, 'mouseenter', {'delegate':partSelector, 'callback':function (){
			utils.el.addClass(element, args.classname);
		}});

		utils.el.addEvent(element, 'mouseleave', {'delegate':partSelector, 'callback':function (){
			utils.el.removeClass(element, args.classname);
		}});
	};


	// dom ---------------------------------------------------------------------
	// add all private function and do a check first that it's an HtmlElement

	
	// used by inline-editor, but need to be removed
	this.dom.parse = function (selector, args){
		var element = utils.dom.get(selector);

		args = args || {};
		if (args.html === undefined) 				args.html = '';
		if (args.create === undefined) 				args.create = false;
		if (args.extract === undefined) 			args.extract = null;
		if (args.appendTo === undefined)			args.appendTo = null;
		if (args.id === undefined && args.create) 	args.id = 'element_'+utils.string.generateId();

		// create the element if it does not exists
		if (!element && args.create){
			var tagName = typeof args.create === 'string' ? args.create : 'div';
			document.write('<'+tagName+' id="'+args.id+'"></'+tagName+'>');
			element = document.getElementById(args.id);
		}

		// save the ID
		if (args.id){
			element.setAttribute('id', args.id);
		}

		// setup the HTML if it's not already there
		if (args.html){
			element.innerHTML = args.html;
		}

		// append to root
		if (args.appendTo){
			utils.el(element, args.appendTo);
		}

		if (args.extract){
			var elements = {'self':element};
			var children = element.querySelectorAll('['+args.extract+']');

			for (var i=0, l=children.length; i<l; ++i){
				var child = children[i];
				var name  = child.getAttribute(args.extract);
				elements[name] = child;
			}

			return elements;
		}else{
			return element;
		}
	};


});
var STATIC  = window.STATIC || {};
var CLASS   = window.CLASS || {};
var CLASSES = window.CLASSES || {};
var MIXINS  = window.MIXINS || {};

if (!STATIC['*']){
	STATIC['*'] = {'logs' : 'error,warn,log'};
}

var Class = Core.Class = (function (){
	var SKIP_CALLBACKS = '$type,$extends,$static,$mixins,$get,$set'.split(',');
		
	var isInitializing = false;
	var classes        = {};
	var classStates    = {};   
	var utils          = Utils;

	var BaseStatic = {
		'logs'    : 'log,warn,error,info',
		'log'     : function (msg, data, details){ return _logClass(this, 'log', msg, data, details); },
		'warn'    : function (msg, data, details){ return _logClass(this, 'warn', msg, data, details); },
		'error'   : function (msg, data, details){ return _logClass(this, 'error', msg, data, details); },
		'info'    : function (msg, data, details){ return _logClass(this, 'info', msg, data, details); },
		'msg'     : function (title, color, msg, data, details){ return _logClass(this, 'log', msg, data, details, title, color); },
		'getType' : function (){ return this.prototype.__type__; },
		'getClass': function (){ return utils.string.toDashCase(this.prototype.__type__); },
		'each'	  : function (list, args, callback){ return utils.each.context(this, list, args, callback); },
	};

	var Base = function (){};

	Base.prototype = {
		'debug'			: false,
		'logs' 			: 'log,warn,error,info',
		'log' 			: function (msg, data, details){ return _log(this, 'log', msg, data, details); },
		'warn' 			: function (msg, data, details){ return _log(this, 'warn', msg, data, details); },
		'error' 		: function (msg, data, details){ return _log(this, 'error', msg, data, details); },
		'info' 			: function (msg, data, details){ return _log(this, 'info', msg, data, details); },
		'msg'			: function (title, color, msg, data, details){ return _log(this, 'warn', msg, data, details, title, color); },
		'getId'			: function (){ return this.$data._id; },
		'setId'			: function (value){ this.$data._id = value; return this; },
		'getType'		: function (){ return this.__type__; },
		'getTypeClass'	: function (){ return this.__type_class__; },
		'getTypes'		: function (){ return this.__types__; },
		'isType'		: function (value){ return utils.array.intersect(this.__types__, value).length > 0; },
		'getClasses' 	: function (){ return this.$data._classes; },
		'addClass'		: function (value){ utils.array.insert(this.$data._classes, value); return this; },
		'removeClass'	: function (value){ utils.array.remove(this.$data._classes, value); return this; },
		'isClass'		: function (value){ return utils.array.intersect(this.$data._classes, value).length > 0; },
		'isReady' 		: function (){ return this.when('ready'); },
		'match' : function (search){
			// @todo do a match function, check type and classes
			return true; 
		},
		'apply' : function (callback, params, returnResponse){
			returnResponse = returnResponse === undefined ? true : returnResponse;
			var response = utils.apply(callback, params, this);
			return returnResponse ? response : this;
		},
		'when' : function (item, name, callback){
			if (utils.is.str(item)){
				callback = name;
				name     = item;
				item     = this;
			}

			if (utils.is.fn(callback) && item !== this){
				callback = callback.bind(this);
			}

			var states = item.$data._states = (item.$data._states || {});
			var value  = utils.fn.when(name, callback, states, this);

			return callback === undefined ? value : this;
		},
		'is' : function (){
			this.warn('Please use "when" instead of "is"');
			return this.when.apply(this, arguments);
		},
		'_get' : function (key, fallback, nvl){
			var value = null;

			if (key !== undefined && utils.is.valid(this.$data[key])){
				value = this.$data[key];
			}else if (key === true){
				var data = {};
				for (var i in this.$data){
					if (i[0] === '_') continue; // skip keys with "_" prefix
					data[i] = this.$data[i];
				}
				value = data;
			}else if (key !== undefined){
				value = fallback;
			}else{
				value = this.$data;
			}

			if (nvl !== undefined && value === null){
				value = nvl;
			}

			return value;
		},
		'_set' : function (key, value, returnValue){
			if (typeof key === 'object'){
				if (utils.is.bool(value)){
					returnValue = value;
					value       = null;
				}

				var defaults = typeof value === 'object' ? value : {};
				utils.extend(this.$data, defaults, key);

				value = this.$data;
			}else{
				this.$data[key] = value;
			}
			return returnValue ? value : this;
		},
		'each' :function (list, args, callback){
			return utils.each.context(this, list, args, callback);
		},
		'map' : function (items, callback){
			return this.each(items, {'type':'array', 'filter':true}, callback);	
		},
		'wait' : function (time, callback, args, returnTimeout){
			if (utils.is.bool(args)){
				returnTimeout = args;
				args          = null;
			}

			if (utils.is.fn(time)){
				args     = callback;
				callback = time;
				time     = 0;
			}
			
			var timeout = utils.fn.wait(time, this, callback, args);
			return returnTimeout ? timeout : this;
		},
		'proxy' : function (props, args){
			if (utils.is.obj(props)){
				_merge2([props], this, this.prototype, args);
			}
			return this;
		},
		'toString' : function (){ 
			return '['+(this.__singleton__?'singleton':'instance')+' '+this.__type__+']'; 
		},
	};

	// Little shortcut in case get/set are overwritten
	Base.prototype.get = Base.prototype._get;
	Base.prototype.set = Base.prototype._set;
	
	function _add (name, value, props, proto, args){
		args        = args || {};
		args.merge  = args.merge || [];
		args.concat = args.concat || [];
		args.skip 	= args.skip || [];
		args.super  = 'super' in args ? args.super : true;
	
		// if proto isnt' defined
		proto = proto || props;

		if (~args.skip.indexOf(name)){
			return;
		}

		if (args.super && utils.is.fn(value)){
			proto[name] = utils.fn.super(value, proto[name]) || value;

			// remove from props the function (if it existed as none-function)
			if (proto !== props){
				delete(props[name]);
			}
		}else if (~args.merge.indexOf(name) && utils.is.obj(value, true)){
			props[name] = utils.extend(true, props[name], value);
		}else if (~args.concat.indexOf(name) && props[name]){
			if (utils.is.str(value)){
				props[name] = (props[name] || '') + ' ' + value;
			}else if (utils.is.arr(value)){
				props[name] = (props[name] || []).concat(value);
			}else if (utils.is.obj(value, true)){
				for (var i in value){
					if (i in props[name]){
						props[name][i] += ' ' + value[i];
					}else{
						props[name][i] = value[i];
					}
				}
			}else{
				props[name] = value;
			}
		}else{
			props[name] = value;
		}
	}

	function _merge2 (list, props, proto, args){
		if (!utils.is.arr(list)){
			list = [list];
		}

		for (var i in list){
			var item = list[i];

			if (!utils.is.obj(item)){
				continue;
			}

			for (var ii in item){
				_add(ii, item[ii], props, proto, args);
			}
		}
	}

	function _merge (obj, args, sources){
		if (sources === undefined){
			sources = args;
			args    = {};
		}

		args = args || {};
		if (args.skipDefinedFunctions === undefined)	args.skipDefinedFunctions = false;
		if (args.createSuperFunctions === undefined)	args.createSuperFunctions = false;
		if (args.mergeProps === undefined)				args.mergeProps = false;
		if (args.debug === undefined)					args.debug = false;

		for (var i in sources){
			if ((typeof sources[i] !== 'object' && typeof sources[i] !== 'function') || !sources[i]) continue;
			
			for (var ii in sources[i]){
				var oldProp      = obj[ii];
				var prop         = sources[i][ii];
				var areFunctions = typeof prop === 'function' && typeof oldProp === 'function';

				if (areFunctions && (args.skipDefinedFunctions || prop === oldProp)){
					continue;
				}else if (areFunctions && args.createSuperFunctions){
					obj[ii] = utils.fn.super(prop, oldProp);
				}else if (typeof prop === 'function'){
					obj[ii] = prop;
				}else if (oldProp !== undefined && args.mergeProps && args.mergeProps.indexOf(ii)){
					utils.extend(true, oldProp, prop);
				}else{
					obj[ii] = prop;
				}
			}
		}
	}

	function _logClass (obj, type, msg, data, details, title, color){
		if (!~obj.logs.indexOf(type)) return;

		msg = msg === null ? '' : msg.toString();

		var name 	= '%c[Class:'+(title || obj.type)+']%c';
		var color  	= color || 'green';
		var colors 	= ['font-weight:bold; color:'+color+';', ''];
		var log 	= utils[type];
		var once   = false;

		if (data === true){
			data = {};
			once = true;			
		}

		log(name + ' ' + msg, data, {'colors':colors, 'once':once});

		if (utils.is(details)){
			console.log('  ', details);
		}

		return null;
	}

	function _log (obj, type, msg, data, details, title, color){
		if (!~obj.$static.logs.indexOf(type)) return;

		if (utils.is.obj(msg)){
			details = msg;
			msg     = '';
		}

		msg = msg === null ? '' : msg.toString();

		var id     = this.__singleton__ ? obj.getId() : obj.getType()+':'+obj.getId();
		var color  = color || 'blue';
		var name   = '%c['+(title || id)+']%c';
		var colors = ['font-weight:bold; color:'+color+';', ''];
		var log    = utils[type];
		var once   = false;

		if (data === true){
			data = {};
			once = true;			
		}

		log(name + ' ' + msg, data, {'colors':colors, 'once':once});

		if (utils.is(details)){
			console.log('  ', details);
		}

		return null;
	}

	function _isInit (v){
		if (typeof(v) === 'boolean'){
			isInitializing = v;
		}
		return isInitializing;
	}

	function Class (args, props){
		var definition = Class.decode(args, props);
		var type       = definition.type;
		var hasBase    = !!definition.extend;
		var extend     = definition.extend || Base;
		var setters    = definition.setters;
		var getters    = definition.getters;
		var static     = definition.static;
		var mixins     = definition.mixins;
		var uses       = definition.uses;
		var props      = definition.props;
		
		var types 		= []; 	
		var defaults 	= {};	// default props
		var inits 		= []; 	// mixin inits
		var destroys 	= [];  	// class destroy + mixin destroy
		var aliases 	= []; 	// mixin aliases
		var merge 		= [];
		var concat 		= [];
		var prototype 	= null;

		// @todo import extend/mixins/imports

		// extends -------------------------------------------------------------
		if (typeof extend === 'string'){
			if (extend in Class)		extend = Class[extend];
			else if (extend in Core)	extend = Core[extend];
			else if (extend in window) 	extend = window[extend];
			else 						utils.warn('Class "{{ type }}" is trying to extend the undefined "{{ extend }}" class', {'type':type, 'extend':extend});
		}

		// make sure extend is a function
		if (typeof extend !== 'function'){
			function Extend (){};
			Extend.prototype = extend || {};
			extend = Extend;
		}

		var parent  = extend.prototype || {};
		var klass 	= new Function('return function '+type+' (){ return this.__init__.apply(this, arguments); };')();
		
		_isInit(true);
		prototype = new extend();
		_isInit(false);

		// special $define function to alter code
		if (extend.$define || static.$define){
			utils.apply(extend.$define || static.$define, [type, {
				'extend'   : extend.name,
				'prototype': prototype,
				'props'    : props,
			}], klass);
		}

		// get the previous inits, aliases, merge, concat
		types	= (parent.__types__ || ['Class']).slice();
		inits   = (prototype.__inits__ || []).slice();
		destroys= (prototype.__destroys__ || []).slice();
		aliases = (prototype.__aliases__ || []).slice();
		merge   = (prototype.__merge__ || ['$data']).slice(); // $data always needs to be merged
		concat  = (prototype.__concat__ || []).slice();
		
		if (!~types.indexOf(type)){
			types.push(type);
		}
		if (definition.merge.length){
			merge = merge.concat(definition.merge);
		}
		if (definition.concat.length){
			concat = concat.concat(definition.concat);
		}

		// mixins --------------------------------------------------------------
		mixins = utils.toArray(mixins);
		
		// make sure the MIXINS are in lowercase
		for (var i in MIXINS){
			var ii = i.toLowerCase();
			MIXINS[ii] = MIXINS[i];
		}

		// mixins can have an alias prefix, so the props/functions will be under that prefix
		for (var i in mixins){
			var pair  = mixins[i].split(':');
			var mixin = pair.length > 1 ? pair[1] : pair[0];
			var alias = pair.length > 1 ? pair[0] : null;

			if (typeof mixin === 'string'){
				if (mixin in MIXINS)		mixin = MIXINS[mixin];
				else if (mixin in Core)		mixin = Core[mixin];
				else 						utils.warn('Class "{type}" is trying to use the undefined "{mixin}" mixin', {'type':type, 'mixin':mixin});
			}

			// parse the mixin
			if (typeof mixin === 'function'){
				// mixin.prototype.$get = {};
				// mixin.prototype.$set = {};
				mixin = new mixin(utils, Class);
			}
			
			if (typeof mixin !== 'object'){
				continue;
			}

			// modifiers
			if (mixin.$merge){
				var m = utils.toArray(mixin.$merge);
				merge = merge.concat(m);
			}
			if (mixin.$concat){
				var c = utils.toArray(mixin.$concat);
				concat = concat.concat(c);
			}
			if (mixin.$alias && !alias){
				alias = mixin.$alias;
			}

			if (alias){
				aliases.push(alias);
				defaults[alias] = {};
			}

			delete(mixin.$merge);
			delete(mixin.$concat);
			delete(mixin.$alias);
			delete(mixin.$init);

			for (var ii in mixin){
				var p = mixin[ii];

				if (alias){
					defaults[alias][ii] = p;
				}else if (ii === 'init' && utils.is.fn(p)){
					inits.push(p);
				}else if (ii === 'destroy' && utils.is.fn(p)){
					destroys.push(p);
				}else{
					_add(ii, p, defaults, prototype, {'merge':merge, 'concat':concat});
				}
			}
		}

		// parent/prototype ----------------------------------------------------
		// in case another type of extended function, make sure it has the base functions too (eg.: extend Array)
		if (!(prototype instanceof Base)){
			utils.extend(prototype, Base.prototype);
			hasBase = false;
		}

		// make copies of the prototype objects, so we have fresh ones everytimes
		for (var i in prototype){
			var p = prototype[i];
			if (i.indexOf('__') === 0) continue;

			if (utils.is.obj(p, true) || utils.is.arr(p, true)){
				defaults[i] = utils.copy(p);
			}
		}

		_merge2([
			!hasBase ? CLASSES['*'] : null,
			props,
			CLASSES[type],
		], defaults, prototype, {
			'merge' : merge,
			'concat': concat,
			'skip'  : SKIP_CALLBACKS,
		});

		// make sure data exists
		defaults.$data = defaults.$data || {};

		// getter/setter ---------------------------------------------------
		for (var i in setters){
			var get = getters[i] || utils.fn.empty;
			var set = setters[i];
			utils.object.prop(prototype, i, get, set);
		}
		
		for (var i in getters){
			// if the this already exists in setters, it's been already set
			if (setters[i] !== undefined) continue;
			var get = getters[i];
			var set = utils.fn.empty;
			utils.object.prop(prototype, i, get, set);
		}

		// static --------------------------------------------------------------
		klass.type  	= type;
		klass.count 	= 0;
		klass.addMethod	= function (name, callback){ prototype[name] = callback; };
		klass.toString  = function (){ return '[class ' + type + ']'; }

		_merge(klass, {'skipDefinedFunctions':true}, [
			BaseStatic,			// base
			STATIC['*'],		// general
			prototype.$static,	// static parent already has been set with STATIC[*]
			static,				// current class static
			STATIC[type],		// specific class static
		]);

		// props ---------------------------------------------------------------
		prototype.$static       = klass;
		prototype.__type__      = type;
		prototype.__type_class__= utils.string.toDashCase(type);
		prototype.__types__     = types;
		prototype.__inits__     = inits;
		prototype.__destroys__ 	= destroys;
		prototype.__aliases__ 	= aliases;
		prototype.__merge__ 	= merge;
		prototype.__concat__ 	= concat;
		prototype.__defaults__  = defaults;
		prototype.__singleton__ = definition.singleton;

		prototype.__init__ = function (){
			// default props
			utils.extend(true, this, defaults);
			
			// instance init
			if (!_isInit()){
				// uses --------------------------------------------------------
				utils.each(uses, function (name){
					if (Class[name] || Core[name] || window[name]) return;
					utils.error('Class "{type}" is trying to use the undefined "{name}" function', {'type':type, 'name':name});
				});

				// props -------------------------------------------------------
				var props = utils.toArray(arguments);
				var i, l;
				
				this.$self 			= this;  // for any mixin function added, the self needs to be added
				this.$data._id      = definition.singleton ? type : type + '_' + klass.count;
				this.$data._classes = [];
				
				// create the group destroy
				var destroy = this.destroy || null;
				this.destroy = function (){
					utils.apply(destroy, null, this);

					// all other destroy
					for (var i=0, l=destroys.length; i<l; ++i){
						utils.apply(destroys[i], null, this);
					}

					// alias mixins
					for (var i=0, l=aliases.length; i<l; ++i){
						var alias = this[aliases[i]];
						utils.apply(alias.destroy, null, alias);
					}
					
					this.info('Mixins destroyed');
				};

				// ready 
				var _ready = (function (p){
					// pre inits
					utils.apply(this.$static.preClassInit, [p], this);
					utils.apply(this.preInit, [p], this);

					// general at root mixin inits
					for (i=0, l=inits.length; i<l; ++i){
						props[0] = utils.apply(inits[i], props, this, props[0]);
					}
					
					// mixin aliases
					for (i=0, l=aliases.length; i<l; ++i){
						var alias = this[aliases[i]];

						// add the self to the alias
						alias.$self = this;

						// check for alias inits
						props[0] = utils.apply(alias.init, props, alias, props[0]);
					}

					// static init (only on the first instance)
					if (typeof this.$static.init === 'function' && klass.count === 0){
						utils.apply(this.$static.init, [this].concat(p), this.$static);
					}
					klass.count++;

					// add the $ready function if it was set
					if (this.$ready){
						this.when('ready', this.$ready);
					}

					return p;
				}).bind(this);

				if (this.init){
					var init = (function (){
						props = _ready(props);

						var response = null;

						// special _init() function to wrap the main init() function. good for extended classes when the main init() needs to do actions before and after the init() 
						if (this._init){
							response = this._init.apply(this, [this.init].concat(props));
						}else{
							response = this.init.apply(this, props);
						}

						this.when('ready', true);

						// post inits
						utils.apply(this.postInit, [props], this);
						utils.apply(this.$static.postClassInit, [props], this);

						return response === undefined ? this : response;
					}).bind(this);

					if (typeof definition.wait === 'function'){
						utils.apply(definition.wait, [init, props, definition], this);
					}else if (typeof this.preload === 'function'){
						utils.apply(this.preload, [init, props, definition], this);
					}else{
						return init();
					}
				}else{
					props = _ready(p);
					this.when('ready', true);

					// post inits
					utils.apply(this.postInit, [props], this);
					utils.apply(this.$static.postClassInit, [props], this);
				}
			}
		};

		// Create the class ------------------------------------------------
		klass.prototype 			= prototype;
		klass.prototype.constructor = klass;

		// @todo warn that a type is over-written

		Class[type] = classes[type] = klass;
		Class.ready(type, true);

		// function to class when the Class is created
		if (typeof prototype.$classReady === 'function'){
			prototype.$classReady.apply(klass, [klass]);
		}

		return definition.singleton ? new klass() : klass;
	};

	Class.decode = function (args, props){
		if (typeof args === 'function'){
			props = args;
			args  = {};
		}
		if (arguments.length === 1 && !utils.is.str(args)){
			props = args;
			args  = {};
		}

		// args ----------------------------------------------------------------
		if (args === true){
			args = {'singleton':true};
		}else if (typeof args === 'string'){
			args = {'type':args};
		}

		args 			= args || {};
		args.type 		= 'type' in args ? args.type : null;
		args.extend 	= 'extend' in args ? args.extend : null;
		args.singleton 	= 'singleton' in args ? args.singleton : false;
		args.wait 		= 'wait' in args ? args.wait : false;
		args.merge 		= utils.toArray('merge' in args ? args.merge : ''); // merge properties (instead of overwrites)
		args.concat 	= utils.toArray('concat' in args ? args.concat : ''); // concat properties (instead of overwrites)

		if (args.type && args.type[0] === '#'){
			args.singleton = true;
			args.type      = args.type.slice(1);
		}

		// the passed definition is a function with a name
		if (!args.type && typeof props === 'function'){
			args.type = props.name;
		}

		// wait for the DOM to be ready before doing the init
		if (~args.type.indexOf('!ready')){
			args.type = args.type.replace('!ready', '');
			args.wait = true;
		}

		if (args.type && ~args.type.indexOf(':')){
			var pair 	= args.type.split(':');
			args.type   = pair[0];
			args.extend = pair[1];
		}

		args.type   = args.type.trim();
		args.extend = utils.is.str(args.extend) ? args.extend.trim() : args.extend;

		// wait for the DOM to be ready shortcut
		if (args.wait === true){
			args.wait = function (done){ utils.dom.ready(done); };
		}

		if (!props){
			props = args.props || {};
		}

		// props ---------------------------------------------------------------
		if (typeof props === 'function'){
			props.prototype.$static = {};
			props.prototype.$get    = {};
			props.prototype.$set    = {};
			props 				    = new props(utils, Class);
		}

		// "extends" is a reserved word, that's why it's the singular version
		var path  = (args.type || props.$type || 'Class'); //.replace('.js', '');
		var type  = path.replace(/((?:^|\/|\-).)/g, function (m, $1){
			if ($1.length > 1){
				return $1[1].toUpperCase();
			}else{
				return $1.toUpperCase();
			}
		});
		
		var extend    	= args.extend || props.$extends || false;
		var setters 	= props.$set || {};
		var getters 	= props.$get || {};
		var static 		= props.$static || {};
		var mixins 		= utils.toArray(props.$mixins || []);
		var uses 		= utils.toArray(props.$uses || []);

		// @todo make those getter/setter cleaner (maybe only if there's no extends)
		getters.id = function (v){ return this.getId(); };
		setters.id = function (v){ this.setId(v); };

		args 			= args || {};
		args.type 		= 'type' in args ? args.type : null;
		args.extend 	= 'extend' in args ? args.extend : null;
		args.singleton 	= 'singleton' in args ? args.singleton : false;
		args.wait 		= 'wait' in args ? args.wait : false;
		args.merge 		= utils.toArray('merge' in args ? args.merge : '');    // merge properties (instead of overwrites)
		args.concat 	= utils.toArray('concat' in args ? args.concat : '');  // concat properties (instead of overwrites)

		return {
			'path'	   : path,
			'type'     : type,
			'extend'   : extend,
			'singleton': args.singleton,
			'wait'     : args.wait,
			'merge'    : args.merge,
			'concat'   : args.concat,
			'setters'  : setters,
			'getters'  : getters,
			'static'   : static,
			'mixins'   : mixins,
			'uses'     : uses,
			'props'    : props,
		};
	};

	Class.load = function (path, callback){
		// @todo...
	};	

	Class.all = function (){
		return classes;
	};

	Class.ready = function (type, callback){
		type = 'class:' + type;
		return !!utils.fn.when(type, callback, classStates);
	};
	
	Class.is = function (item, type){
		// @todo add way to check with type
		return item &&
			typeof item === 'object' &&
			typeof item.isType === 'function' &&
			item.isType('Class') &&
			(!type || item.isType(type));
	};

	Class.isInstance = function (){
		console.warn('Please use Class.is() instead of Class.isInstance()');
		return this.is.apply(this, arguments);
	};

	return Class;
}());

// auto create classes (in project setup.js)
for (var i in CLASS){
	window[i] = new Class(i, CLASS[i]);
}

var EVENTS = window.EVENTS || {};
var Events = new Class('#Events', function (utils){
	// static ------------------------------------------------------------------
	this.$static = {
		'allInfoLogs' : true,	// show all logs, or skip the repeats (when the log is the same as the last one)
	};

    // properties --------------------------------------------------------------
	this.items = {};

	// init --------------------------------------------------------------------
	this.init = function (){
		for (var name in EVENTS) this.on(name, EVENTS[name]);
	};

    // private functions -------------------------------------------------------
    this._getEventNames = function (target, names){
		var eventnames = [];

		this.each(names, function (name){
            // global
			eventnames.push('*:'+name);
			eventnames.push(name);

			// no-target event
			if (!target){
				return;
			}

			// Class functions
			var id      = null;
			var types   = [];
			var classes = [];

            if (Class.is(target)){
                id      = target.getId();
                types   = target.getTypes();
                classes = target.getClasses();
            }else if (utils.is.el(target)){
                id 		= target.id;
				types	= ['HtmlElement', target.tagName.toString().toLowerCase()];
				classes	= (target.getAttribute('class') || '').split(' ');
            }

            var i, ii, l, ll;
			// types
			for (i=0, l=types.length; i<l; ++i){
				eventnames.push(types[i] + ':' + name);
			}
			// classes
			for (i=0, l=classes.length; i<l; ++i){
				eventnames.push('.' + classes[i] + ':' + name);

				for (ii=0, ll=types.length; ii<ll; ++ii){
					eventnames.push(types[ii] + '.' + classes[i] + ':' + name);
				}
			}
			// ID
			if (id){
				eventnames.push('#' + id + ':' + name);
			}
		});

		return eventnames;
	};

    this._isDelegate = function (target, item){
        // can't be the same element
		if (item.target === target) return false;

		// @todo add custom ways to check if element if delegated
		
		if (item.target instanceof Component){
			if (item.delegate instanceof Component){
				return target.contains(item.delegate);
			}else if (item.target.contains(target, item.delegate)){
				return true;
			}
		}

		return false;
    };

    // methods -----------------------------------------------------------------
    this.on = function (target, names, args){
        if (utils.is.str(target)){
			args 	= names;
			names   = target;
			target 	= null;
		}
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args = args || {};


		this.each(names, function (name){
			//if (args.alias) name = name.replace(/\&/g, args.alias);
			var context = args.context || target || null;
			if (target && target.formatEventListener){
				name = utils.apply(target.formatEventListener, [name, args, context], target, name);
			}

			var items = this.items[name];
			if (!items){
				items = this.items[name] = [];
			}

			var item = {
				'target'	: target || null,
				'element'	: args.element ? args.element : utils.is.dom(target),
				'delegate'	: args.delegate || null,
				'context'	: context,
				'callback'	: args.callback || null,
				'once'		: args.once || false,
			};

			this.items[name].push(item);
		});

		return this;
    };

    this.off = function (target, names, args){
        if (utils.is.str(target)){
			args 	= names;
			names   = target;
			target 	= null;
		}
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args = args || {};

        this.each(names, function (name){
			var items = this.items[name];
			if (!items){
				return;
			}

			var search = {
				'target' : target || null,
			//	'element': args.element || (utils.is.el(target) ? target : null),
            };

            if ('delegate' in args) search.delegate = args.delegate;
            if ('context' in args)  search.context = args.context;
            if ('callback' in args) search.callback = args.callback;
            if ('once' in args)     search.once = args.once;

			utils.array.remove(items, search);

			// clean the main object
			if (!items.length){
				delete(this.items[name]);
			}
		});

		return this;
    };

    this.trigger = function (target, names){
		var args = utils.toArray(arguments);

        if (typeof target === 'string'){
			names  = target;
			target = null;
			args   = args.slice(1);
		}else{
			args = args.slice(2);
		}

		// first args is the event data
		if (args[0] === undefined){
			args[0] = {};
		}  

        names = utils.toArray(names);
		// log events 
		if (!!~this.$static.logs.indexOf('info')){
			for (var i in names){
				var msg = '[Event] Triggered "{type}"';
				var data= {'type':names[i]};

				if (Class.is(target)){
					msg     = '[Event] Triggered "{type}" by #{id}';
					data.id = target.getId();
				}	
				
				utils.info(msg, data, {'repeat':this.$static.allInfoLogs});
			}
		}

        names = this._getEventNames(target, names);
        
		var i, l, ii, ll;
        for (i=0, l=names.length; i<l; ++i){
			var name  = names[i];
			var items = this.items[name];
            
            if (!items){
                continue;
			}
        
            var hasPrefix = !!~name.indexOf(':');
            var type      = name.replace(/^.+\:/, '');
            
			for (ii=0, ll=items.length; ii<ll; ++ii){
				var item = items[ii];
				if (!item) continue;
				
                var isSame     = target === item.target && !item.delegate;
				var isDelegate = item.delegate && this._isDelegate(target, item);
				
                if (isSame || isDelegate || (hasPrefix && !item.delegate)){
                    if (utils.is.obj(args[0])){
                        args[0] = utils.extend({}, args[0], {
                            'type'		: type,
                            'target'	: target || item.target,
                            'timestamp'	: new Date(),
                        });
                    }
	
					utils.apply(item.callback, args, item.context || target);

					if (item.once){
						item[ii] = null;
					}
                }
			}

			// @todo clean up the events list, if the item is NULL, remove it
		}

		return this;
    };

    this.has = function (target, names){
        if (utils.is.str(target)){
			names  = target;
			target = null;
		}

		names = this._getEventNames(target, names);

		var found = false;
		var i, l, ii, ll;

        main_loop : for (i=0, l=names.length; i<l; ++i){
			var name  = names[i];
			var items = this.items[name];
            
            if (!items){
                continue;
			}
            
			var hasPrefix = !!~name.indexOf(':');
			for (ii=0, ll=items.length; ii<ll; ++ii){
				var item = items[ii];

				if (target === item.target || hasPrefix){
					found = true;
					break main_loop;
				}
			}
		};

		return found;
    };
});

MIXINS.Events = function (utils){
	this.$merge = 'events';

	// properties --------------------------------------------------------------
	this._events = {
		'context': null,
		'paused' : false,
		'alias'  : '',
		'cache'  : [],		// events to remove		
	};

	// private -----------------------------------------------------------------
	function _ (mixin, names){
		if (!mixin._events.alias || !utils.is.str(names)) return names;
		return names.replace(/\&/g, '.' + mixin._events.alias);
	};

	// init --------------------------------------------------------------------
	this.init = function (){
        var self = this.$self;

		this.$events({
			'context': self,
			'alias'  : self.alias || self.getTypeClass()
		});

		// set the initial events
        if (self.events){
			self.each(self.events, function (v, i){
				this.on(i, v);
            });
        };
	};

	this.$events = function (args){
        utils.extend(this._events, args);
		return this.$self;
	};

	// methods -----------------------------------------------------------------
	this.pauseEvents = function (value){
		this._events.paused = value;
		return this.$self;
	};

	this.on = function (target, names, args, callback){
		if (utils.is.str(target)){
			args 	= names;
			names   = target;
			target 	= this;
		}
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args 		  = args || {};
		args.context  = 'context' in args ? args.context : this._events.context;
		args.callback = callback ? callback : args.callback;
		names 		  = _(this, names);

		// @todo change this for a better suited version (debounce in EVENTS and in DomEvents)
		/*
		if (args.debounce){
			var duration = args.debounce === true ? 0 : args.debounce;
			args.callback = utils.fn.debounce({
				'context': args.context,
				'wait'   : duration,
			}, args.callback);
		}
		*/

		if (window.Query && target instanceof Query){
			target.on(names, args);
		}else if (utils.is.dom(target)){
			utils.el.addEvent(target, names, args);
		}else{
			Events.on(target, names, args);
		}

		this._events.cache.push(arguments);

		return this.$self;
	};

	this.off = function (target, names, args, callback){
		if (utils.is.str(target)){
			args 	= names;
			names   = target;
			target 	= this;
		}
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args 		  = args || {};
		args.context  = 'context' in args ? args.context : this._events.context;
		args.callback = callback ? callback : args.callback;
		names 		  = _(this, names);

		if (window.Query && target instanceof Query){
			target.off(names, args);
		}else if (utils.is.dom(target)){
			utils.el.removeEvent(target, names, args);
		}else{
			Events.off(target, names, args);
		}

		return this.$self;
	};

	this.trigger = function (target){
		if (this._events.paused){
			this.$self.info('Events have been paused');
			return this.$self;
		}

		var args = utils.toArray(arguments);
		if (utils.is.str(target)){
			target = this;
			args.unshift(target);
		}

		if (window.Query && target instanceof Query){
			target.trigger.apply(null, args);
		}else if (utils.is.dom(target)){
			utils.el.triggerEvent.apply(null, args);
		}else{
			Events.trigger.apply(Events, args);
		}

		return this.$self;
	};

	this.hasEvents = function (target, names){
		if (typeof target === 'string'){
			names   = target;
			target 	= this;
		}

		if (utils.is.el(target)){
			// @todo
		}else{
			return Events.has(target, names);
		}
	};

	this.removeEvents = function (){
		for (var i in this._events.cache){
			var a = this._events.cache[i];
			this.off.apply(this.$self, a);
		}

		// clear the cached events
		this._events.cache = [];
		
		// @todo when adding the event with on(), cache the info, so it's easy to remove after
		return this.$self;
	};
};
var FILTERS = window.FILTERS || {};
var Filters = new Class('#Filters', function (utils){
    // properties --------------------------------------------------------------
	this.items = {};

	// init --------------------------------------------------------------------
    this.init = function (){
        for (var name in FILTERS) this.add(name, FILTERS[name]);
    };

    // methods -----------------------------------------------------------------
    this.add = function (name, callback){
        var items = this.items[name];
		if (!items){
			items = this.items[name] = [];
		}
		items.push(callback);
		return this;
    };

    this.remove = function (name, callback){
        var items = this.items[name];
		if (!items){
			return this;
		}

        utils.array.remove(items, callback);
        
		return this;
    };

    this.apply = function (names, context, args){
        if (arguments.length < 3){
			args = context;
		}
		if (!utils.is.arr(args)){
			args = [args];
		}

        var names     = utils.toArray(names);
        var callbacks = [];
        for (var i=0, l=names.length; i<l; ++i){
            var name = names[i];

            if (utils.is.str(name) && name in this.items){
                callbacks = callbacks.concat(this.items[name]);
            }else if (utils.is.obj(name) && 'callback' in name && 'context' in name){
                callbacks.push(name.callback.bind(name.context));
            }else if (utils.is.fn(name)){
                callbacks.push(name);
            }
        }

        for (var i=0, l=callbacks.length; i<l; ++i){
            args[0] = utils.apply(callbacks[i], args, context, args[0]);
		}

		return args[0];
    };
});

MIXINS.Filters = function (utils){
    this.$merge = 'filters';

	// properties --------------------------------------------------------------
    this._filters = {
        'local'   : {},
        'callback': null,
    };

    // init --------------------------------------------------------------------
	this.init = function (){
        var self = this.$self;

        // set the initial $filters
        if (self.filters){
            self.each(self.filters, function (v, i){
                this.addFilter(i, v, self);
            });
        };
    };
    
    this.$filters = function (args){
        utils.extend(this._filters, args);
		return this.$self;
	};

	// methods -----------------------------------------------------------------
    this.addFilter = function (name, callback, context){
        if (utils.is.obj(name)){
            if (utils.is.fn(name.addFilter)){
                name.addFilter(callback, context, this);
                return this.$self;
            }else{
                return this.$self.error('The target doens\'t have an addFilter function', null, target);
            }
        }

        if (!this._filters.local[name]){
			this._filters.local[name] = [];
		}

        // add the filter only if it's not already added
		if (!~this._filters.local[name].indexOf(callback)){
			this._filters.local[name].push({
                'callback': callback,
                'context' : context || this,
            });
		}

        return this.$self;
    };

    this.removeFilter = function (name, callback, context){
        if (utils.is.obj(name)){
            if (utils.is.fn(name.addFilter)){
                name.removeFilter(callback, context, this);
                return this.$self;
            }else{
                return this.$self.error('The target doens\'t have an addFilter function', null, target);
            }
        }

        if (!this._filters.local[name]){
			this._filters.local[name] = [];
		}

        // add the filter only if it's not already added
		if (~this._filters.local[name].indexOf(callback)){
            utils.array.remove(this._filters.local[name], {
                'callback': callback,
                'context' : context || this,
            });
		}

        return this.$self;
    };

    this.applyFilters = function (names){
        names = utils.toArray(names);
        args  = utils.toArray(arguments).slice(1);

        var id      = this.getId();
        var types   = this.getTypes();
        var classes = this.getClasses();

        var i, ii, ll;
        for (i in names){
			var name    = names[i];
            
            // global filter
			args[0] = Filters.apply(name, this, args);
            
            // types filters
			for (ii=0, ll=types.length; ii<ll; ++ii){
				args[0] = Filters.apply(types[ii] + ':' + name, this, args);
			}
            
            // classes filters
			for (ii=0, ll=classes.length; ii<ll; ++ii){
				args[0] = Filters.apply('.' + classes[ii] + ':' + name, this, args);
			}
            
            // id filter
			args[0] = Filters.apply('#' + id + ':' + name, this, args);
            
            // callback filter
			var callbacks = utils.apply(this._filters.callback, [name], this) || [];
			args[0] = Filters.apply(callbacks, this, args);
            
            // local filters
			var local = this._filters.local[name] || [];
			args[0] = Filters.apply(local, this, args);
        }

        return args[0];
    };
};
var STATES = window.STATES || {};
var States = new Class('#States', function (utils){
	// properties --------------------------------------------------------------
    this.items = {};
    
	// init --------------------------------------------------------------------
	this.init = function (){
		for (var name in STATES) this.set(name, STATES[name]);
	};

    // private functions -------------------------------------------------------
    this._item = function (name, value){
        var group = '*';
        if (utils.is.arr(name)){
            group = name[0];
            name  = name[1];
        }

        if (value !== undefined){
            if (!this.items[group]){
                this.items[group] = {
                    'listeners' : [],
                    'values'    : {},
                };
            }
            if (!this.items[group].values){
                this.items[group].values = {};
            }
            
            this.items[group].values[name] = value;
        }else{
            if (!this.items[group] || !this.items[group].values || !this.items[group].values[name]){
                return {
                    'name' : name,
                    'group': group,
                };
            }
        }

        return this.items[group].values[name];
    };

	// methods -----------------------------------------------------------------
    this.set = function (name, value, data){
        var item = this._item(name);
        var old  = item.value;

        if (value !== old){
            item.previous = old;
            item.value    = value;
            item.data     = data || item.data || {};
            this._item(name, item);

            // go through the listeners
            var listeners = this.items[item.group] && this.items[item.group].listeners;
            for (var i in listeners){
                var listener = listeners[i];

                utils.apply(listener.callback, [{
                    'name'    : item.name,
                    'value'   : item.value,
                    'previous': item.previous,
                    'data'    : item.data || {},
                }], listener.context);
            }
        }

        return this;
    };

    this.has = function (name){
        return this._item(name).value !== undefined;
    };

    this.get = function (name, fallback){
        var item = this._item(name);
        return item ? item.value : fallback;
    };

    this.all = function (name, previous){
        if (!name){
            name = '*';
        }

        var values = {};
        var items  = this.items[name] ? this.items[name].values || {} : [];

        for (var i in items){
            values[i] = previous ? item[i].previous : items[i].value;
        }

        return values;
    }

    this.previous = function (name){
        var item = this._item(name);
        if (!item){
            return fallback;
        }
        return item.previous;
	};

    this.toggle = function (name){
        var item  = this._item(name);
        var value = item ? item.value : false;
        return this.set(name, !value);
    };

    this.on = function (name, callback, context){
        if (utils.is.fn(name)){
            context  = callback;
            callback = name;
            name     = '*';
        }

        var item = this.items[name];
        if (!item){
            item = this.items[name] = {'listeners':[]};
        }

        item.listeners.push({
            'context' : context,
            'callback': callback,
        });

        return this;
    };

    this.off = function (name, callback, context){
        if (utils.is.fn(name)){
            context  = callback;
            callback = name;
            name     = '*';
        }

        var item = this.items[name];
        if (!item){
            return this;
        }

        utils.array.remove(item.listeners, function (item){
            return item.context === context && (callback === true || item.callback === callback);
        });

        return this;
    };
});

MIXINS.States = function (utils){
    this.$merge = 'states';

    this._states = {
        'timeout': null,
        'changes': [],
    };

    // init --------------------------------------------------------------------
	this.init = function (){
        var name = _(this);
        var self = this.$self;

        // set the initial $states
        if (self.states){
            this.setStates(self.states);
        };
        
        // add custom prop to get this data faster
        utils.object.prop(self, 'states', function (){
            return States.all(name);
        });
        
        States.on(name, onChange, this);
	};

    this.states = function (args){
        utils.extend(this._states, args);
        return this.$self;
    };

    // private functions -------------------------------------------------------
    function _ (mixin, name){
        var id = '#' + mixin.$self.getId();
        if (name){
            return [id, name];
        }else{
            return id;
        }
    };

    function onChange (e){
        var self      = this.$self;
        var states    = this._states;
        var callback1 = self.onStateChange;
        var callback2 = self.onStatesChange;

        utils.apply(callback1, [e], self);

        states.changes.push(e.name);

        clearTimeout(states.timeout);
        
        states.timeout = setTimeout(function (){
            utils.apply(callback2, [states.changes], self);

            states.changes = [];
            states.timeout = null;
        }, 30);
    };

    // methods -----------------------------------------------------------------
    this.setState = function (name, value, data){
        name = _(this, name);
        States.set(name, value, data);
		return this.$self;
	};

	this.setStates = function (states){
        for (var i in states){
			this.setState(i, states[i]);
		}
		return this.$self;
	};

	this.toggleState = function (name){
        name = _(this, name);
		States.toggle(name);
        return this.$self;
	};  

	this.getState = function (name, fallback){
        name = _(this, name);
		return States.get(name, fallback);
	};

    this.getStates = function (){
        return States.all(_(this));
    };

    this.hasState = function (name){
        name = _(this, name);
        return States.has(name);
    };

	this.isState = function (name, value){
        var state = this.getState(name);
        return value === undefined ? state : state === value;
	};

    this.stateClassnames = function (prefix){
        var items      = States.items[_(this)];
        var values     = items.values || {};
        var classnames = {};

        prefix = prefix || '';

        for (var i in values){
            var name    = values[i].name;
            var value   = values[i].value;
            var old     = values[i].previous;
            var active  = value === false ? false : true;
            
            if (old !== undefined){
                old               = name + (utils.is(old) && !utils.is.bool(old) ? '-' + old : '');
                classnames[prefix + old]   = false;
            }

            value                      = name + (utils.is(value) && !utils.is.bool(value) ? '-' + value : '');
            classnames[prefix + value] = active;
        }

		return classnames;
    };
};

Utils.add('media', function (utils, MEDIA, RE){
	// consts ------------------------------------------------------------------
	RE.MEDIA_SRC_PATH = /url\(([^\)]+)\)/;

    MEDIA.QUEUE    = {};
    MEDIA.IMAGES   = {};
    MEDIA.FONTS    = {};
    MEDIA.REQUIRES = {};
	
	var STATUS = {
		LOADING: 'loading',
		READY  : 'ready',
		ERROR  : 'error',
	};

    // methods -----------------------------------------------------------------

    // methods: require --------------------------------------------------------
	this.http = function (url, data, args){
		if (arguments.length <= 2){
			args = data;
			data = null;
		}

		if (utils.is.fn(data)){
			args = {'callback':data};
			data = null;
		}
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		args          = args || {};
		args.data     = args.data || data || null;
		args.type 	  = args.type || null;
		args.context  = args.context || null;
		args.selector = args.selector || null;
		args.queue 	  = args.queue || null;
		args.delay 	  = utils.string.toDuration(args.delay || 0);
        args.method   = args.method || (args.data ? 'post' : 'get');
		args.callback = args.callback || null;
        
        // add delay, unique...	
		var queue = args.queue ? MEDIA.QUEUE[args.queue] || (MEDIA.QUEUE[args.queue] = []) : null;

		// there's a selector in the url
		var sIndex = url.indexOf(' ');
		if (!!~sIndex){
			args.selector = url.slice(sIndex).trim();
			url  		  = url.slice(0, sIndex);
		}

		var request = new XMLHttpRequest();
		url = utils.string.replace(url, args.data || {});

		if (args.method === 'get' && args.data){
			url += ((~url.indexOf('?') ? '&' : '?') + utils.object.toQuerystring(args.data));
		}

		function _toPart (data, selector){
			if (utils.is.obj(data)){
				data = data[selector];
			}else if (utils.is.str(data)){
				// @source jQuery code
				var doc   = document.implementation.createHTMLDocument("");
				var head  = data.match(/\<head.*?\>([\s|\S]+)\<\/head\>/);
				var base  = '<base href="'+document.location.href+'" />';

				if (head){
					data = data.replace(head[0], '');
					head = head[1];
				}

				doc.documentElement.innerHTML = data;
				doc.head.innerHTML = base + (head || ''); 

				if (selector === ':dom'){
					data = doc;
				}else{
					var nodes = utils.dom.getAll(selector, {'context':doc.body});
					var root  = document.createElement('div');
					var i, l;
					for (i=0, l=nodes.length;i<l;++i){
						root.appendChild(nodes[i]);
					}

					data = root.innerHTML;
				}
			}

			return data;
		}

		function _onChange (){
			if (request.readyState !== XMLHttpRequest.DONE) return;
			if (request.status === 0){
				return; // aborded
			}

			var type       = args.type || request.getResponseHeader("Content-Type") || '';
			var status     = request.status;
			var allHeaders = request.getAllResponseHeaders().split("\n");
			var headers    = {};
			var response   = null;

			utils.each(allHeaders, function (head){
				if (head = head.trim()){
					var pair = head.split(':');
					var key  = pair[0].trim();
					var value= pair[1].trim();
					headers[key] = value;
				}
			});
			
			// parse the data
			if (type === 'application/json' || ~type.indexOf('json')){
				response = JSON.parse(request.responseText);
				type     = 'json';
			}else if (type === 'application/xml' || type === 'text/xml' || type === 'text/html' || type === 'html' || type === 'xml'){
				response = request.responseXml;
				type     = 'xml';
			}else if (type === 'text/css' || type === 'css'){
				response = utils.string.toCss(request.responseText);
				type     = 'css';
			}else{
				response = request.responseText;
				type     = 'text';
			}

			if (status === 200 && !response){
				status = 204;
			}

			if (response && args.selector){
				response = _toPart(response, args.selector);
			}

			// output logs from PHP
			if (headers['content-logs']){
				var logs  = utils.decode(headers['content-logs']);
				var time  = headers['content-time'] || '';
				var label = url + (time ? ' ('+time+')' : '');
				
				console.group(label);
				for (var i=0, l=logs.length; i<l; ++i){
					eval('console.log('+logs[i]+')');
				}
				console.groupEnd(label);
			}			

			if (utils.is.fn(args.callback)){
				args.callback.apply(args.context, [response, status >= 200 && status <= 299, {
					'type'   : type,
					'headers': headers,
					'request': request,
					'status' : status,
				}]);

				if (queue){
					queue.shift();

					if (queue.length){
						queue[0]();
					}
				}
			}
		}

		function _call (){
			request.onreadystatechange = _onChange;
			
			// send request
			request.open(args.method, url, true);
	
			if (args.method === 'post' && args.data){
				var data = args.data instanceof FormData ? args.data : utils.object.toForm(args.data);

				// @info "ERR_CONTENT_DECODING_FAILED" happens when gzip on the server is ON and the Content-Length limit (for upload), is over the limit

				request.send(data);
			}else{
				request.send();
			}
		}
		
		if (queue){
			queue.push(_call);

			if (queue.length === 1){
				_call();
			}
		}else if (args.delay){
			setTimeout(_call, args.delay);
		}else{
			_call();
		}

		return request;
	};

	this.get = function (url, data, callback){
		if (utils.is.fn(data)){
			callback = data;
			data 	 = {};
		}
		return utils.media.http(url, {
			'method'  : 'get',
			'data'    : data,
			'callback': callback,
		});
	};

	this.post = function (url, data, callback){
		if (utils.is.fn(data)){
			callback = data;
			data 	 = {};
		}
		return utils.media.http(url, {
			'method'  : 'post',
			'data'    : data,
			'callback': callback,
		});
	};

	this.cancel = function (request){
		if (request && utils.is.fn(request.abort)){
			request.abort();
		}
	};

	this.require = function (url, args, callback){
		if (utils.is.fn(args)){
			callback = args;
			args     = {};
		}
		
		args          = args || {};
		args.async    = 'async' in args ? args.async : true;
		args.context  = 'context' in args ? args.context : null;
		args.callback = callback || args.callback || null;
		args.cache 	  = 'cache' in args ? args.cache : true;
		args.version  = 'version' in args ? args.version : (window.version || false);

		// clean url
		// url = url.replace(/\/{2,}/, '/');
		// console.log(url);

		var cache = MEDIA.REQUIRES[url] = args.cache && url in MEDIA.REQUIRES ? MEDIA.REQUIRES[url] : {
			'status': null,
			'queue' : [],
		};

		// add new item to queue
		cache.queue.push({
			'context' : args.context,
			'callback': args.callback,
		});

		if (cache.status){
			if (cache.status === STATUS.READY || cache.status === STATUS.ERROR) _done();
			return;
		}else{
			cache.status = STATUS.LOADING;
		}
		
        function _done (success){
			if (utils.is.bool(success)){
				cache.status = success ? STATUS.READY : STATUS.ERROR;
			}
			
			var items = cache.queue;
			var i=0, l=items.length;
			cache.queue = [];

			success = cache.status === STATUS.READY;

			for (;i<l;++i){
				utils.apply(items[i].callback, [url, success], items[i].context);
			}
        }

        var head  = document.getElementsByTagName("head")[0];
        var isCss = !!~url.indexOf('.css');
		var url2  = args.version ? url + '?ver=' + args.version : url;

        if (isCss){
            var link    = document.createElement('link');
            link.rel  	= 'stylesheet';
			link.type	= 'text/css';
			link.media 	= 'all';
			link.onload = function(){ _done(true); };
			link.onerror= function(){ _done(false); };
            link.href 	= url2;

			head.appendChild(link);
        }else{
            var script   = document.createElement('script');
			script.type  = "text/javascript";
			
			if (args.async){
				script.async = "true";
				script.defer = "true";
			}

            // IE browser
            if (script.readyState){
                script.onreadystatechange = function (){
                    if (this.readyState !== "loaded" && this.readyState !== "complete") return;
                    this.onreadystatechange = null;
                    _done(true);
                };
            // other browsers
            }else{
                script.onload  = function(){ _done(true); };
                script.onerror = function(){ _done(false); };
            }

            script.src = url2;
			
            head.appendChild(script);
        }
	};

	this.requires = function (urls, args, callback){
		if (utils.is.fn(args)){
			callback = args;
			args     = {};
		}
		
		args 			  = args || {};
		args.simultaneous = 'simultaneous' in args ? args.simultaneous : true;
		args.delay        = 'delay' in args ? args.delay : 0;
		args.async        = 'async' in args ? args.async : true;
		args.context      = 'context' in args ? args.context : null;

		var index   = 0;
		var count   = 0;
		var args2   = utils.extend({}, args);
		var success = [];
		var error   = [];

		args2.simultaneous = false;

		function _next (){
			var url = urls[index++];

			if (utils.is.arr(url)){
				utils.media.requires(url, args2, _check);
			}else if (url){
				utils.media.require(url, args2, _check);
			}else{
				return;
			}

			if (args.simultaneous){
				_next();
			}
		}

		function _check (u, s){
			count++;

			if (u){
				if (s) success.push(u);
				else   error.push(u);
			}

			if (count >= urls.length){
				setTimeout(function (){
					utils.apply(callback, [success, error, urls], args.context);
				}, args.delay);
			}

			if (!args.simultaneous){
				_next();
			}
		}

		if (!urls.length){
			_check();
		}else{
			_next();
		}
	};

	// methods: image ----------------------------------------------------------
	this.image = function (url, args, callback){
		if (utils.is.fn(args)){
			callback = args;
			args     = {};
		}

		if (url instanceof Array){
			url = url[0];
		}

		args 			= args || {};
		args.callback 	= callback || args.callback;
		args.context 	= 'context' in args ? args.context : null;
		args.image 		= url instanceof Image ? url : null;
		args.data 		= 'data' in args ? args.data : {};
		args.cache 		= 'cache' in args ? args.cache : true;

		var src = utils.toSrc(url, 'image');

		// this will create a new image with the same src, that way, the source can't be impacted
		if (args.image && !args.cache){
			args.image.src = src;
		}
		
		if (!src){
			utils.apply(args.callback, null, args.context);
			return;
		}

		var media = MEDIA.IMAGES[src];
		if (!media){
			var dummy = new Image();

			// @todo 
			//var isSvg   = !!~src.indexOf('.svg');
			//var isLocal = isSvg && utils.url.isLocal(src);

			MEDIA.IMAGES[src] = media = {
				'src'   : src,
				'image' : dummy,
				'type'  : 'img',
				'width' : 0,
				'height': 0,
				'queue' : [],
				'status': STATUS.LOADING,
				'cached': false,
			};

			// image already defined
			if (url instanceof Image && url.naturalWidth && url.naturalHeight){
				dummy.src = src;
				utils.apply(_load, null, url);
			}else{
				dummy.onload  = _load;
				dummy.onerror = _error;
				dummy.src     = src;
			}
			// crossOrigin = Anonymous 
		}

		if (media.status === STATUS.READY || media.status === STATUS.ERROR){
			_done([args]);
		}else{
			media.queue.push(args);
		}

		function _load (){
			// @info little fix for IE9 to IE11 with SVG images
			if (!this.width && !this.height){
				document.body.appendChild(this);
				this.width 	= this.offsetWidth;
				this.height = this.offsetHeight;
				document.body.removeChild(this);
			}

			// /if (url instanceof Image)
			//console.log(url, this.naturalWidth);

			media.width  = this.naturalWidth || this.width;
			media.height = this.naturalHeight || this.height;
			media.status = STATUS.READY;

			// @todo svg

			_done();
		}
		function _svg (){
			// @todo svg
		}
		function _error (){
			media.status = STATUS.ERROR;
			_done();
		}
		function _done (queue){
			queue = queue || media.queue || [];
			media.queue = [];
			
			var i=0, l=queue.length, v, img;
			for (;i<l;++i){
				v = queue[i];

				// use the dummy image for the first callback
				if (media.status === STATUS.ERROR){
					img = null;
				}else if (v.image){
					img = v.image;
				}else{
					img = media.image;
				}
				
				img = media.image;


				var cached = media.cached;
				media.cached = true;

				utils.apply(v.callback, [{
					'image' : img,
					'source': media.image,
					'src'	: media.src,
					'width' : media.width,
					'height': media.height,
					'type'	: media.type,
					'cached': cached,
				}, media.status !== STATUS.ERROR], v.context);
			}
		}

		return media;
	};

	this.images = function (urls, args, callback){
		if (utils.is.fn(args)){
			callback = args;
			args     = {};
		}

		args.path 		= 'path' in args ? args.path : '';
		args.context 	= 'context' in args ? args.context : null;
		args.callback 	= callback || args.callback;
		args.onComplete = 'onComplete' in args ? args.onComplete : null;
		//args.firstValid	= 'firstValid' in args ? args.firstValid : false;

		if (urls instanceof Image){
			urls = [urls];
		}else{
			urls = utils.toArray(urls);
		}

		var count 	= 0;
		var total 	= urls.length;
		var images = [];

		urls = utils.each(urls, function (url, i){
			url = utils.is.str(url) ? args.path + url : url;

			utils.media.image(url, {
				'context' : args.context,
				'callback': _onLoad,
				'data'    : {'index':i}
			});

			return url;
		});

		function _onLoad (image){
			images.push(image);
			// console.log(image.cached);

			utils.apply(args.callback, [image], args.context);

			if (images.length >= total){
				utils.apply(args.onComplete, [images], args.context);
			}
		}

		if (!total){
			utils.apply(args.onComplete, [], args.context);
		}
	};

	// methods: font -----------------------------------------------------------
	this.font = function (name, args, callback){
		if (utils.is.fn(args)){
			args = {'callback':args};
		}

		// @todo use FontFace API if possible https://developer.mozilla.org/en-US/docs/Web/API/FontFace

		args          = args || {};
		args.callback = args.callback || callback;
		args.context  = 'context' in args ? args.context : null;
		args.italic   = 'italic' in args ? args.italic : false;
		args.bold     = 'bold' in args ? args.bold : false;
		args.timeout  = utils.string.toDuration('timeout' in args ? args.timeout : '1s');

		var key  = name + (args.italic ? ' / italic' : '') + (args.bold ? ' / bold' : '');
		var font = MEDIA.FONTS[key];

		if (!font){
			MEDIA.FONTS[key] = font = {
				'name'  : name,
				'queue' : [],
				'status': STATUS.LOADING,
			};

			_load();
		}

		if (font.status === STATUS.READY || font.status === STATUS.ERROR){
			_done([args]);
		}else{
			font.queue.push(args);
		}
		
		function _load (){
			var els = font.elements = utils.dom.create('<div style="position:absolute; top:0; left:0; pointer-events:none; opacity:0; overflow:hidden;">\
				<div element="content" style="position:relative; white-space: nowrap; font-family: serif; display:inline-block;">\
					<div element="innerWrapper" style="position:absolute; width:100%; height:100%; overflow:hidden;"><div element="innerContent"></div></div>\
					dummy text\
				</div>\
			</div>', {'extract':'element', 'parent':'body'});

			font.width   = font.elements.content.offsetWidth;
			font.height  = font.elements.content.offsetHeight;
			font.time  	 = +new Date();
			
			
			utils.el.update(els.self, {'style':{'width':font.width - 1, 'height':font.height - 1}, 'props':{
				'scrollLeft': els.self.scrollWidth - els.self.clientWidth,
				'scrollTop'	: els.self.scrollHeight - els.self.clientHeight,
			}});

			utils.el.update(els.innerContent, {'style':{'width':font.width + 1, 'height':font.height + 1}});

			utils.el.update(els.innerWrapper, {'props':{
				'scrollLeft' : els.innerWrapper.scrollWidth - els.innerWrapper.clientWidth,
				'scrollTop'	 : els.innerWrapper.scrollHeight - els.innerWrapper.clientHeight,
			}});

			els.self.addEventListener('scroll', _scroll);
			els.innerWrapper.addEventListener('scroll', _scroll);

			els.content.style.font = (args.italic ? 'italic ' : '') + (args.bold ? 'bold ' : '') + '100px ' + name;

			// add timeout
			if (args.timeout){
				font.timeout = setTimeout(_error, args.timeout);
			}
		}

		function _scroll (e){
			if (font.elements.content.offsetWidth === font.width && font.elements.content.offsetHeight === font.height){
				return;
			}

			// console.log(font.elements.content.offsetWidth, font.elements.content.offsetHeight, '->', font.width ,font.height);

			font.time 	= (+new Date()) - font.time;
			font.status = STATUS.READY;

			setTimeout(_done, 10);
		}

		function _error (){
			font.status = STATUS.ERROR;
			_done();
		}

		function _clear (){
			if (font.cleared) return;
			
			font.cleared = true;

			clearTimeout(font.timeout);
			font.elements.self.removeEventListener('scroll', _scroll);
			font.elements.innerWrapper.removeEventListener('scroll', _scroll);
			// utils.dom.remove(font.elements.self);
		}

		function _done (queue){
			_clear();

			queue = queue || font.queue;
			
			// @todo 
			for (var i in queue){
				var q = queue[i];
				utils.apply(q.callback, null, q.context);
			}

			font.queue = [];
			
			// // loading 2 similar fonts, but with different Italic/Bold seems to bug
			// setTimeout(function (){
			// 	utils.fn.all(callbacks, args.context, [item, false]);
			// }, 0);
		}
	};
});

MIXINS.Fallback = function (utils){
    // Point fallback ----------------------------------------------------------
    this.$point = function (args){
        if (window.Point){
            return new Point(args);
        }else{
            this.info('Module "item/point" is missing, using a fallback', true);

            var args = args || {};

            return utils.extend(args, {
                'x'       : args.x || 0,
                'y'       : args.y || 0,
                'width'   : args.width || 0,
                'height'  : args.height || 0,
                'ratioX'  : 0,
                'ratioY'  : 0,
                'percentX': '0%',
                'percentY': '0%',
                'isStart' : null,
                'isChange': false,
                'isEnd'   : false,
                'size'   : function (p){
                    p           = utils.math.toPoint(p);
                    this.width  = p.x;
                    this.height = p.y;
                    return this;
                },
                'update': function (p){
                    if (this.isStart === null){
                        this.isStart = true;
                    }else if (this.isStart === true){
                        this.isStart = false;
                    }

                    if (!p){
                        this.isStart = null;
                        this.isEnd   = true;
                    }else{
                        p             = utils.math.toPoint(p);
                        this.x        = p.x;
                        this.y        = p.y;
                        this.ratioX   = this.width ? this.x / this.width : 0;
                        this.ratioY   = this.height ? this.y / this.height : 0;
                        this.percentX = this.ratioX * 100 + '%';
                        this.percentY = this.ratioY * 100 + '%';
                        this.isEnd    = false;

                        if (this.isStart){
                            this.startX = p.x;
                            this.startY = p.y;
                        }

                        this.deltaX = this.startX - p.x;
                        this.deltaY = this.startY - p.y;
                    }

                    this.isChange = (!this.isStart && !this.isEnd);

                    return this;
                }
            });
        }
    };
};
MIXINS.Style = function (utils){
    this.$concat = 'style';
    this.$merge  = 'vars';
    
	// properties ------------------------------------------------------------------------------------------------------
    
    // private ---------------------------------------------------------------------------------------------------------

	// init ------------------------------------------------------------------------------------------------------------
    this.init = function (){
        var self   = this.$self;
        var alias  = self.alias || self.classname || self.getTypeClass();
        var vars   = ('vars' in self ? self.vars : {});
        var format = self.onStyleFormat;

        vars['debug']  = '&.is-debug';
        vars['!debug'] = '&:not(.is-debug)';

        if (self.style){
            utils.dom.addStyle({
                'name'   : self.getType() + (self.alias ? ': ' + self.alias : ''),
                'alias'  : alias,
                'vars'   : vars,
                'once'   : true,
                'format' : format,
                'context': self,
            }, self.style);
        }
    };

	// methods ---------------------------------------------------------------------------------------------------------
    this.addStyle = function (){
        // @todo
    };


	// methods ---------------------------------------------------------------------------------------------------------
    // If states exists
    this.onStyleFormat = function (t){
        var stateRe = /\:?state:(\!)?(.[^\s{]+)/g;
        var prefix  = this.$static.statePrefix || 'is-';

        return t.replace(stateRe, function (m, $1, $2){
            return $1 ? '&:not(.' + prefix + $2 + ')' : '&.' + prefix + $2;
        });
    };

    this.onStateChange = function (e){
        if (this.element && utils.is.fn(this.stateClassnames)){
            var classnames = this.stateClassnames(this.$static.statePrefix || 'is-');
            this.element.classnames(classnames);
        }
        // this.trigger('state-' + e.name + '-change', e);
    };

    // shortcuts --------------------------------------------------------------------------------------------------------
    utils.fn.once('mixin_style', function (){
        var _add = utils.dom.addCustomStyle;

        _add('size', function (width, height){
            if (height === undefined){
                height = width;
            }
            
            return {
                'width' : width,
                'height': height,
            };
        });

        _add('corner', function (x, y, position){
            var style = {
                'position' : position || 'absolute',
            };

            var translate = {
                'x' : 0,
                'y' : 0,
            };

            if (x === 'all'){
                y            = utils.array.to4Values(y || 0, ' ');
                style.top    = y[0];
                style.right  = y[1];
                style.bottom = y[2];
                style.left   = y[3];
            }else{
                x = (x || '').split(' ');
                y = (y || '').split(' ');
                
                x[1] = x[1] || 0;
                y[1] = y[1] || 0;
                
                // switch x and y when the wrong order is set
                if (['top','bottom'].indexOf(x[0])){
                    x = [y, y = x][0];
                }
                if (['left','right'].indexOf(y[0])){
                    x = [y, y = x][0];
                }

                if (x[0] === 'left' || x[0] === 'start'){
                    style.left = x[1];
                }else if (x[0] === 'right' || x[0] === 'end'){
                    style.right = x[1];
                }else if (x[0] === 'center' || x[0] === 'middle'){
                    style.left  = '50%';
                    translate.x = x[1] ? 'calc(-50% + '+x[1]+')' : '-50%';
                }else{
                    style.left = x[0];
                }

                if (y[0] === 'top' || y[0] === 'start'){
                    style.top = y[1];
                }else if (y[0] === 'bottom' || y[0] === 'end'){
                    style.bottom = y[1];
                }else if (y[0] === 'center' || y[0] === 'middle'){
                    style.top   = '50%';
                    translate.y = y[1] ? 'calc(-50% + '+y[1]+')' : '-50%';
                }else{
                    style.top = y[0];
                }

                if (translate.x || translate.y){
                    style.transform = 'translate('+translate.x+','+translate.y+')';
                }
            }

            return style;
        });
    });    
};
MIXINS.Element = function (utils){
    this.$merge  = '$element,$elements,elements';
    this.$element = {
        'defaultTag'      : null,             // default tag if the element is null, create the element
        'defaultSelector' : null,             // default selector if the element is null, try to find it in the page
        'parentNode'      : null,             // add the element to a specific parentNode
        // 'parentSelector'  : null
        'cloneNodes'      : false,            // parse clone nodes
        'hiddenNodes'     : false,            // parse hidden nodes and remove hidden/hide attributes
        'domContext'      : null,
        'extractElements' : false, 
        'classAttr'       : 'class',          // set the instance class with the element attribute
        'idAttr'          : 'id',             // set the instance id with the element attribute
        'elementAttr'     : 'data-element',
        'htmlAttr'        : 'data-html',      // change the "element" where the "this.html" should work, and change the this.element
        'stringsAttr'     : 'data-strings',   // find an element attribute for special strings
        'aliasAttr'       : 'data-alias',     // change the alias of a class
        'rootAttr'        : 'data-root',      // move the element into another root (like parentNode, but this can be set by an attribute)
        'autoClass'       : true,             // automatically the default classname (based on this.getAlias())
        'autoExtractClass': true,             // automatically the a alias classname (based on this.getAlias()) and the extract name/key
        'autoTemplate'    : false,            // automatically tag "element" to templates if they have "{{" in them
        'excludeClosest'  : null,             // when extracting elements, limit the fetch to the current parent, if inside ANOTHER  "closest selector", skip the element
        'useQuery'        : null,             // convert element/elements to Query class
    };
    
    // consts ----------------------------------------------------------------------------------------------------------
    var CLASSES = {
        IS_ANIMATING : 'is-animating',
        IS_LOADING   : 'is-loading',
        IS_EMPTY     : 'is-empty',
        HAS_OVERLAY  : 'has-overlay',
        HAS_SCROLL   : 'has-overlay-scroll',
    };

	// properties ------------------------------------------------------------------------------------------------------
    this._element = {
        'el'         : null,
        'children'   : null,
        'isOverlay'  : false,
        'isParsed'   : false,
        'isLoading'  : false,
        'isAnimating': false,
        'requests'   : [],
    };

    this.element    = null;
    this.elements   = {};
    this._templates = {};

    // private ---------------------------------------------------------------------------------------------------------
    function _attr (el, attr, fallback){
        var value = el && el.getAttribute && attr ? el.getAttribute(attr) : null;
        fallback = fallback === undefined ? null : fallback;
        return utils.is(value) ? value : fallback;
    }

    function _child (v){
        var t = v.tagName.toLowerCase();
        return t === 'template' || t === 'script' ? null : v;
    }

    function _element (el, config){
        config = config || {};

        var self       = this.$self;
        var args       = this.$element;
        var cache      = this._element;
        var classnames = _attr(el, args.classAttr, config.className || '');
        var id         = _attr(el, args.idAttr,  config.id || null);
        var root       = _attr(el, args.rootAttr, config.root || self.root);
        var alias      = _attr(el, args.aliasAttr, config.alias || self.alias);
        var strings    = _attr(el, args.stringsAttr, config.strings || {});

        root    = utils.dom.get(root);
        strings = utils.toJson(strings);
        strings = self.strings = utils.extend(self.strings || {}, strings);

        // update the alias
        self.alias = alias || self.alias;
        
        // elements 
        this.element = el;

        // templates 
        var templates = el && el.getAttribute('template');
        if (templates){
            templates = utils.toJson(templates) || templates;
            
            if (utils.is.str(templates)){
                templates = {'*':templates};
            }

            if (templates){
                this.addTemplate(templates);
            }

            el.removeAttribute('template');
        }

        // elements
        if (utils.is.either(this.elements, 'str,arr')){
            var elements  = utils.toArray(this.elements);
            this.elements = {};
            for (var i in elements){
                var k = elements[i];
                this.elements[k] = false;
            }
        }

        this.elements          = this.elements || {};
        this.elements.win      = window;
        this.elements.doc      = document;
        this.elements.html     = document.documentElement;
        this.elements.body     = document.body;
        this.elements.children = el ? utils.toArray(el.children) : [];

        cache.el       = el;
        cache.children = this.elements.children;

        if (classnames){
            self.addClass(classnames);
        }
        if (id){
            self.setId(id);
        }
        
        // update the html
        if (el && self.html){
            var selector   = _attr(el, args.htmlAttr);
            var target     = (selector ? utils.dom.get(selector, {'context':el}) : null) || el;
            var children   = target ? utils.toArray(target.children) : [];
            
            // update the children
            cache.el       = target;
            cache.children = this.elements.children = children;
        }

        // auto-template
        if (args.autoTemplate){
            var elements = this._nodes('[element]');
            utils.each(elements, function (el){
                var name     = el.getAttribute('element');
                var template = el.getAttribute('template');
                
                // it's a template, but no value specified
                if (name && template === ''){
                    el.setAttribute('template', name + '!inner');
                }
            });
        }

        this.setHtml(self.html);
        
        if (root){
            var el = utils.dom.get(this.element);
            root.appendChild(el);
        }
        
        var element = utils.dom.get(this.element);

        // auto-class
        if (element && args.autoClass){
            var alias = this.getAlias();
            var type  = this.getTypeClass();
            utils.el.addClass(element, [alias, 'type-' + type]);
        }

        element && utils.apply(_templates, [element], this);
        
        // change of selector for everything else
        var selector = _attr(el, args.elementAttr);
        if (selector){
            element = this.element = utils.dom.get(selector);

            if (args.useQuery){
                this.element = this.$(element);
            }
        }

        return element;
    }

    function _templates (el){
        var templates = this._nodes('template[id],[template]');

        this.each(templates, function (el){
            var id      = el.getAttribute('template') || el.getAttribute('id') || '*';
            var isInner = !!~id.indexOf('!inner');
            var remove  = !!~id.indexOf('!remove');
            el.removeAttribute('template');
            
            id = id.replace(/\!.+/, '').trim();
            
            this.addTemplate(id, el, isInner);

            if (remove){
                utils.dom.remove(el);
            }
        });
    };

    function _events (el){
        var self    = this.$self;
        var targets = this._nodes('[onclick], [onchange]');

        // check for [onclick] and [onchange] event, convert them if they are for the Class instance
        utils.each(targets, function (target){
            var event;
            if (event = _parse(target, 'onclick', 'on-click')){
                target.setAttribute('on-click', event.value);
                target.removeAttribute('onclick');
            }

            if (event = _parse(target, 'onchange', 'on-change')){
                target.setAttribute('on-change', event.value);
                target.removeAttribute('onchange');
            }
        });

        // listen to [on-click], [on-change]
        utils.dom.addEvent(el, '[on-click]:click, [on-click]:keyup, [on-change]:change', function (e){
            var type = e.type;

            // simulate "click"
            if (type === 'keyup' && e.key == 'Enter' && e.target.hasAttribute('on-click') && !utils.dom.is(e.target, 'button, [href], input, select, textarea')){
                type = 'click';
            }

            var parent = utils.dom.closest(e.target, '[is]');
            var link   = utils.dom.closest(e.originalTarget, 'a:not([href^="#"])');
            var value  = e.target.getAttribute('on-click') || e.target.getAttribute('on-change') || '';
            
            if ((parent && parent !== el && value[0] !== '#') || link) return;

            var event = _parse(e.target, 'on-' + type);
            event && event.callback(e);
        });

        // parse the event
        function _parse (target, name, key){
            var value = target.getAttribute(name);
            if (!value) return;
            
            var cache = utils.cache(target);
            var key   = key || name;

            if (cache[key]){
                return cache[key];
            }

            var ctx = null;
            if (value[0] === '#'){
                var pair = value.split(':');
                ctx   = pair[0];
                value = pair[1];
            }

            var action = utils.string.toAction(value, {
                'modifierSeparator': '!',
                'context'          : target
            });
            
            var callback = function (e){
                var context = __(ctx) || self.eventContext || self;
                
                if (!context[action.name]){
                    self.warn('Action "{{ name }}" doens\'t exists in context', {'name':action.name}, {'context':context});
                    return;
                }

                if ('prevent' in action.modifiers){
                    e.preventDefault();
                }
                if ('stop' in action.modifiers){
                    e.stopPropagation();
                }

                // save the last triggered element
                var trigger = self.$(target);
                
                if (self.elements)      self.elements.lastTrigger = trigger;
                if (context.elements)   context.elements.lastTrigger = trigger;

                // @todo add e maybe?
                utils.apply(context[action.name], action.params, context);
            };
            
            cache[key] = {
                'callback': callback,
                'value'   : value,
            };

            return cache[key];
        }
    };

    function _bind (el){
        var self    = this.$self;
        var targets = this._nodes('[bind]', {'includeSelf':true});
        var filters = self.bindFilters || null;
        
        var binds = utils.each(targets, function (target){
            var value    = target.getAttribute('bind');
            var template = target.getAttribute('bind-template') || target.innerHTML.replace(/(<!-- @(html|template))|(@(html|template) -->)/g, '');
            var action   = utils.string.toAction(value, {
                'modifierSeparator': '!',
                'context'          : target
            });

            var isSkipped = false;

            return function (){
                if (isSkipped) return;

                var value = self.get(action.name) || self[action.name] || self.$data;
                value = utils.apply(value, action.params, self, value);

                var html = '';
                if (~template.indexOf('{{') && utils.is(value)){
                    value = utils.is.obj(value) ? value : {'value':value};
                    html  = _tmpl(template, value, {
                        'context': self,
                        'filters': filters
                    });
                }else if (!utils.is.obj(value)){
                    html = (value || '').toString();
                }else{
                    html = template;
                }

                utils.el.html(target, html);
                utils.el.classnames(target, {'is-empty':!value});

                if ('once' in action.modifiers){
                    isSkipped = true;
                }
            };
        });

        this._element.bindings = binds;
    };

    function _tmpl (str, data, args){
        return window.Template ? Template.parse(str, data, args) : utils.string.replace(str, data, args);
    }

    this._nodes = function (selector, args){
        args                = args || {};
        args.context        = 'context' in args ? args.context : (this.$element.domContext !== null ? this.$element.domContext : this.element);
        args.includeSelf    = args.includeSelf || false;
        args.excludeClosest = 'excludeClosest' in args ? args.excludeClosest : this.$element.excludeClosest;
        args.remove         = 'remove' in args ? args.remove : false;

        // need the context to work properly
        if (!args.context){
            return [];
        }

        var elements = utils.dom.getAll(selector, {
            'alias'         : this.getAlias(),
            'context'       : args.context,
            'includeContext': args.includeSelf,
            'excludeClosest': args.excludeClosest,
        });

        if (args.remove){
            for (var i in elements){
                elements[i].parentNode.removeChild(elements[i]);
            }
        }

        return elements;
    };

    this._is = function (name, value, classname, element, key){
        var cache  = this._element || {};
        var target = utils.dom.get(element || this.element);

        // the key is used in case we need to trigger many "action" (eg. many loading items)
        key = key || '*';

        if (value !== undefined){
            cache[name] = cache[name] || {};

            if (cache[name][key] !== value){
                if (target){
                    if (value){
                        utils.dom.addClass(target, classname);
                    }else{
                        utils.dom.removeClass(target, classname);
                    }
                }
                
                if (value){
                    cache[name][key] = value;
                }else{
                    delete(cache[name][key]);
                }
            }

            if (utils.is.empty(cache[name])){
                cache[name] = false;
            }

            return this;
        }else{
            return !!cache[name];
        }
    };

	// init ------------------------------------------------------------------------------------------------------------
    this.init = function (selector, args, config){
        var self    = this.$self;
        var args    = this.$element || {};
        var element = self.element || (selector && utils.dom.get(selector)) || null;

        element = utils.dom.get(element);
        if (!utils.is.el(element)){
            element = null;
        }

        if (utils.is.obj(self.templates)){
            this.addTemplate(self.templates);
            delete(this.templates);
        }

        // automatically use Query if available
        if (args.useQuery === null){
            args.useQuery = !!window.Query;
        }

        // default selector
        if (!element && args.defaultSelector){
            element = utils.dom.get(args.defaultSelector);
        }
        
        // default tag to create
        if (!element && args.defaultTag){
            element = utils.dom.create(args.defaultTag);
        }
        
        // append to parent element
        if (element && !element.parentNode && args.parentNode){
            utils.dom.add(element, args.parentNode);
        }

        element = utils.apply(_element, [element, config], this);
        element && utils.apply(_events, [element], this);
        element && utils.apply(_bind, [element], this);

        if (element){
            utils.cache(element, '__CLASS__', this);
        }

        return this.element;
    };

	// methods: html ---------------------------------------------------------------------------------------------------
    this.setHtml = function (html, data){
        var self    = this.$self;
        var args    = this.$element;
        var cache   = this._element;
        var alias   = this.getAlias();
        var el      = cache.el;
        var replace = this._nodes('[replace]');

        replace = this.each(replace, {'reindex':true}, function (el){
            var id = el.getAttribute('replace');
            el.removeAttribute('replace');
            utils.dom.remove(el);

            return {
                '$id'   : '@' + id,
                '$value': el
            };
        });

        html = html || self.html;

        // original node
        this.elements.node = el;

        // update the html
        if (el && html){
            if (typeof html === 'object'){
                var node    = utils.dom.get(el);
                var classes = utils.dom.classnames(el);
                var strings = self.strings || {};

                // arrays will only change the html inside the element
                if (utils.is.arr(html)){
                    html = {'html':html};
                // object will replace the element
                }else{
                    var tag  = html.tag || el.tagName.toLowerCase();
                    node     = utils.dom.create(tag);
                    node     = utils.el.replace(el, node, {
                        'attrs'   : html.moveAttrs || false,
                        'class'   : html.moveClass || false,
                        'children': html.moveChildren || false
                    });

                    // move the [is] attribute
                    var is = el.getAttribute('is');
                    if (is){
                        node.setAttribute('is', is);
                        el.removeAttribute('is');
                    }

                    cache.el = node;
                }

                var children = cache.children || [];
                // var children = utils.toArray(cache.children || [], _child);

                // @todo add a way to change the "element/children" class and grouping
                data = utils.defaults(data || {}, {
                    '@node'      : el,
                    '@childNodes': children,
                    '@element'   : function (alias, e){
                        utils.el.addClass(el, '&--element', alias);
                        utils.el.attrs(el, {'element':'element'});
                        return el;
                    },
                    '@children' : function (alias, e){
                        var nodes = [];
                        for (var i in children){
                            nodes.push({
                                'attrs' : {'group':'child'},
                                'meta'  : {'child':children[i]},
                                'class' : '&--child &--child' + i,
                                'html'  : {
                                    'class': '&--child-inside',
                                    'html' : children[i],
                                }
                            });
                        }
                        return nodes;
                    }
                });
                
                // add replace nodes
                data = utils.defaults(data, replace);
                // add all the other strings
                data = utils.defaults(data, strings);

                html.alias   = alias;
                html.context = self;
                html.replace = data;

                utils.el.update(node, html);
                utils.el.addClass(node, classes);

                // update the element if it has replaced the original one
                if (utils.dom.contains(node, this.element) || !this.element.parentNode){
                    this.element = node;
                }
            // change the el.innerHTML
            }else if (utils.is.str(html)){
                utils.el.html(el, html);
            }
        }

        if (this.element){
            // hidden elements -------------------------------------------------
            args.hiddenNodes && this.parseHidden();
                        
            // clone elements --------------------------------------------------
            if (args.cloneNodes){
                var clones = this._nodes('[clone]');
                this.each(clones, function (n){
                    var selectors = n.getAttribute('clone');
                    var isReplace = !!~selectors.indexOf('!replace');

                    var html = this.each(selectors, function (selector){
                        var isInner = !!~selector.indexOf('!inner');
                        var context = !!~selector.indexOf('!child') ? this.element : null;
                        var sel     = selector.replace(/\!(.|\s)+$/, '');
                        var targets = utils.dom.getAll(sel, {'context':context});
                        return this.each(targets, function (t){ return isInner ? t.innerHTML : t.outerHTML; }).join('\n');
                    }).join('\n');
                    
                    if (isReplace){
                        utils.dom.add(html, 'after', n);
                        utils.dom.remove(n);
                    }else{
                        n.innerHTML = html;
                        n.removeAttribute('clone');
                    }
                });
            }
        }

        // elements ------------------------------------------------------------
        var element  = this.element || null;
        var elements = this.elements || [];

        // console.log(this.id, elements);

        // add default elements
        if (self.elements && !cache.isParsed){
            this.each(self.elements, function (v, i, a){
                // the element is already fetched (from "extract()") AND not a selector
                if (elements[i] && !utils.is.str(elements[i])) return;

                if (v){
                    elements[i] = element ? this._nodes(v, {'excludeClosest':false}) : false;
                }else{
                    elements[i] = false;
                }
            });
        }


        // extract "[element]" and "[group]"
        if (args.extractElements && element){
            var els = utils.el.extract(element, {
                'clean'         : true,
                'includeSelf'   : true,
                'alias'         : args.autoExtractClass ? alias : false,
                'excludeClosest': args.excludeClosest,
            });
            utils.extend(elements, els);
        }
        
        // convert to Query objects
        if (args.useQuery && !window.Query){
            this.$self.error('Trying to use Query class for Element Mixin, but Query class doens\'t exists');
        }else if (args.useQuery){
            var args = {'context':this, 'alias':alias};
            element  = new Query(element, args);
            elements = this.each(elements, function (el){ return new Query(el, args); });
        }
        
        this.element  = element;
        this.elements = elements;
        
        // update the cache el node
        cache.isParsed = true;

        return this.$self;
    };

    this.$ = function (els, update, single){
        if (utils.is.bool(update)){
            single = update;
            update = null;
        }
        if (single === undefined){
            single = utils.is.el(els) ? true : false;
        }

        var alias = this.getAlias();
        var ctx   = this.$self;

        if (utils.is.str(els)){
            update         = update || {};
            update.alias   = alias;
            update.context = ctx;
        }else if (update){
            update.alias   = alias;
            update.context = ctx;
        }

        var a = els;
        if (utils.is.str(els) && els.trim().match(/^[>+~]/)){
            els = utils.dom.getAll(els, {'context':this.element, 'alias':alias});
        }else{
            els = utils.dom.getAll(els, {'alias':alias});
        }
        
        if (update){
            this.each(els, function (el){ utils.dom.update(el, update); });
        }

        if (single){
            els = els[0];
        }

        if (window.Query){
            els = new Query(els, {'alias':alias, 'context':ctx});
        }
        
        return els;
    };

    this.parseHidden = function (el){
        el = el || this.element;

        if (!el) return;

        var hidden = this._nodes('[hidden],[hide]', {'context':el, 'includeSelf':true});
        this.each(hidden, function (n){ 
            var hidden = n.getAttribute('hidden');
            if (hidden !== 'true' && hidden !== 'hidden'){
                n.removeAttribute('hidden');
            }
            n.removeAttribute('hide');
        });
    };
    
    this.addClassnames = function (classnames){
        utils.dom.addClass(this.element, classnames);
        return this.$self;
    };
    
    this.removeClassnames = function (classnames){
        utils.dom.removeClass(this.element, classnames);
        return this.$self;
    };

    this.renderBindings = function (){
        var bindings = this._element.bindings || [];
        utils.each(bindings, function (binding){ 
            binding(); 
        });
    };

    this.addTemplate = function (id, template, args){
        if (utils.is.bool(args)){
            args = {'inner':args};
        }

        args       = args || {};
        args.inner = args.inner || false;
        args.data  = args.data || null;

        if (utils.is.obj(id)){
            for (var i in id){
                this.addTemplate(i, id[i], args);
            }
            return this;
        }

        var parent = null;
        var html   = null;
        var data   = {};

        if (utils.is.el(template, true)){
            template = utils.dom.get(template);
            data     = utils.dom.data(template);

            if (utils.is.el(template, 'template')){
                html     = template.innerHTML;
                parent   = template.parentNode;
            }else{
                parent   = args.inner ? template : template.parentNode;
                html     = args.inner ? template.innerHTML : template.outerHTML;
            }
        }else if (utils.is.str(template)){
            html = template;
        }

        if (args.data){
            utils.defaults(data, args.data);
        }

        this._templates[id] = {
            'parent': parent,
            'html'  : html,
            'data'  : data,
        };

        if (utils.is.el(template)){
            if (parent === template){
                parent.innerHTML = '';
            }else if (parent && parent.removeChild){
                parent.removeChild(template);
            }
        }

        return this;
    };

    this.template = function (key, data, args){
        if (utils.is.obj(key)){
            args = data;
            data = key;
            key  = '*';
        }

        // default template
        if (key === true){
            key = '*';
        }

        if (utils.is.either(args, 'bool,str')){
            args = {'return':args};
        }

        args        = args || {};
        args.parent = 'parent' in args ? args.parent : null;
        args.append = 'append' in args ? args.append : false;
        args.return = 'return' in args ? args.return : false;
        args.layout = 'layout' in args ? args.layout : false;
        args.warn   = 'warn' in args ? args.warn : false;

        var template = this._templates[key];
        if (!template){
            return (args.warn && this.warn('Template "{{ template }}" doens\'t exists', {
                'template' : key,
            }));
        }

        if (args.parent === null){
            args.parent = template.parent;
        }

        // just return the HTML, do not add to a parent
        if (args.return === true){
            args.return = 'html';
            args.parent = null;
        }

        var self    = this.$self;
        var filters = self.bindFilters || null;
        var tmpl    = args.layout ? utils.string.replace(args.layout, {'template':template.html}, {'fallback':null}) : template.html;
        var parent  = utils.dom.get(args.parent);
        var hasNodes= !!(args.return === 'node' || parent);
        var nodes   = [];
        var html    = '';

        if (utils.is(data)){
            var list = utils.is.arr(data) ? data : [data];
            var html = this.each(list, function (item, i){
                if (!utils.is.obj(item)){
                    item = {'value':item};
                }

                item['$index'] = i;

                var h = _tmpl(tmpl, item, {'filters':filters});
                var n = hasNodes ? utils.dom.getAll(h, {'text':true}) : [];

                nodes = nodes.concat(n);

                // @todo mayde add a warning if Template doesn't exists
                return h;
            }).join('\n');
        }else{
            html = _tmpl(tmpl, null, {'filters':filters});
        }

        // var nodes = hasNodes ? utils.dom.getAll(html, {'text':true}) : [];
        if (parent){
            !args.append && (parent.innerHTML = '');

            utils.dom.add(nodes, parent);

            if (html){
                utils.dom.removeClass(parent, CLASSES.IS_EMPTY);
            }else{
                utils.dom.addClass(parent, CLASSES.IS_EMPTY);
            }
        }

        if (args.return === 'object'){
            return {
                'html' : html,
                'nodes': nodes,
                'data' : template.data,
            };
        }else if (args.return === 'html'){
            return html;
        }else if (args.return === 'node'){
            return nodes[0];
        }else if (args.return === 'nodes'){
            return nodes;
        }else if (args.return === 'element'){
            return this.$(nodes);
        }else{
            return this;
        }
    };

    this.transition = function (items, args, callback){
        if (utils.is.fn(args)){
            args = {'callback':args};
        }

        args          = args || {};
        args.duration = args.duration || 300;
        args.delay    = args.delay || 0;
        args.easing   = args.easing || null;
        args.reverse  = args.reverse || false;
        args.callback = args.callback || callback;
        args.context  = args.context || this;
        args.clean    = 'clean' in args ? args.clean : false;

        var self     = this;
        var duration = utils.string.toDuration(args.duration) + utils.string.toDuration(args.delay);

        items = utils.is.arr(items) ? items : [items];

        function _style (index, transition){
            index = args.reverse ? 1 - index : index;

            for (var i in items){
                if (!items[i] || !items[i].el) continue;

                var item  = items[i];
                var el    = utils.dom.get(item.el);
                if (!el) continue;

                var style = item.style[index] || {};
                var clean = 'clean' in item ? item.clean : args.clean;
                var d     = utils.number.toDuration(item.duration || duration);
                var e     = utils._easing(item.easing || args.easing, true, 'linear');
                var delay = utils.number.toDuration(item.delay || args.delay || 0);
                var t     = 'all ' + d + ' ' + e + ' ' + delay;

                if (transition === false){
                    t = '';
                }

                // clean the styles
                if (transition === true && clean !== false){
                    var style = {'transition':''};

                    for (var ii in item.style){
                        for (var iii in item.style[ii]){
                            style[iii] = '';
                        }
                    }
                }else{
                    utils.dom.style(el, {'transition':t});
                }

                utils.dom.style(el, style);
            }
        }

        function _start (){
            utils.each(items, function (item){
                if (!item || !item.el) return;
                var el = utils.dom.get(item.el);
                el && (el.style.transition = '');
                el && utils.el.addClass(el, 'is-transitioning');
            });
        }

        function _end (){
            utils.apply(args.callback, null, args.context);
            utils.each(items, function (item){
                if (!item || !item.el) return;
                var el = utils.dom.get(item.el);
                el && (el.style.transition = '');
                el && utils.el.removeClass(el, 'is-transitioning');
            });
        }

        if (duration){
            utils.fn.all({'context':this}, 
                true,
                function (){ _style(0, false); _start(); }, // start style
                true,                                       // wait 1 animation frame
                function (){ _style(1); },                  // transition style
                duration,                                   // wait props.duration time
                function (){ _style(1, true); _end(); }     // end style                                    
            );
        }else{
            _done();
        }        
    };

    

    // medthos: states -------------------------------------------------------------------------------------------------
    this._overlayScrollpane = null;
    function overlay_onTouchStart (e){
        var scrollpane = this._overlayScrollpane = utils.dom.scrollParent(e.originalEvent.target, {'strict':true, 'fallback':null});
        if (!scrollpane) return;

        var scrollBottom = (scrollpane.scrollHeight - scrollpane.clientHeight) | 0;

        // @info little fix, so the scroll won't overflow, offset the scrollPosition to not be at the beginning or end
        if (scrollpane.scrollTop === 0){
            scrollpane.scrollTop = 1;
            // _js('offset TOP');
        }else if (scrollpane.scrollTop >= scrollBottom){
            scrollpane.scrollTop = scrollBottom - 1;
            // _js('offset BOTTOM');
        }
    }
    function overlay_onTouchMove (e){
        (!this._overlayScrollpane) && e.preventDefault();
    }


    this.isOverlay = function (value){
        var html = document.documentElement;

        if (typeof value === 'boolean'){
            var hasScroll  = (html.scrollHeight > html.clientHeight);
            var scrollTop  = window.pageYOffset;
            var count      = window._overlayCount || 0;

            if (value){
                count++;

                utils.dom.addClass(html, CLASSES.HAS_OVERLAY);
                hasScroll && utils.dom.addClass(html, CLASSES.HAS_SCROLL);

                // V1
                html.style.overflow = 'hidden';
                
                // V2
                // document.body.style.position = 'fixed';
                // document.body.style.top      = (-scrollTop) + 'px';
                // document.body.$scrollTop     = scrollTop;
                
                // V3
                // utils.dom.style(document.body, {
                //     'touch-action'       : 'none',
                //     'overflow-scrolling' : 'none',
                //     'overflow'           : 'hidden',
                //     'overscroll-behavior': 'none',
                // });

                // V4
                this.on(this.element, 'touchstart', overlay_onTouchStart);
                this.on(this.element, 'touchmove', overlay_onTouchMove);
            }else if (!--count){
                utils.dom.removeClass(html, CLASSES.HAS_OVERLAY);
                utils.dom.removeClass(html, CLASSES.HAS_SCROLL);

                // V1
                html.style.overflow = '';

                // V2
                // document.body.style.position = '';
                // document.body.style.top      = '';
                // window.scrollTo(0, document.body.$scrollTop);

                // V3
                // utils.dom.style(document.body, {
                //     'touch-action'       : '',
                //     'overflow-scrolling' : '',
                //     'overflow'           : '',
                //     'overscroll-behavior': '',
                // });

                // V4
                this.off(this.element, 'touchstart', overlay_onTouchStart);
                this.off(this.element, 'touchmove', overlay_onTouchMove);
            }

            window._overlayCount = count > 0 ? count : 0;

            return this.$self;
        }    
        
        return window._overlayCount && window._overlayCount > 0;
    };
 
    this.isAnimating = function (value){
        return this._is('isAnimating', value, CLASSES.IS_ANIMATING);
    };

    this.isLoading = function (value, target, key){
        // option to load many things at the same time
        return this._is('isLoading', value, CLASSES.IS_LOADING, target, key);
    };

    // methods ---------------------------------------------------------------------------------------------------------
    this.getAlias = function (){
        return this.$self.alias || this.$self.classname || this.$self.getTypeClass();
    };

    this.http = function (url, data, args, callback){
        var requests = this._element.requests;

        if (!url){
            var ctx = this;
            utils.each(requests, function (v){
                utils.media.cancel(v.request);
                v.loading && ctx.isLoading(false, v.loading, v.code);
            });
            this._element.requests = [];
            return this;
        }

        if (utils.is.fn(args)){
            args = {'callback':args};
        }
        if (utils.is.fn(data)){
            args = {'callback':data};
            data = {};
        }

        args          = args || {};
        args.queue    = args.queue || null;
        args.callback = args.callback || callback;
        args.loading  = 'loading' in args ? args.loading : (this.elements.loading || this.element);

        // @todo add delay/debounce
        var code = utils.string.random();

        if (this.applyFilters){
            url = this.applyFilters('http-url', url);
        }else{
            // TODO send error/warning log
        }

        args.loading && this.isLoading(true, args.loading, code);
        var request = utils.media.http(url, {
            'data'    : data,
            'queue'   : args.queue,
            'selector': args.selector,
            'context' : this,
            'callback': function (){
                args.loading && this.isLoading(false, args.loading, code);
                
                var aaa = utils.toArray(arguments);
                aaa[0] = this.applyFilters('http-response', aaa[0]);
                
                utils.apply(args.callback, aaa, this);

                // remove the current request
                utils.array.remove(requests, request);
            },
        });

        requests.push({
            'request': request,
            'loading': args.loading,
            'code'   : code,
        });

        return request;
    };
};
MIXINS.Collection = function (utils){
    this.init = function (){
        this.$self.$static.collection = this.$self.$static.collection || [];
        this.$self.$static.collection.push(this.$self);
    };

    this.destroy = function (){
        this.utils.array.remove(this.$self.$static.collection, this.$self);
    };

    this.collection = function (excludeSelf, callback){
        var self = this.$self;

        if (utils.is.fn(excludeSelf)){
            callback    = excludeSelf;
            excludeSelf = false;
        }

        if (utils.is.fn(callback)){
            self.each(self.$static.collection, function (item){
                if (excludeSelf && item === self) return;
                this.apply(callback, [item]);
            });
        }

        return self.$static.collection;
    }
};
var PROP_TYPES      = window.PROP_TYPES || {};
var PROP_CONDITIONS = window.PROP_CONDITIONS || {};

var Props = new Class('Props', function (utils){
    // constants -------------------------------------------------------------------------------------------------------
	var RE = {
		SIZES 		: /^(<|>|<=|>=)?(\d+)((?:\-)\d+)?(w|h|vh|vw|cw|ch|%)?$/,
	//	RELATIVE  	: /^([+-/*%!])\=(.+)/,
	};
    
    // static ----------------------------------------------------------------------------------------------------------
    this.$static = {
        'conditions'     : {},
        'types'          : {},
        'autoResizeItems': null,
    };
    
    this.$static.types = {
        '*' : function (){
            return function (v){ return v; }
        },
        'String' : function (){
            return function (v){
                return v === null || v === undefined ? '' : v.toString();
            };
        },
        'Number' : function (prop){
            prop.min 	= 'min' in prop ? prop.min : -Infinity;
			prop.max 	= 'max' in prop ? prop.max : Infinity;
			prop.modulus= 'modulus' in prop ? prop.modulus : 0;

            return function (v){
                v = utils.dom.toPx(v) || 0;

                // @todo relative values calculation. Not sure it's necessary since we can do "p.nbr += v"

                if (prop.modulus){
                    v = v % prop.modulus;
                }
                if (v < prop.min){
                    v = prop.min;
                }
                if (v > prop.max){
                    v = prop.max;
                }

                return v;
            };
        },
        'Boolean' : function (){
            return function (v){ return !!v; };
        },
        'Array' : function (prop){
            prop.separator = 'separator' in prop ? prop.separator : ',';

            return function (v){
                v = utils.toArray(v, prop.separator);
                v = utils.toValues(v);
                return v;
            };
        },
        'Function':function (prop, obj){
            return function (v){
                if (utils.is.str(v)){
                    v = (obj._context && obj._context[v]) || window[v];
                }
                return utils.is.fn(v) ? v : utils.fn.empty;
            }
		},
        'Object' : function (prop){
            prop.default = 'default' in prop ? prop.default : null;

            return function (v){
                if (utils.is.str(v)){
                    v = utils.toJson(v);
				}

                // make sure it's a valid object
                v = utils.is.obj(v) ? v : {};

                if (prop.default){
                    v = utils.extend(true, {}, prop.default, v);
                }

                return v;
            };
        },
        'Config' : function (prop){
            prop.namespace = prop.namespace || false;

            // keep the old props, merge them
            return function (v, o){
                o = o || {};

                if (utils.is.str(v)){
                    v = utils.toJson(v);
				}

                if (prop.namespace){
                    v = utils.object.namespace(v);
                }

                // make sure it's a valid object
                v = utils.is.obj(v) ? v : {};
                v = utils.extend(true, o, v);

                return v;
            }
        },
        'Namespace' : function (prop){
            prop.namespace = true;
            return this.Config(prop);
        },
        'Enum' : function (prop){
            if (utils.is.arr(prop.value)){
                prop.list  = prop.value[1];
                prop.value = prop.value[0];
            }
            
            return function (v){
                var isFound = false;

                for (var i in prop.list){
					var item = prop.list[i];
					if ((item == v) || (!utils.is.invalid(v) && v.constructor === item)){
						isFound = true;
					}
				}

                if (!isFound){
					utils.warn('Setting prop "{key}" to "{value}" isn\'t valid, needs to be in the ENUM ({options})', {
						'key' 		: prop.name,
						'value'		: v,
						'options'	: utils.array.join(prop.list, {'separator':', '})
					});

					return null;
				}

				return v;
            };
        },
        'Class' : function (prop){
            prop.class = prop.class ? prop.class : window[prop.className];

            if (!prop.class){
                utils.error('The Class "{name}" couldn\'t be fun', {
                    'name' : prop.className || '?',
                });
            }

            return function (v){
                if (v instanceof prop.class){
                    return v;
                }

                // if it's a string, try to transform it to an array of arguments
                if (typeof v === 'string'){
                    v = utils.toValue(v, {'json':true});
                }

                if (!utils.is.arr(v)){
                    v = [v];
                }

                // initialize a Class instance
                v = new (Function.prototype.bind.apply(prop.class, [null].concat(v)));
                
                return v;
            };
        },
        'Element' : function (prop){
            prop.context= prop.context || document.documentElement;
            prop.single = 'single' in prop ? prop.single : true;
            prop.query  = 'query' in prop ? prop.query : false;

            return function (v){
                if (utils.is.el(v)){
                    return v;
                }

                if (prop.query){
                    return new Query(v);
                }else{
                    v = utils.dom.get(v, {
                        'context': prop.context,
                        'single' : prop.single,
                    });
                }

                return v;
            }
        },
        'Elements' : function (prop){
            prop.single = false;
            return this.Element(prop);
        },
        'Query' : function (prop){
            prop.query = true;
            return this.Element(prop);
        },
        'Value2' : function (prop){
            return _toXValues(prop, 'to2Values');
        },
        'Value4' : function (prop){
            return _toXValues(prop, 'to4Values');
        },
        'Number2' : function (prop){
            return _toXValues(prop, 'to2Numbers', 0);
        },
        'Number4' : function (prop){
            return _toXValues(prop, 'to4Numbers', 0);
        },
        'Date' : function (){
            return function (v){
				return utils.date.get(v, {'time':false});
			}
        },
        'DateTime' : function (){
            return function (v){
				return utils.date.get(v);
			}
        },
        'Color' : function (){
            return function (v){
                // @todo deal with colors more in depth 
				return utils.toValue(v);
			}
        },
        'Angle' : function (prop, obj){
            prop.modulus = 360;
            return this.Number(obj, prop);
        },
        'Ratio' : function (){
            return function (v){
                return utils.math.get(v, {
                    'min'     : 0,
                    'max'     : 1,
                    'decimals': true,
                });
            }
        },
        'Duration' : function (){
            return function (v){
                return utils.string.toDuration(v);
            }
        },
        'Bytes' : function (){
            return function (v){
                return utils.string.toBytes(v);
            }
        },
        'Easing' : function (prop, obj){
            return function (v){
                if (utils.is.fn(v)){
                    return v;
                }
                if (v in utils.easing.js){
					return utils.easing.js[v];
				}else{
                    return obj.error('Easing "{name}" doens\'t exists', {
                        'name' : v
                    });
                }
			}
        },
        // 'CssVar' : function (prop, obj){
        //     return function (v){
        //         var el = obj._element;
                
        // doesnt work right now

        //         return utils.el.var(el, v);
		// 	}
        // },
        'Alias' : function (prop, obj){
            prop.alias    = 'alias' in prop ? prop.alias : prop.value;
            prop.value    = obj[prop.alias];
            prop.fallback = 'fallback' in prop ? prop.fallback : null;

            return {
                'get':function (){
                    var v = utils.object.resolve(obj, prop.alias)
                    return v === undefined ? prop.fallback : v;
                },
                'set':function (v){
                    utils.object.resolve(obj, prop.alias, {'value':v});
                    return v;
                }
            }
        },
        'Computed' : function (props, obj){
            // @todo
        },
        'Shortcut' : function (){}, // shortcut is to represent multiple props, like css border for borderStyle,borderColor,borderWidth
    };

    this.$static.addType = function (key, callback){
		if (this.types[key] !== undefined){
			return this.error('Can\'t add the "{type}" type, it already exists', {'type':key});
		}
		this.types[key] = callback;
	};

    this.$static.addCondition = function (key, callback){
        if (this.conditions[key] !== undefined){
			return this.error('Can\'t add the "{key}" condition since it already exists', {'condition':key});
		}
		this.conditions[key] = callback;
    };
    
    this.$static.addAutoResize = function (item){
        var self = this;

        if (!this.autoResizeItems){
            this.autoResizeItems = [];

            window.addEventListener('resize', function (){
                for (var i in self.autoResizeItems){
                    self.autoResizeItems[i].invalidate();
                }
            });
        }

        this.autoResizeItems.push(item);
    };

    this.$static.removeAutoResize = function (item){
        if (this.autoResizeItems){
            utils.array.remove(this.autoResizeItems, item);
        }
    };

    // properties ------------------------------------------------------------------------------------------------------
    this._element       = null;
    this._context       = null;
    this._hasConditions = false;
    this._conditions    = null;   // cached results of the conditions
    this._keys          = {};     // the current condition key the values are set at 
    this._props         = {};
    this._auto          = true;   // automatically invalidate the props on window resize
    
    // init ------------------------------------------------------------------------------------------------------------
    this.init = function (props, args){
        args = args || {};

        this.element       = args.element || null;
        this.context       = args.context || null;
        this._onInvalidate = args.onInvalidate || null;
        this._auto         = 'auto' in args ? args.auto : true;
        
        if (this._auto){
            this.$static.addAutoResize(this);
        }

        this.add(props);
    };

    this.destroy = function (){
        if (this._auto){
            this.$static.removeAutoResize(this);
        }
    };

    // private ---------------------------------------------------------------------------------------------------------
    function _toXValues (prop, name, fallback){
        prop.fallback  = 'fallback' in prop ? prop.fallback : (fallback === undefined ? null : fallback);
        prop.separator = prop.separator || ',';

        return function (v){
            return utils.array[name](v, {
                'fallback' : prop.fallback,
                'separator': prop.separator,
            });
        };
    }

    this._toSizeCondition = function (condition){
		var match = condition.match(RE.SIZES);
		if (!match){
			return;
		}

        var nbr1    = parseFloat(match[2]) || 0;
        var nbr2    = parseFloat((match[3] || '').toString().replace('-', ''));
        var compare = match[1];
        var unit    = match[4] || 'w';
        var min     = 0;
        var max     = 0;

		if (unit === '%'){
			unit = 'vw';
		}

		if (!compare && !isNaN(nbr1) && !isNaN(nbr2)){
			compare = '<=>';
		}else if (!compare){
			compare = '<=';
		}

		if (compare === '<'){
			max = nbr1 - 1;
		}else if (compare === '<='){
			max = nbr1;
		}else if (compare === '>'){
			min = nbr1 + 1;
			max = Infinity;
		}else if (compare === '>='){
			min = nbr1;
			max = Infinity;
		}else if (compare === '<=>'){
			min = nbr1;
			max = nbr2;
		}

		return function (el){
            var doc  = document.documentElement;
            var el   = el || doc;
			var size = 0;

			// element width
			if (unit === 'cw'){
				size = el.clientWidth;
			// element height
			}else if (unit === 'ch'){
				size = el.clientHeight;
			// view width percentage
			}else if (unit === 'vw'){
				size = el.clientWidth / doc.clientWidth * 100;
			// view height percentage
			}else if (unit === 'vh'){
				size = el.clientHeight / doc.clientHeight * 100;
			// view width
			}else if (unit === 'w'){
				size = doc.clientWidth;
			// view height
			}else if (unit === 'h'){
				size = doc.clientHeight;
			}

			return size >= min && size <= max;
		}
	};
    
    this._getConditionKey = function (prop){
        var key = '*';

        if (prop.conditions){
            // make sure this._conditions isn't null
            this._conditions = this._conditions || {};

            for (var i in prop.conditions){
                var c       = prop.conditions[i];
                var isMatch = null;

                if (c.key in this._conditions){
                    isMatch = this._conditions[c.key];
                }else{
                    var condition = this.$static.conditions[c.key];
                    isMatch = this._conditions[c.key] = utils.apply(condition, [this._element], this._context);
                }

                if (isMatch === c.isEqual){
                    key = i;
                    // break; // match the last item (not the first condition)
                }
            }            
        }
        return key;
    };

    this._getProp = function (prop, key){
        var willCache = key === undefined;
        var key       = key || this._keys[prop.name] || this._getConditionKey(prop);
        var value     = prop.values[key];

        if (utils.is.fn(prop.get)){
            value = prop.get();
        }

        if (willCache){
            this._keys[prop.name] = key;
        }

        return value;
    };

    this._setProp = function (prop, value, key){
        // console.log(this.id, prop, value);

        var willCache = key === undefined;
        var key = key || this._keys[prop.name] || this._getConditionKey(prop);

        // standerize the value to NULL if it's enabled
        if (prop.nullable && (value === null || value === undefined)){
            value = null;
        }else{
            value = prop.set(value, prop.values[key]);
        }

        if (willCache){
            this._keys[prop.name] = key;
        }
        
        prop.values[key] = value;
    };

    // get/set ---------------------------------------------------------------------------------------------------------
    this.$get.context = function (){
        return this._context;
    };
    this.$set.context = function (v){
        this._context = v;
        this.when('ready') && this.invalidate();
    };

    this.$get.element = function (){
        return this._element;
    };
    this.$set.element = function (v){
        this._element = utils.dom.get(v) || null;
        this.when('ready') && this.invalidate();
    };

    this.$get.dynamic = function (){

    };

    // methods ---------------------------------------------------------------------------------------------------------
    this.add = function (name, prop){
        var props = utils.toSet(name, prop);
        var self  = this;
            
        for (var i in props){
            var type = null;
            var name = i;
            var prop = props[i];

            if (~name.indexOf(':')){
                var pair = name.split(':');
                name = pair[0];
                type = pair[1];
            }

            // special shortcut, if the type is set in the name, then the prop can be right away a value
            if (type && utils.is.obj(prop, true) && !('value' in prop)){
                prop = {'value':prop};
            }

            // skip re-creating the same prop, set the value instead
            if (name in this._props){
                this.set(name, prop);
                return;
            }

            // type decoding -------------------------------------------------------
            // type is specified in the prop
            if (utils.is.obj(prop, true) && 'type' in prop){
                type = prop.type;
            }
            // type is a function/type
            if (!type && typeof prop === 'function'){
                type = prop;
                prop = {}; 
            }
            // check if the type is already set in the "types"
            if (typeof type === 'function' && type.name in this.$static.types){
                type = type.name;
            }
            
            // check if it's a class/function
            if (type && !(type in this.$static.types) && type in window){
                prop = prop || {};

                // make sure it's a plain object
                if (!utils.is.obj(prop, true)){
                    prop = {'value':prop};
                }

                prop.className = type;
                type = 'Class';
            }

            if (!utils.is.obj(prop, true)){
                prop = {'value':prop};
            }

            // ---------------------------------------------------------------------
            prop            = prop || {};
            prop.name       = name;
            prop.type       = type || '*';
            prop.nullable   = 'nullable' in prop ? prop.nullable : true;   // values can be null OR never
            prop.value      = 'value' in prop ? prop.value : null;         // default value
            prop.format     = 'format' in prop ? prop.format : null;       // custom format function
            prop.conditions = null;
            prop.values     = {};
            
            //var type = prop.type.toLowerCase();
            if (!this.$static.types[prop.type]){
                return this.error('The type "{type}" doens\'t exists', {
                    'type' : prop.type,
                });
            }
            
            // either return a get and set, or just a set function
            var transform = this.$static.types[prop.type](prop, this);
            if (utils.is.obj(transform)){
                prop.get = transform.get;
                prop.set = transform.set;
            }else{
                prop.set = transform;
            }
            
            this._setProp(prop, prop.value);

            // add the getter/setter shortcuts
            _add(prop);
            
            this._props[name] = prop;
        }

        function _add (prop){
            Object.defineProperty(self, prop.name, {
                'get' : function (){ return self._getProp(prop); },
                'set' : function (v){ return self._setProp(prop, v); },
            });
        }

        return prop;
    };

    this.set = function (name, value, defaultCondition){
        var values = utils.toSet(name, value);
        
        for (var i in values){
            var pair      = i.split(':');
			var name      = pair[0];
			var conditions= utils.toArray(pair[1] || defaultCondition);
			var value     = values[i];
            var prop      = this._props[name];
			
            // setting a new prop that doesn't exists, add it has a normal
            if (!prop){
                // if the value was there before, we delete it
                delete(this[name]);
                prop = this.add(name, {'value':null});
            }

            // no special conditions, means setting the current matched key
            if (!conditions.length){
                this._setProp(prop, value);
            }
            
            // go through the conditions to set them
            var ii = 0, ll = conditions.length;
            for (;ii<ll;++ii){
                var key   = conditions[ii];
                var isNot = key[0] === '!';

                // if it's the default condition
                if (key === '*'){
                    this._setProp(prop, value, '*');
                    continue;
                }else{
                    this.set('dynamic', true);
                }

                key = key.replace('!', '');

                var condition = null;
                if (!(key in this.$static.conditions)){
                    condition = this._toSizeCondition(key);
                    
                    if (!condition){
                        this.warn('Condition "{key}" does not exists', {'name':key});
                        continue;
                    }else{
                        this.$static.addCondition(key, condition);
                    }
                }

                var cKey = (isNot ? '!' : '') + key;
                prop.conditions       = prop.conditions || {};
                prop.conditions[cKey] = {'key':key, 'isEqual':!isNot};
                
                this._setProp(prop, value, cKey);
            }

            this._keys[prop.name] = null;
            this._hasConditions = true;
        }
    };
    
    this.invalidate = function (){
        var refresh = this._hasConditions && this._conditions;
        
        this._conditions = null;
        this._keys       = {};

        if (refresh){
            utils.apply(this._onInvalidate, [this], this.context);
        }
    };

    this.values = function (){
        var values = {};

        for (var i in this._props){
            values[i] = this._getProp(this._props[i]);
        }

        // get the custom values that aren't dynamic
        for (var i in this){
            if (i[0] === '$' || i[0] === '_' || i === 'destroy' || !this.hasOwnProperty(i)) continue;
            values[i] = this[i];
        }

        return values;
    };

    // init ------------------------------------------------------------------------------------------------------------
	for (var name in PROP_TYPES){
		this.$static.addType(name, PROP_TYPES[name]);
	}
	for (var name in PROP_CONDITIONS){
		this.$static.addCondition(name, PROP_CONDITIONS[name]);
	}    
});

var PROPS = window.PROPS || {};
MIXINS.Props = function (utils){
	// properties ------------------------------------------------------------------------------------------------------
    this.$merge = 'props,$props';
    this.$props = {
        'excludeClosest' : null,
    };

	// private ---------------------------------------------------------------------------------------------------------
    function _props (self, inline){
		var types   = self.getTypes();
		var classes = self.getClasses();
		var id      = self.getId();

        if (!classes.length){
            classes = ['default'];
        }

        var keys  = [];
        var props = {};
        
        // types
        for (var i in types){
			keys.push(types[i]);
		};

		// classes
        for (var i in classes){
			keys.push('.' + classes[i]);

            for (var ii in types){
                keys.push(types[ii] + '.' + classes[i]);
            };
		};
		// id
		if (id){
			keys.push('#' + id);
		}

		// general settings
        utils.extend(props, PROPS['*'] || {});

		for (var i=0, l=keys.length; i<l; ++i){
			var key = keys[i];
			var p 	= PROPS[key];
			if (!p) continue;
			utils.extend(true, props, p);
		}

        utils.extend(true, props, inline || {});

        return props;
    };

    function _element (element){
        element = utils.dom.get(element);
        if (!element){
            return this.$self;
        }

        //this.$props.element = element;
        var inline = utils.el.data(element, undefined, undefined, false);
        var script = utils.dom.get('script[type="json/props"]', {
            'context'       : element,
            'skipClosest'   : this.$props.excludeClosest,
        });

        if (script){
            script = script.innerHTML;
            script = utils.toJson(script);
        }

        var props = utils.extend({}, inline || {}, script || {});
        this.props.element = element;
        this.props.set(props);

        return props;
    };

	// init ------------------------------------------------------------------------------------------------------------
    this.init = function (selector, props){
        var self    = this.$self;
        var element = ('element' in self ? self.element : (selector && utils.dom.get(selector))) || null;

        // separate the props (the one with definition in the title)
        var start  = {};
        var update = {};
        for (var i in self.props){
            if (~i.indexOf(':')){
                start[i] = self.props[i];
            }else{
                update[i] = self.props[i];
            }
        }        

        this.props = new Props(start, {'context':self, 'onInvalidate':self.onPropsInvalidate});
        this.props.set(update);

        // add props by type/class/id
        var props = _props(self, props);
        this.props.set(props);

        if (element){
            _element.call(this, element);
        }

        // replace the $props object to the $$props function
        this.$props = this.$$props;
    };

    this.$$props = function (args){
        args = args || {};

        if ('context' in args) this.props.context = args.context;
        if ('element' in args) _element.call(this, args.element);

        return this.$self;
    };
};
var Query = Core.Query = new Class('Query:Array', function (utils){
	// static ----------------------------------------------------------------------------------------------------------
    this.$static.shorthand = '$$';
    
	this.$static.init = function (){
        this.noConflict(this.shorthand);
	};

	this.$static.noConflict = function (shorthand){
        var klass = this;
        delete(window[this.shorthand]);
		this.shorthand = shorthand;
		window[shorthand] = function (selector){ return new klass(selector); };
    };	
    
    // props -----------------------------------------------------------------------------------------------------------
    this.context = null;
	this.element = null; // 
    this.alias   = '';

	// init ------------------------------------------------------------------------------------------------------------
    this.init = function (selector, args){
        if (args && (args.ctx === undefined && args.context === undefined && args.alias === undefined)){
            this.error('The params seems like the old version of it (selector, context, alias) and should be (selector, args)');
        }

        args         = args || {};
        this.context = args.context || null;
        this.alias   = args.alias || '';
		
        this.add(false, selector);
    };

    // private ---------------------------------------------------------------------------------------------------------
	this._toSelector = function (selector, isClassname){
		if (!this.alias || !selector) return selector;

		isClassname = isClassname === undefined ? true : isClassname;

		var alias = (isClassname ? '.' : '') + this.alias;
		var _get  = function (v){ 
			var isString = utils.is.str(v);

			// it's HTML (so parse only the class attributes)
			if (isString && v.trim()[0] === '<'){
				return v.replace(/class="[^"]+"/g, function (m){
					return m.replace(/\&/g, alias);
				});
			// normal string
			}else if (isString){
				return v.replace(/\&/g, alias);
			}else{
				return v;
			}
		};

		if (utils.is.arr(selector)){
			var i=0, l=selector.length;
			for (;i<l;++i){
				selector[i] = _get(selector[i]);
			}
		}else if (utils.is.obj(selector, true)){
			var s = {}, i, k;
			for (i in selector){
				k   = _get(i);
				s[k]= selector[i];
			}
			selector = s;
		}else{
			selector = _get(selector);
		}

		return selector;
	};

    this._create = function (items){
        if (items === undefined){
            items = this;
        }

        if (utils.is.fn(items)){
            var callback = items;
            var items    = this;
            var elements = [];
            
            utils.each(items, function (el, i){
                var response = callback.call(this, el, i);
                if (response instanceof Array){
                    elements = elements.concat(response);
                }else if (response){
                    elements.push(response);
                }
            });

            items = elements;
        }else{
            items = utils.toArray(items);
        }

        return new this.$static(items, {
			'alias'  : this.alias,
			'context': this.context
		});
    };

    this._walk = function (el, key, callback){
        while (el && el !== document){
            if (el.nodeType === 1 && utils.is.fn(callback)){
                var response = callback.apply(this, [el]);
                if (response === BREAK){
                    break;
                }
            }
            el = el[key];
        }
    };

    this._is = function (el, selector, isStrict){
        if (selector instanceof this.$static){
            selector = selector[0];
        }
        return (!selector && !isStrict) || (selector && utils.dom.is(el, selector)) ? el : undefined;
    };

	this._el = function (node){
		return utils.is.el(node);
	};
    
    this._set = function (key, value, callback, onlyEl){
        var set = utils.toSet(key, value);

        if (set){
            return this.each(function (el){ callback(el, set); }, onlyEl);
        }else if (this[0]){
			if (!onlyEl || (onlyEl && this._el(this[0]))){
				if (key){
					return callback(this[0], key);
				}else{
					return callback(this[0]) || {};
				}
			}

			return null;
        }else{
            return key !== undefined || value !== undefined ? undefined : {};
        }
    }

    this._toFragment = function (els, isClone, list){
        var frag = document.createDocumentFragment();
        var i=0, l=els.length, el;
        
        for(;i<l;++i){
            el = isClone ? els[i].cloneNode(true) : els[i];
            frag.appendChild(el);

            if (list instanceof Array){
                list.push(el);
            }
        }

        return frag;
    }

    this._clone = function (selector, callback){
        var source = utils.dom.getAll(selector);
        var self   = this;
        var els;

        this.each(function (el, i, a){
			els = self._toFragment(source, !a.isFirst);

            if (utils.is.str(callback)){
                utils.el.add(els, callback, el);
            }else{
                callback.apply(this, [el, els]);
            }
        });

        return this;
    };

    this._cloneTo = function (selector, callback){
        var targets = utils.dom.getAll(selector);
        var clones  = [];
        var i=0, l=targets.length, el, els;
        
        for(;i<l;++i){
            els = this._toFragment(this, i !== l-1, clones);
            el  = targets[i];

            if (utils.is.str(callback)){
                utils.el.add(els, callback, el);
            }else{
                callback.apply(this, [els, el]);
            }
        }

        return this._create(clones);
	};
	
    // loops -----------------------------------------------------------------------------------------------------------
    this.each = function (args, callback, onlyEl){
        if (utils.is.fn(args)){
			onlyEl   = callback;
			callback = args;
			args     = {};
		}
		if (!utils.is.fn(callback)){
			return this;
		}
		this.map(args, callback, onlyEl);
		return this;
    };

    this.map = function (args, callback, onlyEl){
        if (utils.is.fn(args)){
			onlyEl   = callback;
            callback = args;
			args 	 = {};
        }else if (utils.is.bool(args)){
            args 	 = {'query':args};
        }

		args.alias   = 'query' in args ? args.query : this.alias;
		args.context = 'context' in args ? args.context : (this.context || this);
		args.query 	 = 'query' in args ? args.query : false;

		if (typeof callback !== 'function'){
			return [];
		}

		var r, q;
        var items = utils.each(this, {'context':this, 'filter':true}, function (el, i, a){
			if (args.query){
                q = utils.cache(el, 'query');

                // cache the query in the element, so we can reuse them
                if (!q){
                    q = new this.$static(el);
                    utils.cache(el, 'query', q);
                }
                
				q.alias   = this.alias;
                q.context = args.context;
                el        = q;
			}

			if (!onlyEl || (onlyEl && this._el(el))){
            	r = callback.apply(args.context, [el, i, a]);
				return r;
			}
			return false;
		});

		return items;
    };

	/*
	this.call = function (callback){
		var args 	= utils.toArray(arguments).slice(1);
		//var context = this.context;

		return this.each(function (el){
			var callback = utils.el.cache(el, key) || el[key];
			if (typeof callback === 'function'){
				callback.apply(context, args);
			}
		});
	}
	*/

    // fetch -----------------------------------------------------------------------------------------------------------
    this.add = function (isNewQuery, selector){
        if (selector === undefined){
            selector   = isNewQuery;
            isNewQuery = true;
        }
        if (isNewQuery === undefined){
            isNewQuery = true;
        }

		selector = this._toSelector(selector);
		
		var els = utils.dom.getAll(selector);

		if (isNewQuery){
            els = this.get().concat(els);
            els = this._create(els);
            return els;
		}else{
            var i=0, l=els.length, el;
			for (; i<l; ++i){
                el = els[i];                
				if (el && !~this.indexOf(el)){
					this.push(el);
				}
			}
		}

        return this;
    };

	this.copy = function (){
		return this._create(this);
	};

    this.get = function (search){
        if (search === undefined){
			return utils.toArray(this);
		// get a value of the elements
		}else if (utils.is.fn(search)){
			var values = [];
			this.each(function (el){
				values.push(search(el));
			});
			return values;
		}else{
			return this[search];
		}
    };

    this.find = function (isSelf, selector){
        if (selector === undefined){
			selector = isSelf;
			isSelf   = false;
		}

		selector = this._toSelector(selector);

		return this._create(function (el){
			var els = utils.dom.getAll(selector, {'context':el});

			if (isSelf && this._is(el, selector)){
				els.unshift(el);
			}

			return els;
		});
    };

    this.filter = function (selector){
		selector = this._toSelector(selector);

        return this._create(function (el){
			return this._is(el, selector);
		});
    };

    this.children = function (includeText, selector){
		if (!utils.is.bool(includeText)){
            selector    = includeText;
			includeText = false;
		}

		selector = this._toSelector(selector);

		return this._create(function (el){
            return utils.el.children(el, {'text':includeText, 'selector':selector});
		});
	};

    this.parent = function (selector){
		selector = this._toSelector(selector);
		
        return this._create(function (el){
			return this._is(el.parentNode, selector);
		});
    };

    this.parents = function (selector, untilSelector, includeSelf){
		selector      = this._toSelector(selector);
		untilSelector = this._toSelector(untilSelector);

		return this._create(function (el){
			var parents = [];

			this._walk(includeSelf ? el : el.parentNode, 'parentNode', function (parent){
				if (this._is(parent, selector)){
					parents.push(parent);
				}
				if (this._is(parent, untilSelector, true)){
					return BREAK;
				}
			});

			return parents;
		});
	};

    this.closest = function (selector, untilSelector){
		selector      = this._toSelector(selector);
		untilSelector = this._toSelector(untilSelector);

		var until = utils.dom.get(untilSelector);
		return this._create(function (el){
			return utils.el.closest(el, selector, until);
		});
    };

	this.siblings = function (selector){
		selector = this._toSelector(selector);
        return this._create(function (el){
			return utils.el.siblings(el, {'selector':selector});
		});
	};

    this.next = function (selector){
		selector = this._toSelector(selector);
        return this._create(function (el){
			return this._is(el.nextElementSibling, selector);
		});
    };

	this.nextAll = function (selector){
		selector = this._toSelector(selector);
        return this._create(function (el){
			return utils.el.siblings(el, {'previous':false, 'selector':selector});
		});
    };

    this.prev = function (selector){
		selector = this._toSelector(selector);
        return this._create(function (el){
			return this._is(el.previousElementSibling, selector);
		});
    };

	this.prevAll = function (selector){
		selector = this._toSelector(selector);
        return this._create(function (el){
			return utils.el.siblings(el, {'next':false, 'selector':selector});
		});
	};

    this.not = function (selector){
		selector = this._toSelector(selector);
		return this._create(function (el){
			return this._is(el, selector) ? false : el;
		});
	};

	this.eq = function (index, loop){
        if (index === 'first'){
            index = 0;
        }else if (index === 'last'){
            index = this.length - 1;
        }

		if (loop){
			if (index < 0){
				index = this.length + index;
			}

			index = index % this.length;
		}

		var el = this[index];

        return this._create([el]);
	};

	this.first = function (count){
		if (count){
			return this._create(this.slice(0, count));
		}else{
			return this.eq('first');
		}
	};

	this.last = function (count){
		if (count){
			return this._create(this.slice(count * -1));
		}else{
			return this.eq('last');
		}
	};

	this.slice = function (index, count, args){
		if (utils.is.bool(args)){
			args = {'clone':args};
		}

		args           = args || {};
		args.clone     = 'clone' in args ? args.clone : false;
		args.indexAttr = args.indexAttr || 'sourceIndex';

		if (count === undefined){
			count = this.length;
		}
		
		var els  = [];
		var from = utils.math.loop(index, 0, this.length - 1);

		// go backward
		if (count < 0){
			count *= -1;
			from  = from - count + 1;
			from  = utils.math.loop(from, 0, this.length - 1);
		}
		
		var to = from + count;
		
		// inverse the to/from if to is under from
		if (to < from){
			from = [to, to = from][0];
		}

		// "to" is more like the "to + 1", because in the for loop we're going less than 
		// TODO maybe this better, make the "to" the real value

		var i = 0, l = to - from, el;
		for (; i<l; ++i){
			el = utils.array.loop(this, from + i);
			el = args.clone ? el.cloneNode(true) : el;

			var data = utils.toSet(args.indexAttr, from + i);
			utils.cache(el, data);

			els.push(el);
		}

		return this._create(els);
	};

	this.extract = function (args){
		var items = {};

		// @todo make this work with ALL items()

		if (this[0]){

			args       = args || {};
			args.clean = true;
			items = utils.el.extract(this[0], args);
		}

		return items;
	};

    // insert/remove ---------------------------------------------------------------------------------------------------
	this.remove = function (){
		return this.each(function (el){
			utils.els.remove(el);
		});
	};

	this.append = function (selector){
		selector = this._toSelector(selector);
		return this._clone(selector, 'append');
	};

	this.appendTo = function (selector){
		selector = this._toSelector(selector);
		return this._cloneTo(selector, 'append');
	};

	this.prepend = function (selector){
		selector = this._toSelector(selector);
		return this._clone(selector, 'prepend');
	};

	this.prependTo = function (selector){
		selector = this._toSelector(selector);
		return this._cloneTo(selector, 'prepend');
	};

	this.before = function (selector){
		selector = this._toSelector(selector);
		return this._clone(selector, 'before');
	};

	this.insertBefore = function (selector){
		selector = this._toSelector(selector);
		return this._cloneTo(selector, 'before');
	};

	this.after = function (selector){
		selector = this._toSelector(selector);
		return this._clone(selector, 'after');
	};

	this.insertAfter = function (selector){
		selector = this._toSelector(selector);
		return this._cloneTo(selector, 'after');
	};
	
	this.wrap = function (selector){
		selector = this._toSelector(selector);
		return this._clone(selector, 'wrap');
	};

	// TODO maybe rename to replaceWith
	
	this.replace = function (selector){
		selector = this._toSelector(selector);
		// @todo have option to keep the children
		return this._clone(selector, 'replace');
	};
	
	// @todo wrapInner, wrapAll ...

	this.clone = function (withEventsCache){
		return this._create(function (el){
			return utils.el.clone(el, {'events':withEventsCache});
		});
	};	

    // validation ------------------------------------------------------------------------------------------------------
    this.is = function (selector, allValid){
		selector = this._toSelector(selector);

		var self    = this;
		var isValid = null;
		this.each(function (el){
			var valid = self._is(el, selector);
			if (allValid && !valid){
				isValid = false;
			}else if (isValid === null && valid){
				isValid = true;
			}
		});

		return !!isValid;
	};

    this.contains = function (selector, allValid){
		selector = this._toSelector(selector);

		var isValid = null;
		this.each(this, function (el){
			var children = utils.dom.getAll(selector, {'context':el});
			var found 	 = 0;
			var i, child;

			for (i in children){
				child = children[i];
				if (utils.el.contains(el, child)){
					found++;
				}
			}

			var isMatch = found && (found >= children.length);
			if (!allValid && isMatch){
				isValid = true;
				return BREAK;
			}else if (allValid){
				p(found, children.length);
				if (isMatch){
					isValid = true;
				}else{
					isValid = false;
					return BREAK;
				}
			}
		});

		return !!isValid;
	};
	
	this.visible = function (allValid){
		var isValid = null;

		this.each(function (el){
			var valid = utils.el.isVisible(el);
			
			if (allValid && !valid){
				isValid = false;
			}else if (isValid === null && valid){
				isValid = true;
			}
		});

		return !!isValid;
	};

    // props -----------------------------------------------------------------------------------------------------------
    this.tag = function (replace){
		if (replace || replace === false){
			return this._create(function (el){
				return utils.el.tag(el, replace);
			});
		}else if (this[0] && this._el(this[0])){
			return utils.el.tag(this[0]);
		}else{
			return null;
		}
    };

    this.attrs = function (key, value){
        return this._set(key, value, utils.el.attrs, true);
	};

    this.props = function (key, value){
        return this._set(key, value, utils.el.props, true);
	};

    this.data = function (key, value){
        return this._set(key, value, utils.el.data, true);
	};

	this.cache = function (key, value){
		return this._set(key, value, utils.cache, true);
	};

    this.style = function (key, value){
        return this._set(key, value, utils.el.style, true);
	};

	this.transform = function (key, value){
        return this._set(key, value, utils.el.transform, true);
	};

	this.hide = function (){
		return this.style('display', 'none');
	};

	this.show = function (isForced){
		return this.each(function (el){
			utils.el.show(el, isForced);
		}, true);
	}; 

    this.html = function (html, data, args){
        if (arguments.length && html !== true){
			if (utils.is.str(html) && data){
				html = utils.string.replace(html, data);
			}else if (html instanceof this.$static){
				html = html.get();
			}

			args 		= args || {};
			args.alias 	= args.alias || this.alias;
			
            return this.each(function (el){
				utils.dom.html(el, html, args);
            }, true);
        }else if (this._el(this[0])){
            return utils.dom.html(this[0], html === true ? true : false);
        }else{
            return '';
        }
    };

	this.text = function (text, data){
        if (arguments.length){
			text = utils.is.str(text) ? utils.string.replace(text, data) : text;

            this.each(function (el){
                el.innerText = text;
            });
        }else if (this[0]){
            return this[0].innerText;
        }else{
            return '';
        }
	};

	this.json = function (json){
		function _isInput (el){
			var t = el.tagName.toLowerCase();
			return t === 'textarea' || t === 'input';
		}

		if (arguments.length){
			var html = JSON.stringify(json || {});
			return this.each(function (el){
				if (_isInput(el)){
					el.value = html;
				}else{
					el.innerHTML = html;
				}
			}, true);
        }else if (this._el(this[0])){
			var html = _isInput(this[0]) ? this[0].value : this[0].innerHTML;
			return utils.toJson(html);
        }else{
            return {};
        }
	};
	
	this.value = function (value, data){
		if (arguments.length){
			return this.each(function (el){
				utils.el.value(el, value, data);
			}, true);
		}else if (this._el(this[0])){
			return utils.el.value(this[0]);
		}else{
			return undefined;
		}
    };
    
    this.values = function (key, value, setter){
		if (utils.is.obj(key) || (value && !utils.is.fn(value))){
			return this.each(function (el){
				utils.el.values(el, key, value, setter);
			}, true);
		}else if (this._el(this[0])){
			return utils.el.values(this[0], key, value, setter);
		}else{
			return arguments.length ? undefined : {};
		}
	};

	this.index = function (parentSelector){
		return this[0] ? utils.dom.index(this[0], parentSelector) : -1;
	};

	this.update = function (args){
		args         = args || {};
		args.alias   = 'alias' in args ? args.alias : this.alias;
		args.context = 'context' in args ? args.context : this.context;

		if (args.class || args.classnames || args.classname){
			args.class = this._toSelector(args.class || args.classnames || args.classname || null, false);
		}

		return this.each(function (el){
			utils.el.update(el, args);
		}, true);
	};

	// classnames ------------------------------------------------------------------------------------------------------
	this.hasClass = function (classname){
		classname = this._toSelector(classname, false);

		var isFound = false;
		var classnames;

		// @todo add "allValid"
		this.each(function (el){
			classnames = utils.el.classnames(el);

			if (~classnames.indexOf(classname)){
				isFound = true;
			}
		}, true);

		return isFound;
	};

    this.classnames = function (classnames){
		if (classnames){
			classnames = this._toSelector(classnames, false);
			return this.each(function (el){
				utils.el.classnames(el, classnames);
			}, true);
		}else if (this[0]){
			return utils.el.classnames(this[0]);
		}else{
			return [];
		}
	};
	
    this.addClass = function (classnames, duration){
		classnames = this._toSelector(classnames, false);
        return this.each(function (el){
			utils.el.addClass(el, classnames, null, duration);
		}, true);
    };

    this.removeClass = function (classnames){
		classnames = this._toSelector(classnames, false);
        return this.each(function (el){
			utils.el.removeClass(el, classnames);
		}, true);
    };

    this.toggleClass = function (classnames){
		classnames = this._toSelector(classnames, false);
        return this.each(function (el){
			utils.el.toggleClass(el, classnames);
		}, true);
    };

	// dimensions/positions --------------------------------------------------------------------------------------------
	this.bounds = function (args){
		return utils.dom.bounds(this[0], args);
	};

	this.width = function (){
		return this.bounds().width;
	};

	this.height = function (){
		return this.bounds().height;
	};

	this.outerWidth = function (){
		return this.bounds().vbox.width;
	};

	this.outerHeight = function (){
		return this.bounds().vbox.height;
	};

	this.scroll = function (x, y, args){
		if (arguments.length){
			args   = args || {};
			args.x = x;
			args.y = y;
			return this.each(function (el){
				utils.el.scrollTo(el, args);
			}, true);
		}else if (utils.is.dom(this[0])){
			return utils.el.scroll(this[0]);
		}else{
			return null;
		}
	};

	this.scrollTop = function (y, args){
		if (arguments.length){
			args   = args || {};
			args.y = y;
			return this.each(function (el){
				utils.el.scrollTo(el, args);
			}, true);
		}else if (this._el(this[0])){
			return utils.el.scroll(this[0]).top;
		}else{
			return null;
		}
	};

	this.scrollLeft = function (x, args){
		if (arguments.length){
			args   = args || {};
			args.x = x;
			return this.each(function (el){
				utils.el.scrollTo(el, args);
			}, true);
		}else if (this._el(this[0])){
			return utils.el.scroll(this[0]).left;
		}else{
			return null;
		}
	};
    
    // events ----------------------------------------------------------------------------------------------------------
    this.on = function (name, args){
		name = this._toSelector(name);

        args         = (utils.is.fn(args) ? {'callback':args} : args) || {};
        args.context = args.context || this.context;

		return this.each(function (el){
			utils.el.addEvents(el, name, args);
        }, true);
    };

    this.off = function (name, args){
		name = this._toSelector(name);

		args         = (utils.is.fn(args) ? {'callback':args} : args) || {};
        args.context = args.context || this.context;
        
        return this.each(function (el){
            utils.el.removeEvents(el, name, args);
        }, true);
    };

    this.trigger = function (name, args){
		name = this._toSelector(name);

		return this.each(function (el){
            utils.el.triggerEvent(el, name, args);
        }, true);
	};
	
	this.focus = function (select){
		if (this._el(this[0])){
			var el = this[0];
		
			el.focus();

			if (select){
				utils.fn.requestFrame(function (){ el.select(); });
			}
		}
		return this;
	};

	this.blur = function (){
		if (this._el(this[0])){
			return this[0].blur();
		}
		return this;
	};

	// http ------------------------------------------------------------------------------------------------------------
	this.load = function (url, args){
		if (utils.is.fn(args)){
			args.callback = {'callback':args};
		}

		args 		 = args || {};
		args.context = args.context || this.context;
		args.add	 = args.position || null;			// [append, prepend, before, after, ..., null]
				
		var self      = this;
		var oCallback = args.callback;
		
		args.callback = function (response, success, e){
			self.each(function (el){
				var nodes = self._create([]); // empty Query

				// @todo deal with textNodes...

				if (success && utils.is.str(response)){
					nodes.add(false, response);

					if (args.add){
						utils.dom.add(nodes, args.add, el);	
					}else{
						utils.dom.html(el, nodes);
					}
				}

				utils.apply(oCallback, [nodes, response, success, e], args.context);
			});
		};

		utils.media.http(url, null, args);

		return this;
	};

	// other -----------------------------------------------------------------------------------------------------------
	this.lazy = function (args){
		utils.dom.lazy(this, args);
		return this;
	};

    // aliases ---------------------------------------------------------------------------------------------------------
	this.css  = this.style;
	this.attr = this.attrs;
	this.prop = this.props;
	this.val  = this.value;
	this.removeAttr = function (name){ return this.attrs(name, ''); }
});

Query.noConflict(Query.shorthand);

MIXINS.Query = function (utils){
    // methods -----------------------------------------------------------------
	this.$ = function (selector){
		var self      = this.$self;
        var classname = ('classname' in self ? self.classname : self.getTypeClass());
		return new Query(selector, {
			'context' : self,
			'alias'	  : classname,
		});
	};
};

// @todo add resizer observer : https://stackoverflow.com/questions/14866775/detect-document-height-change
var Browser = new Class('#Browser', function (utils, Class){
    this.$mixins = 'Fallback,Events';

	// constants -------------------------------------------------------------------------------------------------------
    var ORIENTATIONS = {
		PORTRAIT  : 'portrait',
		LANDSCAPE : 'landscape'
	};

    var DIRECTIONS = {
        UP        : 'up',
		RIGHT 	  : 'right',
		DOWN      : 'down',
		LEFT 	  : 'left',
	};
    
    var DELAYS = {
		DEBOUNCE 	: 150,
        ZOOM        : 500,
	};

    var BREAKPOINTS = {
        MINI   : 360,
        PHONE  : 480,
        TABLET : 768,
        LAPTOP : 1440,
        DESKTOP: 2000,
    };

    // properties ------------------------------------------------------------------------------------------------------
    this.$data = {
        'zoom'   : 1,
        'columns': {
            'count'   : 8,
            'gap'     : 20,
            'padding' : 30,
            'width'   : true,
            'maxWidth': true,
        }
    };

    this.conditions = {
        'mobile' : function (){
            return this.mobile;
        },
        'phone' : function (){
            return this.breakpoint === 'phone';
        },
        'tablet' : function (){
            return this.breakpoint === 'tablet';
        },
        'laptop' : function (){
            return this.breakpoint === 'laptop';
        },
        'desktop' : function (){
            return this.breakpoint === 'desktop';
        },
        'widescreen' : function (){
            return this.breakpoint === 'widescreen';
        },
        'small' : function (){
            return this.breakpoint === 'phone' || this.breakpoint === 'tablet';
        },
        'big' : function (){
            return this.breakpoint !== 'phone' && this.breakpoint !== 'tablet';
        },
        'ie' : function (){
            return this.name === 'ie';
        },
        'ie10' : function (){
            return this.name === 'ie' && this.version <= 10;;
        },
    };

    // constructor -----------------------------------------------------------------------------------------------------
	this.init = function (){
        this.refresh();

        utils.dom.ready(this, dom_onReady);
        utils.dom.load(this, dom_onLoad);

        this.on(window, 'resize', window_onResize);
        // this.on(window.visualViewport, 'resize', window_onResize);
        this.on(window, 'scroll', {'capture':true, 'passive':true}, window_onScroll);
        this.on(document, 'mouseenter,mousemove,mouseleave,mousedown', document_onMouse);
        this.on(document, 'touchstart,touchmove,touchend,touchcancel', document_onTouch);

        // @todo test pixelDensity maybe, if needed? https://css-tricks.com/can-javascript-detect-the-browsers-zoom-level/
        var onZoom = visualViewport_onResize.bind(this);
        if (window.visualViewport){
            visualViewport.onresize = onZoom;
        }else{
            setInterval(onZoom, DELAYS.ZOOM);
        }
        
        // @todo add "resize" content event of the browser

        if (this.onready){
            this.ready(this.onready);
        }
        if (this.onload){
            this.load(this.onload);
        }

        // add defaults for PROPS, Props needs to be added before Browser
        var self = this;
        Class.ready('Props', function (){
            utils.each(self.conditions, function (c, i){
                Class.Props.addCondition(i, function (){ return self.apply(c); });
            });
        });

        // resize point
        var point = this.$point({
            'x' : document.documentElement.clientWidth,
            'y' : document.documentElement.clientHeight,
        });
        this.set({'pointResize':point});
    };
    
    // getter/setter ---------------------------------------------------------------------------------------------------
    this.$get.scrollbarSize = function (){
        return this._scrollbar();
    };

    this.$get.size = function (){
        return this.get('size', {});
    };

    this.$get.zoom = function (){ return this.get('zoom', 1); };

    this.$get.breakpoint = function (){ 
        return this.get('size', {}).breakpoint; 
    };

    this.$set.breakpoint = function (v){ 
        if (v){
            document.documentElement.setAttribute('breakpoint', v);
        }else{
            document.documentElement.removeAttribute('breakpoint');
        }
        this.refresh(true);
    };

    this.$get.scroll = function (){
        return this.get('scroll', {
            'top'   : 0,
            'bottom': window.innerHeight,
            'left'  : 0,
            'right' : window.innerWidth,
            'hasX'  : false,
            'hasY'  : false,
        });
    };

    this.$get.cursor = function (){
        return this.get('cursor', {
            'x'    : null,
            'y'    : null,
            'pageX': null,
            'pageY': null,
        });
    };

    this.$get.os        = function (){ return this.get('browser', {}).os || null; };
    this.$get.name      = function (){ return this.get('browser', {}).name || null; };
    this.$get.version   = function (){ return this.get('browser', {}).version || 0; };
    this.$get.mobile    = function (){ return this.get('mobile', false); };

    this.$get.sitename = function (){ return this.get('page_sitename', ''); };
    this.$set.sitename = function (v){ this.set({'page_sitename':v}); this._title(); };
    this.$get.title    = function (){ return this.get('page_title', ''); };
    this.$set.title    = function (v){ this.set({'page_title':v}); this._title(); };
    this.$get.count    = function (){ return this.get('page_count', ''); };
    this.$set.count    = function (v){ this.set({'page_count':v}); this._title(); };

    // private function ------------------------------------------------------------------------------------------------
    this._title = function (){
        if (!this.when('hasTitle')){
            if (utils.object.has(window, 'page_sitename, page_title, page_separator, page_count, page_template, page_template_count')){
                this.set({
                    'page_sitename'      : window.page_sitename,
                    'page_title'         : window.page_title,
                    'page_separator'     : window.page_separator,
                    'page_count'         : window.page_count,
                    'page_template'      : window.page_template,
                    'page_template_count': window.page_template_count,
                });
            }else{
                var title = document.querySelector('head title');
                title = title && (title.innerText || '');
                title = title && title.replace(/\n/g, ' ');
                this.set('page_title', title);
            }

            this.when('hasTitle', true);
        }

        var data = this.$data;
        if (data.page_template){
            var count = utils.is.numeric(data.page_count) ? utils.string.replace(data.page_template_count, {
                'count' : data.page_count,
            }) : '';

            var title = utils.string.replace(data.page_template, {
                'sitename'   : data.page_sitename,
                'title'		 : data.page_title || '',
                'separator'  : (data.page_sitename && data.page_title) ? data.page_separator : '',
                'count'		 : count,
            });

            document.title = title;
        }
    };

    this._scrollbar = function (refresh){
        var size = this.get('scrollbarSize', -1);
        if (size > -1 && !refresh){
            return size;
        }
        
        // create a box
        var outside = this._scrollOutside;
        var inside  = this._scrollInside;

        if (!outside){
            var parent  = document.documentElement; 
            outside     = this._scrollOutside = document.createElement('div');
            inside 	    = this._scrollInside = document.createElement('div');

            outside.style = 'opacity:0; overflow:scroll; width:50px; pointer-events:none; position:absolute; top:0; left:0;';
            outside.setAttribute('dummy', 'browser-scroll-size');
            outside.setAttribute('aria-hidden', 'true');
            outside.appendChild(inside);
            parent.appendChild(outside);
        }
		
		// create a dummy DIV with a children and compare their width
		var size = outside.offsetWidth - inside.offsetWidth;
		
		return this.set('scrollbarSize', size, true);
    }

    this._size = function (refresh){
        var breakpoint, style;
        var html     = document.documentElement;
        var body     = document.body;
        var size     = this.get('size', {});
        var previous = this.get('previous', {});

        if (refresh){
            this._setVars(null);
        }

        body && body.offsetHeight;

        // update the previous
        previous.width         = size.screenWidth;
        previous.height        = size.screenHeight;
        previous.contentWidth  = size.contentWidth;
        previous.contentHeight = size.contentHeight;
        previous.body          = body;

        body = body || {
            'scrollWidth'  : 0,
            'scrollHeight' : 0,
            'offsetWidth'  : 0,
            'offsetHeight' : 0,
        };
		
        var screenWidth   = window.innerWidth;
        var screenHeight  = window.innerHeight;
        var innerWidth    = html.clientWidth;
        var innerHeight   = html.clientHeight;
        var zoom          = innerWidth / screenWidth;
       
        var hasScrollbarY = html.scrollHeight > html.clientHeight;
        var hasScrollbarX = html.scrollWidth > html.clientWidth;
        var viewportWidth = utils.dom.toPx('100vw');
        var viewportHeight= utils.dom.toPx('100vh');

        // debugging the size with the debug-media() sass mixin
        if (this.debug){
            style = window.getComputedStyle(html);

            // @todo replace those with utils.el.var()
            var w = parseFloat(style.getPropertyValue('--debug-width').trim()) || 0;
            var h = parseFloat(style.getPropertyValue('--debug-height').trim()) || 0;

            if (w){
                screenWidth = w;
                innerWidth  = w;
                contentWidth= w;
                deviceWidth = w;
                offsetWidth = w;
                scrollWidth = w;
            }
            if (h){
                screenHeight = h;
                innerHeight  = h;
            }
        }

        // size of the window/screen
        size.screenWidth   = screenWidth;
        size.screenHeight  = screenHeight;
        // size of the container without the scrollbar
        size.innerWidth    = innerWidth;
        size.innerHeight   = innerHeight;
        // size of viewport
        size.viewportWidth   = viewportWidth;
        size.viewportHeight  = viewportHeight;
        size.viewportOffsetX = viewportWidth - screenWidth;
        size.viewportOffsetY = viewportHeight - screenHeight;
        // size of the container with the scrollbar (but not "overflow:scroll")
        size.offsetWidth   = innerWidth + (hasScrollbarY ? this.scrollbarSize : 0);
        size.offsetHeight  = innerHeight + (hasScrollbarX ? this.scrollbarSize : 0);
        // size of the content inside
        size.contentWidth  = Math.max(html.clientWidth, body.scrollWidth, html.scrollWidth, body.offsetWidth, html.offsetWidth);
        size.contentHeight = Math.max(html.clientHeight, body.scrollHeight, html.scrollHeight, body.offsetHeight, html.offsetHeight);
        // scrollable size
        size.scrollWidth   = size.contentWidth - size.innerWidth;
        size.scrollHeight  = size.contentHeight - size.innerHeight;
        size.scrollbar     = this.scrollbarSize;
        // orientation
        size.orientation   = size.screenHeight > size.screenWidth ? ORIENTATIONS.PORTRAIT : ORIENTATIONS.LANDSCAPE; 
        // device width/height while ignoring the orientation
        size.deviceWidth 	= size.orientation == ORIENTATIONS.LANDSCAPE ? size.screenWidth : size.screenHeight;
        size.deviceHeight	= size.orientation == ORIENTATIONS.LANDSCAPE ? size.screenHeight : size.screenWidth;
    
        // breakpoints sizes
        var breakpoints = this.get('breakpoints');
        if (!breakpoints){
            style               = style || window.getComputedStyle(html);
            breakpoints         = {};
            
            var a               = {'style':style, 'format':parseFloat};
            breakpoints.mini    = utils.el.var(html, '--breakpoint-mini', a) || BREAKPOINTS.MINI;
            breakpoints.phone   = utils.el.var(html, '--breakpoint-phone', a) || BREAKPOINTS.PHONE;
            breakpoints.tablet  = utils.el.var(html, '--breakpoint-tablet', a) || BREAKPOINTS.TABLET;
            breakpoints.laptop  = utils.el.var(html, '--breakpoint-laptop', a) || BREAKPOINTS.LAPTOP;
            breakpoints.desktop = utils.el.var(html, '--breakpoint-desktop', a) || BREAKPOINTS.DESKTOP;
            breakpoints         = this.set('breakpoints', breakpoints, true);
        }
        
        //console.log(previous.contentWidth, size.contentWidth, previous.contentHeight, size.contentHeight);

        // skip the rest if it's the same as before...
        if (
            !refresh && 
            previous.width === screenWidth && 
            previous.height === screenHeight && 
            previous.contentWidth === size.contentWidth && 
            previous.contentHeight === size.contentHeight && 
            previous.body === body
        ){
            return false;
        }

        // breakpoints ---------------------------------------------------------
        // version 1 : "--breakpsoint" variable
        style      = style || window.getComputedStyle(html);
        breakpoint = style.getPropertyValue('--breakpsoint').trim();

        // version 2 : html:before "content" prop
        if (!breakpoint){
            style      = window.getComputedStyle(html, ':before');
            breakpoint = style.getPropertyValue('content').replace(/\"/g, '').trim();
            breakpoint = breakpoint !== 'none' ? breakpoint : '';
        }
        
        // version 3 : specified size
        if (!breakpoint){
            //var breakpoints = this.get('breakpoints', {});
            for (var name in breakpoints){
                if (screenWidth <= breakpoints[name]){
                    breakpoint = name;
                    break;
                }
            }
        }

        size.breakpoint = breakpoint || null;

        this.set({
            'previous': previous,
            'size'   : size,
        });

        return size;
    };

    this._mobile = function (refresh){
        var mobile = this.get('mobile', null);

        if (mobile === null || refresh){
            var mobile = (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase())) ||
                        (((navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) && !window.MSStream);
            this.set('mobile', mobile);
        }

        return mobile;
    };

    this._browser = function (refresh){
        var browser = this.get('browser');

        if (!browser || refresh){
            var os               = null;
            var name             = null;
            var version          = null;
            
            var ua               = navigator.userAgent;
            var platform         = window.navigator.platform;
            var macosPlatforms   = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
            var windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
            var iosPlatforms     = ['iPhone', 'iPad', 'iPod'];

            // since iPad 13 and +
            if (platform === 'MacIntel' && navigator.maxTouchPoints > 1 && !window.MSStream){
                os = 'ios';
            }else if (macosPlatforms.indexOf(platform) !== -1) {
                os = 'macos';
            } else if (iosPlatforms.indexOf(platform) !== -1) {
                os = 'ios';
            } else if (windowsPlatforms.indexOf(platform) !== -1) {
                os = 'windows';
            } else if (/Android/.test(ua)) {
                os = 'android';
            } else if (!os && /Linux/.test(platform)) {
                os = 'linux';
            }

            var match = null;

            //"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0"
            if (match = ua.match(/Firefox\/(\d+(?:\.\d+)?)/)){
                name = 'firefox';
            // Opera/9.80 (Windows NT 6.1; WOW64) Presto/2.12.388 Version/12.18
            // Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.52 Safari/537.36 OPR/15.0.1147.100
            }else if (match = ua.match(/(?:Opera|OPR)\/(\d+(?:\.\d+)?)/)){
                name = 'opera';
            //"Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; Zoom 3.6.0; wbx 1.0.0; rv:11.0) like Gecko"
            }else if (~ua.indexOf('Trident') && ((match = ua.match(/MSIE\s(\d+(?:\.\d+)?)/)) || (match = ua.match(/rv\:(\d+(?:\.\d+)?)/))) ){
                name = 'ie';
            //"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299"
            }else if (match = ua.match(/Edge\/(\d+(?:\.\d+)?)/)){
                name = 'edge';
            //"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/66.0.3359.181 Chrome/66.0.3359.181 Safari/537.36"
            }else if (match = ua.match(/Chrome\/(\d+(?:\.\d+)?)/)){
                name = 'chrome';
            //Mozilla/5.0 (iPhone; CPU iPhone OS 12_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1
            }else if (ua.match(/iP(ad|od|hone)/i) && (match = ua.match(/OS\s(\d+(?:\_\d+)?)/))){
                name = 'safari';
            //Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15
            }else if (~ua.indexOf('Safari') && (match = ua.match(/Version\/(\d+(?:\.\d+)?)/))){
                name = 'safari';
            }else{
                name = 'unknown';
            }

			version = match ? parseFloat(match[1].replace('_', '.')) : 0;

            browser = this.set('browser', {
                'os'     : os,
                'name'   : name,
                'version': version,
            }, true);
        }

        return browser;
    };

    this._scroll = function (){
        return this.set('scroll', {
            'top'   : window.pageYOffset,
            'bottom': window.pageYOffset + window.innerHeight,
            'left'  : window.pageXOffset,
            'right' : window.pageXOffset + window.innerWidth,
            'hasX'  : document.documentElement.scrollWidth > window.innerWidth,
            'hasY'  : document.documentElement.scrollHeight > window.innerHeight,
        }, true);
    };

    this._cursor = function (e){
        var x       = null;
        var y       = null;
        var pageX   = null;
        var pageY   = null;
        var scrollX = window.scrollX || window.pageXOffset || 0;
        var scrollY = window.scrollY || window.pageYOffset || 0;

        if (e.type.match(/^touch/) && e.touches && e.touches[0]){
            var x = e.touches[0].clientX;
            var y = e.touches[0].clientY;
        }else{
            var x = e.clientX;
            var y = e.clientY;
        }

        switch (e.type){
            case 'mouseleave':
            case 'touchcancel':
            case 'touchend':
                x = null;
                y = null;
                break;
        }
        
        if (x !== null){
            pageX = x + scrollX;
        }

        if (y !== null){
            pageY = y + scrollY;
        }

        return {
            'x'    : x,
            'y'    : y,
            'pageX': pageX,
            'pageY': pageY,
        }
    };

    this._touchScroll = function (e, isEnd){
        var hasTouch = this.get('hasTouch');
        if (!hasTouch){
            return;
        }

        var touch = this.get('pointTouch') || this.$point();

        if (isEnd){
            touch.update(false);
        }else{
            touch.node   = e.node;
            touch.top    = e.top;
            touch.right  = e.right;
            touch.bottom = e.bottom;
            touch.left   = e.left;
            touch.width  = e.width;
            touch.height = e.height;
            touch.update([e.x, e.y]);
        }

        this.trigger('touch-scroll', touch);
        this.set('pointTouch', isEnd ? null : touch);
        
        if (isEnd){
            this.set('hasTouch', null);
        }
    };

    this._setVars = function (size){
        size = size || {};

        function _v (prop, value, unit, fallback){
            value = value ? value + (unit||'') : (fallback||'');
            document.documentElement.style.setProperty(prop, value);
        }

        _v('--scrollbar', size.scrollbar, 'px');
        _v('--screen-width', size.screenWidth, 'px', '100vw');
        _v('--screen-height', size.screenHeight, 'px', '100vh');
        _v('--screen-scrollbar', size.scrollHeight ? size.scrollbar : 0, 'px');
        _v('--view-width', size.screenWidth);
        _v('--view-height', size.screenHeight);

        _v('--viewport-width', size.viewportWidth, 'px', '100vw');
        _v('--viewport-height', size.viewportHeight, 'px', '100vh');
        _v('--viewport-min-height', size.innerHeight, 'px', '100vh');
        _v('--viewport-max-height', size.viewportHeight, 'px', '100vh');
        _v('--viewport-dynamic-height', size.screenHeight, 'px', '100vh');
        _v('--viewport-visible-height', window.visualViewport.height, 'px', '100vh');
        _v('--viewport-offset-x', size.viewportOffsetX, 'px');
        _v('--viewport-offset-y', size.viewportOffsetY, 'px');
        
        _v('--inner-width', size.innerWidth, 'px', '100vw');
        _v('--inner-height', size.innerHeight, 'px', '100vh');
        _v('--offset-width', size.offsetWidth, 'px', '100vw');
        _v('--offset-height', size.offsetHeight, 'px', '100vh');
        _v('--scroll-width', size.scrollWidth, 'px', '0px');
        _v('--scroll-height', size.scrollHeight, 'px', '0px');
        _v('--content-width', size.contentWidth, 'px', '100vw');
        _v('--content-height', size.contentHeight, 'px', '100vh');
        _v('--orientation', size.orientation);
        
        // debugger;

        /*
        html.style.setProperty('--scrollbar', (size.scrollbar || 0) + 'px');
        html.style.setProperty('--screen-width', (size.screenWidth + 'px') || '100vw');
        html.style.setProperty('--screen-height', (size.screenHeight + 'px') || '100vh');
        html.style.setProperty('--screen-scrollbar', ((size.scrollHeight ? size.scrollbar : 0) || 0) + 'px');
        html.style.setProperty('--viewport-width', (size.viewportWidth + 'px') || '100vw');
        html.style.setProperty('--viewport-height', (size.viewportHeight + 'px') || '100vh');
        
        html.style.setProperty('--viewport-min-height', (size.innerHeight + 'px') || '100vh');
        html.style.setProperty('--viewport-max-height', (size.viewportHeight + 'px') || '100vh');
        html.style.setProperty('--viewport-dynamic-height', (size.screenHeight + 'px') || '100vh');

        html.style.setProperty('--viewport-offset-x', (size.viewportOffsetX || 0) + 'px');
        html.style.setProperty('--viewport-offset-y', (size.viewportOffsetY || 0) + 'px');
        html.style.setProperty('--inner-width', (size.innerWidth + 'px') || '100vw');
        html.style.setProperty('--inner-height', (size.innerHeight + 'px') || '100vh');
        html.style.setProperty('--offset-width', (size.offsetWidth + 'px') || '100vw');
        html.style.setProperty('--offset-height', (size.offsetHeight + 'px') || '100vh');
        html.style.setProperty('--scroll-width', (size.scrollWidth + 'px') || '0px');
        html.style.setProperty('--scroll-height', (size.scrollHeight + 'px') || '0px');
        html.style.setProperty('--content-width', (size.contentWidth + 'px') || '100vw');
        html.style.setProperty('--content-height', (size.contentHeight + 'px') || '100vh');
        html.style.setProperty('--orientation', (size.orientation) || '');     
        */ 
    }

	// events ----------------------------------------------------------------------------------------------------------
    function dom_onReady (){
        this.refresh();
        this._title();
		this.trigger('ready');	
    };

    function dom_onLoad (){
        this.refresh();
		this.trigger('load');
		//this.loadTime = +new Date() - this.get('startTime');
    };

    function window_onResize (e){
        this.refresh(true);
        
        var size  = this.get('size', {});
        var point = this.get('pointResize') || this.$point();
        this.set({'pointResize':point});

        if (!this._resizer){
            this._resizer = utils.fn.sync({
                'context'  : this,
                'throttle' : true,
                'debounce' : DELAYS.DEBOUNCE,
                'format'   : _format,
                'onStart'  : _trigger,
                'onChange' : _trigger,
                'onEnd'	   : _trigger,
            });

            function _format (e, start){
                point._x          = point.x;
                point._y          = point.y;
                point._breakpoint = point.breakpoint;
                point.breakpoint  = e.breakpoint;
                point.width       = e.width;
                point.height      = e.height;
                point._sh         = e.screenHeight;
                return point.update([e.width, e.height], null, !start);
            }

            function _trigger (e){
                // size
                if (e._x !== e.x){
                    this.trigger('resize-width', e);
                }
                if (e._y !== e.y){
                    this.trigger('resize-height', e);
                }
                if (e._sh !== e.screenHeight){
                    this.trigger('resize-screen-height', e);
                }
                if (e._x !== e.x || e._y !== e.y){
                    this.trigger('resize', e);
                }
				// breakpoint
				if (e._breakpoint !== e.breakpoint){
                    this.trigger('breakpoint', e);
				}
            }
        }

        var self = this;
        function _refresh (){
            if (!size || window.innerHeight === size.screenHeight) return;

            self.refresh(true);

            var s = self.get('size', {});
            self._resizer({
                'width'      : s.innerWidth,
                'height'     : s.innerHeight,
                'breakpoint' : s.breakpoint,
            });
        }

        if (size){
            this._resizer({
                'width'       : size.innerWidth,
                'height'      : size.innerHeight,
                'breakpoint'  : size.breakpoint,
                'screenHeight': size.screenHeight,
            });

            // ios issue. when rotating the screen, the screenHeight isn't properly updated
            // the double check is to try to see the screen change, but it might not be already changed
            this.wait(10, _refresh);
            this.wait(300, _refresh);
            this.wait(600, _refresh);
        }
    };

    function window_onScroll (e){
        var point = this.get('pointScroll') || this.$point();

        if (e.target === window || e.target === document || e.target === document.body){
            this._scroll();
        }

        this.set({
            'pointScroll' : point,
            'scrollTarget': e.originalTarget,
            'isScrolling' : true,
        });

        if (!this._scroller){
            this._scroller = utils.fn.sync({
                'context'  : this,
                'throttle' : true,
                'debounce' : DELAYS.DEBOUNCE,
                'format'   : _format,
                'onStart'  : _trigger,
                'onChange' : _trigger,
                'onEnd'	   : _trigger,
            });

            function _format (e, start){                
                return point.update([e.x, e.y], null, !start);
            }

            function _trigger (e){
                var isTouching = this.get('isTouching');

                this.trigger('scroll', e);
                this._touchScroll(e, !isTouching && e.isEnd);

                if (e.isEnd){
                    this.set('isScrolling', false);
                }
            }
        }

        // since scroll can be on many elements, we don't cache the previous value
        var scroll = utils.el.scroll(e.originalTarget);
        
        point.node   = scroll.node;
        point.width  = scroll.maxX;
        point.height = scroll.maxY;
        point.top    = scroll.top;
        point.right  = scroll.right;
        point.bottom = scroll.bottom;
        point.left   = scroll.left;

        this._scroller(scroll);
    };

    function visualViewport_onResize (e){
        var zoom = window.visualViewport ? visualViewport.scale : document.documentElement.clientWidth / window.innerWidth;
        var old  = this.get('zoom');

        // @info issue with some iOS where the zoom isn't 1 when at the normal scale
        if (zoom <= 1.01){
            zoom = 1;
        }

        if (zoom !== old){
            this.set('zoom', zoom);
            this.trigger('zoom', {'zoom':zoom});
        }

        // visible height
        var height = window.visualViewport.height;
        if (this._visualHeight !== height){
            this._visualHeight = height;
            var size = this.get('size');
            this._setVars(size);
        }
    }

    function document_onMouse (e){
        var previous = this.get('cursor', {});
        var cursor   = this._cursor(e);
        var point    = this.get('pointMove') || this.$point();

        this.set({
            'cursor'   : cursor,
            'pointMove': point,
        });

        if (!this._mover){
            this._mover = utils.fn.sync({
                'context'  : this,
                'throttle' : true,
                'debounce' : DELAYS.DEBOUNCE,
                'format'   : _format,
                'onStart'  : _trigger,
                'onChange' : _trigger,
                'onEnd'	   : _trigger,
                'callback' : _trigger,
            });

            function _format (e, start){
                var isValid = e.x !== null && e.y !== null;
                point.pageX = e.pageX;
                point.pageY = e.pageY;
                return point.update(isValid && [e.x, e.y], null, !start);
            }

            function _trigger (e){
                this.trigger('cursor', e);
            }
        }

        if (previous.pageX !== cursor.pageX || previous.pageY !== cursor.pageY){
            point.size([window.innerWidth, window.innerHeight]);
            this._mover(cursor);
        }
    };

    function document_onTouch (e){
        document_onMouse.apply(this, [e]);

        if (e.type === 'touchstart'){
            this.set('hasTouch', true);
			this.set('scrollTarget', null);
		}

        if (e.type === 'touchend' || e.type === 'touchcancel'){
            var scrollTarget = this.get('scrollTarget');
            var isScrolling  = this.get('isScrolling');

            if (scrollTarget && !isScrolling){
                this._touchScroll({'node':scrollTarget}, true);
            }

            this.set('isTouching', false);
        }else{
            this.set('isTouching', true);
        }
    };

    // methods ---------------------------------------------------------------------------------------------------------
    this.ready = function (context, callback){
        if (!arguments.length){
            return utils.dom.isReady();
        }
		if (callback === undefined){
			callback = context;
			context  = this;
		}
		utils.dom.ready(context, callback);
        return this;
	};

	this.load = function (context, callback){
        if (!arguments.length){
            return utils.dom.isLoaded();
        }
		if (callback === undefined){
			callback = context;
			context  = this;
		}
		utils.dom.load(context, callback);
        return this;
	};

    this.breakpoints = function (breakpoints, clear){
        if (!arguments.length){
            return this.get('breakpoints', {});
        }

        var previous = clear ? {} : this.get('breakpoints', {});
        breakpoints = utils.extend(previous, breakpoints);
        breakpoints = utils.array.sort(breakpoints, 'value ASC');
        return this.set('breakpoints', breakpoints);
    };

    this.addCondition = function (key, callback){
        this.conditions[key] = callback;

        // add the condition to the Props too
        Class.Props && Class.Props.addCondition(key, function (){ 
            return callback(); 
        });
    };

    this.is = function (condition){
        if (condition in this.conditions){
            return this.apply(this.conditions[condition]);
        }else if (utils.is.obj(condition)){
            // @todo 
        }
    };

    this.isWidth = function (min, max){
        // @todo
    };

    this.columns = function (data){
        if (data){
            this.$data.columns = utils.extend(this.$data.columns, {}, data || {});
            return this;
        }else{
            var media = this.size.breakpoint;
            var data  = this.get('columns_' + media);

            if (!data){
                var style = window.getComputedStyle(document.documentElement);

                data          = this.get('columns', {});
                data.count    = utils.el.var(null, '--columns-count', data.count, style);
                data.gap      = utils.el.var(null, '--columns-gap', data.gap, style);
                data.padding  = utils.el.var(null, '--columns-padding', data.padding, style);
                data.width    = utils.el.var(null, '--columns-width', data.width, style);
                data.maxWidth = utils.el.var(null, '--columns-max-width', data.maxWidth, style);

                this.set('columns_' + media, data);
            }

            var width = data.width === true ? this.size.screenWidth : utils.dom.toPx(data.width);
            var max   = data.width === true ? this.size.screenWidth : utils.dom.toPx(data.maxWidth);

            return {
                'count'  : data.count,
                'gap'    : utils.dom.toPx(data.gap),
                'padding': utils.dom.toPx(data.padding),
                'width'  : width > max ? max           : width,
            };
        }
    };

    this.col = function (count, gap, padding){
        var columns = this.columns();

        count   = count || 0;
        gap     = gap || 0;
        padding = padding || 0;

        var size = count ? ((columns.width + columns.gap) * (count / columns.count) - columns.gap) : 0;
        return size + (gap * columns.gap || 0) + (padding * columns.padding || 0);
    };

	this.popup = function (href, args){
		args         = args || {};
        args.x       = 'x' in args ? args.x : '50%';
        args.y       = 'y' in args ? args.y : '50%';
		args.width   = args.width || (window.screen.width / 2);
		args.height  = args.height || (window.screen.height / 2);
		args.target  = args.target || '';
		args.toolbar = args.toolbar || false;
		args.status  = args.status || false;

		var left = utils.calculate(args.x, window.screen.width - args.width);
		var top  = utils.calculate(args.y, window.screen.height - args.height);

		var left = left < 0 ? 0 : left;
		var top  = top < 0 ? 0 : top;
		var win  = window.open(href, args.target, 'toolbar='+(args.toolbar?1:0)+',status='+(args.status?1:0)+',width='+args.width+',height='+args.height+',left='+left+',top='+top);

        if (win){
            win.focus();
        }

		return win;


        /*
        // https://stackoverflow.com/questions/4068373/center-a-popup-window-on-screen

        var w     = args.width;
        var h     = args.height;
        var url   = href;
        var title = '';

        // Fixes dual-screen position                             Most browsers      Firefox
        const dualScreenLeft = window.screenLeft !==  undefined ? window.screenLeft : window.screenX;
        const dualScreenTop = window.screenTop !==  undefined   ? window.screenTop  : window.screenY;

        const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
        const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;

        const systemZoom = width / window.screen.availWidth;
        const left = (width - w) / 2 / systemZoom + dualScreenLeft
        const top = (height - h) / 2 / systemZoom + dualScreenTop
        const newWindow = window.open(url, title, 
        `
        scrollbars=yes,
        width=${w / systemZoom}, 
        height=${h / systemZoom}, 
        top=${top}, 
        left=${left}
        `
        )
        */
	};

    this.favicon = function (path, args){
        args      = args || {};
        args.size = utils.array.to2Numbers(args.size || '152x152');
        args.color= utils.dom.var('body', args.color || 'black');

        var favicon = utils.dom.get('head link[rel="icon"]') || utils.dom.create('link', {
            'parent' : 'head',
            'attrs'  : {
                'rel'  : 'icon',
                'type' : 'image/png',
                'href' : '',
                'sizes': args.size.join('x'),
                'width': args.size[0] + 'px',
            },
        });

        var ctx = utils.dom.canvas({'size':args.size});
        if (utils.is.fn(path)){
            path(ctx);
        }else{
            path = utils.path.get(path, {
                'width' : args.size[0],
                'height': args.size[1],
            });

            ctx.beginPath();
            utils.path.draw(path, {'ctx':ctx});
            ctx.fillStyle = args.color;
            ctx.closePath();
            ctx.fill();
        }

        favicon.href = ctx.canvas.toDataURL('image/png');
    };

    this.refresh = function (refresh){
        var scrollbar = this._scrollbar(true);
        var size      = this._size(refresh);
        var mobile    = this._mobile(refresh);
        var browser   = this._browser(refresh);

        this._scroll();

        if (size){
            var previous   = this.get('previous', {});
            var html       = document.documentElement;
            var classnames = [];

            // mobile
            if (mobile){
                classnames.push('is-mobile');
            }else{
                classnames.push('is-not-mobile');
            }

            // browser
            classnames.push('is-' + browser.os);
            classnames.push('is-' + browser.name);
            classnames.push('is-' + size.orientation);
            classnames.push('is-' + browser.name + '_' + browser.version);

            if (size.scrollHeight && size.scrollbar){
                classnames.push('has-scrollbar');
            }

            // remove old classnames
            if (previous.classnames){
                utils.el.removeClass(html, previous.classnames);
            }

            // add new classnames
            utils.el.addClass(html, classnames);

            // add vars()
            if (utils.is.fn(html.style.setProperty)){
                this._setVars(size);     
			}

            // cache the data
            previous.classnames = classnames;
            this.set('previous', previous);
        }

        return this;
    };
});
var COMPONENTS = window.COMPONENTS || {};

var Component = new Class('Component', function (utils){
    this.$mixins  = 'Element,Filters,States,Events,Props,Style';
    this.$element = {
        'useQuery'       : true,
        'hiddenNodes'    : true,
        'extractElements': true,
        'cloneNodes'     : true,
        'autoTemplate'   : true,
        'excludeClosest' : '[is],[x]',
        'parentSelector' : '[is]',
    };
    this.$props = {
        'excludeClosest': '[is],[x]'
    };

    // constants ---------------------------------------------------------------
    var WRAPPED_FUNCTIONS = 'init,cache,render,uncache,unrender,refresh,addEvents,removeEvents,destroy'.split(',');

    var REFRESH_TYPES = {
        CHILDREN : 'children',
    };

    var STATUS = {
		REQUESTED : 'requested',
		LOADING   : 'loading',
		LOADED 	  : 'loaded',
	};

    var CLASSES = {
        // IS_ENABLE  : 'is-enabled',
        // IS_DISABLED: 'is-disabled',
    };

    var STATES = {
        // ENABLE: 'enable',
        DEBUG : 'debug',
    };

    var SETTINGS = window.theme_settings || window.settings || {};
    var SCRIPTS  = SETTINGS.scripts || SETTINGS.scripts_url || '';
    var VERSION  = SETTINGS.version || '';
    
    // static ------------------------------------------------------------------
    this.$static = {
        'classes'        : {},                       // name : {'path':..., 'status':..., 'class':..., 'queue':...}
        'items'          : [],
        'queues'         : [],
        'baseDir'        : SCRIPTS + '/',
        'mixinsDir'      : SCRIPTS + '/mixins/',
        'componentDir'   : SCRIPTS + '/components/',
        'componentPrefix': 'component-',
        'strings'        : null,
        'statePrefix'    : 'is-',
        'stylePrefix'    : '-',
        'getter'		 : '__',                    // function to get the Component info
    };

    this.$static.$define = function (type, e){
        // simplify some methods to make code quicker.
        // all instances that extends Components will automatically call the Wrapped functions
        if (e.extend === 'Component'){
            utils.each(WRAPPED_FUNCTIONS, function (name){
                var old  = e.prototype[name];
                var fn   = e.props[name];

                if (!fn) return;

                e.props[name] = function (){
                    // skip those functions depending on the "enable" $props
                    if (
                        (this.props.enable && (name === 'uncache' || name === 'unrender')) ||
                        (!this.props.enable && (name === 'cache' || name === 'render'))
                    ){
                        return this;
                    }

                    fn && fn.apply(this, arguments);
                    old && old.apply(this, arguments);

                    return this;
                };
            });
        }
    };

    this.$static.define = function (path, props){
        var self     = this;
        var def      = Class.decode(path, props);
        var requires = [];

        // extends
        if (utils.is.str(def.extend)){
            // deal with classes that are already there
            requires.push(this.componentDir + def.extend.toLowerCase() + '.js');
        }
        // mixins
        this.each(def.mixins, function (v){
            if (!utils.is.str(v)) return;

			v = v.split(':');
			v = v.length > 1 ? v[1] : v[0];

			if (MIXINS[v] || Core[v]) return;
            
            // console.log(MIXINS, v);

			requires.push(this.mixinsDir + v.toLowerCase() + '.js');
        });

        // requires
        this.each(def.props.$requires, function (v){
			v = v.replace('{base}', this.baseDir);
            
			// special components : {type/components}
			if (v.match(/^\{.+\}$/)){
				v = this.componentDir + v.replace(/^\{|\}$/g, '') + '.js';
			}

            requires.push(v);
		});   

        var klass 		 = this.classes[def.type] = this.classes[def.type] || {};
        klass.class      = null;
        klass.extend     = utils.is.str(def.extend) ? utils.string.toCamelCase(def.extend, true) : null;
		klass.requires 	 = requires;
		klass.status 	 = STATUS.LOADING;
		klass.definition = def;
        klass.queue      = klass.queue || [];
        klass.check      = function (){
            // the class has been defined already
            if (this.class) return true;

            // there's still link waiting to be loaded
            if (this.requires.length) return false;

            // deal with the extends
            if (utils.is.str(this.extend) && (!self.classes[this.extend] || self.classes[this.extend].status !== STATUS.LOADED)) return;

            this.status = STATUS.LOADED;
            this.extend = def.extend = this.extend in self.classes ? self.classes[this.extend].class : (this.extend || self);
            this.class  = self[def.type] = new Class(def);

            // create instances of items in the queue
            for (var i in this.queue){
                var item = this.queue[i];
                self.create(item.el, item.path, item.props, item.args);
            }
            this.queue = [];

            // validate other classes that could be depending on this one
			for (var i in self.classes){
				if (
                    i === def.type || !self.classes[i].check    
                ) continue;
                
                self.classes[i].check();
			}
            
            Events.trigger('component-class-ready', {
                'type'  : def.type,
                'target': this.class,
            });
        };

        utils.media.requires(requires, {'version':VERSION}, function (s, e, urls){
            // deal with error links
            if (e.length){
                self.warn('Files for "{{ type }}" component couldn\'t be loaded:\n  {{ urls }}\n  (if it\'s an Extend or Mixin, make sure it\'s written with the proper case)', {
					'urls' : e.join('\n  '),
					'type' : def.type,
				});
            }

            for (var ii in self.classes){
                var c = self.classes[ii];

                // the class is already loaded
                if (c.status === STATUS.LOADED) continue;

                // remove all the loaded URLs from the requires
                if (c.requires.length){
                    utils.array.remove(c.requires, urls);
                }

                // check if current is finished loading
                if (c.status === STATUS.LOADING){
                    c.check();
                }
            }
        });
    };

    this.$static.create = function (el, path, props, args){
        if (utils.is.obj(path) || path === undefined){
            args = props;
            props    = path;
            path     = el;
            el       = null;
        }

        if (utils.is.fn(path)){
            args  = path;
            props = {};
            path  = el;
            el    = null;
        }

        if (utils.is.fn(props)){
            args  = props;
            props = {};
        }

        if (utils.is.fn(args)){
            args = {'onReady' : args};
        }

        if (utils.is.el(el, 'script')){
            var json = utils.toJson(el.innerText);
            utils.extend(props, json);
        }
        
        args         = args || {};
        args.onReady = args.onReady || null;
        args.onLoad  = args.onLoad || null;

        var self  = this;
        var pair  = path.split('.');
        var style = pair[1] || 'default';
        var path  = pair[0];
        var el    = utils.dom.get(el) || document.createElement('div'); // default to an empty <div>
        var type  = utils.string.toCamelCase(path, true);
        var klass = this.classes[type];

        props = props || {};
        
        if (!path){
            // simple component
            klass = {'class':Component};
        }else if (!klass || klass.status !== STATUS.LOADED){
            klass = this.classes[type] = (this.classes[type] || {
                'queue'   : [],
                'requires': [],
            });

            klass.queue.push({
                'el'   : el,
                'props': props,
                'path' : path + '.' + style,
                'args' : args,
            });

            if (!klass.status){
                var url = this.componentDir + path.toLowerCase() + '.js';
                klass.status = STATUS.REQUESTED;
                utils.media.require(url, {'version':VERSION}, function (url, success){
                    if (success) return;
                    self.warn('Component "{type}" couldn\'t be loaded, url wasn\'t found:\n {url}', {
                        'type' : path,
                        'url'  : url,
                    });
                });
            }

            return;
        }

        var instance = new klass.class(el, props, {
            'style': style,
            'path' : path,
        });

        // @todo deal with callback for READY and for LOAD
        instance.when('ready', args.onReady);
        instance.when('loaded', args.onLoad);
        
        Events.trigger('component-instance-ready', {
            'type'  : type,
            'style' : style,
            'target': instance,
        });

        this.items.push(instance);

        return instance;
    };

    this.$static.start = function (){
        // shorthand to get a component
        window[this.getter] = this.get;

        // scane the body for component (with [is] attributes) and include the <body>
        this.scan('body', {
            'self': true
        });
    };

    this.$static.scan = function (el, args){
        if (utils.is.bool(args)){
            args = {'lazy':args};
        }

        args      = args || {};
        args.self = args.self || false;
        args.lazy = args.lazy || false;
        
        var element  = utils.dom.get(el);
        var elements = utils.dom.getAll('[is]', {'context':element, 'includeContext':args.self});
        var total    = 0;

        // remove LAZY elements (with [lazy] attribute) and the elements already initialized
        elements = elements.filter(function (el){
			var isLazy      = args.lazy ? false : utils.el.closest(args.self ? el : el.parentNode, '[lazy]');
			var isComponent = !!el.$component;
            var instance    = isComponent && utils.cache(el, 'component');

            // if it's a component and has the "scan" function, call it
            if (instance && utils.is.fn(instance.scan)){
                instance.scan();
            }

			return !isLazy && !isComponent;
		});

        Events.trigger('component-scan', {
			'target'	: element,
			'elements'	: elements,
			'count'		: 0,
			'total'		: total,
		});

        this.each(elements, function (el){
            var path  = utils.el.attrs(el, 'is');
            var props = utils.el.data(el, undefined, undefined, false);

            el.$component = path;

            this.create(el, path, props, {
                'onReady' : function (){
                    // in some cases (the "overlay" for example), the startup element is changed, we need to make sure "$component" is set on the new parent element
                    var el = utils.dom.get(this.element);
                    el.$component = path;

                    // console.log('ready', this);
                },
                'onLoad' : function (){
                    // console.log('load', this);
                }
            });
        });
    };

    this.$static.get = function (search, args){
        if (utils.is.either(args, 'arr,fn')){
            var callbacks = utils.is.arr(args) ? args : [args];
            args = {
                'callback': callbacks[0],
                'onAll'   : callbacks[1]
            };
        }

        args          = args || {};
        args.context  = args.context || null;
        args.single   = args.single || false;
        args.callback = args.callback || null;
        args.lazy     = args.lazy || true;      // wait till the elements are ready to finish the call
        args.onAll    = args.onAll || null;
        
        var items = [];
        if (utils.is.obj(search, true)){
            search.types    = utils.toArray(search.types || search.type || []);
            search.parent   = 'parent' in search ? search.parent : document;
            search.contains = search.contains || false;
            search.children = search.children || false;  // direct children on the component
         
            var parent   = utils.dom.get(search.parent);
            var contains = search.contains && utils.dom.get(search.contains);
            var elements = !parent ? [] : utils.dom.getAll('[is]', {
                'context'       : parent,
                'excludeClosest': search.children ? '[is]' : false,
            });

            items = utils.each(elements, {'filter':true}, function (el){
                var item = utils.cache(el, 'component');

                if (!item) return;

                if (contains && !utils.dom.contains(el, contains)){
                    return;
                }

                if (search.types.length){
                    var types  = item.getTypes();
                    var exists = utils.array.intersect(search.types, types);
                    if (!exists.length){
                        return;
                    }
                }
                
                utils.apply(args.callback, [item], args.context);

                return item;
            });

            utils.apply(args.onAll, [items], args.context);
        }else{
            var element;
            element     = utils.dom.get(search);
            element     = utils.el.closest(element, '[is]');
            items       = utils.cache(element, 'component');
            items       = [items];
            args.single = true;
        }

        return args.single ? items[0] : items;
    };

    this.$static.ready = function (items, args, callback){
        if (utils.is.fn(args)){
            args = {'callback':args};
        }

        var items = utils.toArray(items);
        
        args          = args || {};
        args.context  = args.context || null;
        args.callback = callback || args.callback || null;

        this.queues.push({
            'search': items,
            'args'  : args,
        });

        this.check();
    };

    // check the queue
    this.$static.check = function (){
        var self = this;

        // check if the item is matched
        var ready = [];
        utils.array.remove(this.queues, function (q){
            var items = utils.each(q.search, {'filter':true}, function (s){
                return self.get(s);
            });
            
            if (items.length === q.search.length){
                ready.push({
                    'items'   : utils.object.reindex(items, 'id'),
                    'callback': q.args.callback,
                    'context' : q.args.context,
                });
                return true;
            }
        });

        // call the ready items
        utils.each(ready, function (v){
            utils.apply(v.callback, [v.items], v.context);
        });
    };

    // properties --------------------------------------------------------------
    this.vars = {
        
    };
    
    this.style = {
        '&.no-animation *' : 'transition: none !important;',
    };

    this.html = null;

    this.props = {
        'enable:Boolean' : true,
        'debug:Boolean'  : false,
    };

    this.states = {
        // 'enable': true,
        'debug' : false,
    };

    this.$data = {

    };

    // this.children = {};

    // refresh on window resize
    this.resizeRefresh = false; // [false, true, 'element' for only when the element resizes]

    // mixin functions ---------------------------------------------------------

    // private functions -------------------------------------------------------

    // get/set -----------------------------------------------------------------
    // this.$get.debug = function (){ return this.props.debug; };
    // this.$set.debug = function (v){ this.props.debug = v; };
    
    // init --------------------------------------------------------------------
    this.preInit = function (params){
        params = params || [];

        var el        = params[0];
        var styleName = (params[2] && params[2].style) || '';
        var pathKey   = (params[2] && params[2].path) || this.getTypeClass().replace(/\-/g, '/');
        var styleKey  = pathKey + '.' + styleName;
        var path  = COMPONENTS[pathKey] || {};
        var style = COMPONENTS[styleKey] || {};
        
        // Setup ---------------------------------------------------------------
        var setup = utils.is.el(el, 'script') ? el : this._nodes('script[type="json/setup"]', {'context':el, 'remove':true})[0];
        var props = utils.is.el(el, 'script') ? null : this._nodes('script[type="json/props"]', {'context':el, 'remove':true})[0];
        var data  = utils.is.el(el, 'script') ? null : this._nodes('> script[type="json/data"]', {'context':el, 'remove':true})[0];

        setup = utils.toJson(setup && setup.innerHTML, {'warn':true, 'fallback':{}});
        props = utils.toJson(props && props.innerHTML, {'warn':true, 'fallback':{}});
        data  = utils.toJson(data && data.innerHTML, {'warn':true, 'fallback':{}});

        setup.props = utils.extend(setup.props || {}, props || {});
        setup.data  = utils.extend(setup.data || {}, data || {});

        if (setup.data){
            utils.extend(this.$data, setup.data);
            delete(setup.data);
        }
        
        this.proxy(path, {'skip':'props', 'merge':'events,filters,states'});
        this.proxy(style, {'skip':'props', 'merge':'events,filters,states'});
        this.proxy(setup, {'skip':'props', 'merge':'events,filters,states'});

        // @todo ID component
        // @todo add filters, events, ... from COMPONENTS

        // merge the props from COMPONENTS
        utils.defaults(params[1], setup.props || {});
        utils.defaults(params[1], style.props || {});
        utils.defaults(params[1], path.props || {});

        // Check for defaul
        this.strings = utils.defaults(this.strings || {}, this.$static.strings || {});

        return params;
    };

    this._init = function (init, el, props, args){

        // style class
        this.element && utils.dom.addClass(this.element, this.$static.stylePrefix + args.style);

        // states
        var states = this.stateClassnames(this.$static.statePrefix);
        this.element.classnames(states);
        
        if ('debug' in this.props){
            this.debug = this.props.debug;
            this.setState(STATES.DEBUG, this.debug);
        }

        var el2 = utils.dom.get(el);
        if (utils.is.element(el2, 'script')){
            var el = el2.getAttribute('target') || 'body';
            this.element = this.$(el);
        }

        // attributes/classnames
        this.elements.self.attrs({
            'ready'  : true,
            'loaded' : true,
        }).cache({
            'component' : this,
        });

        this.init(el, props, args);

        // add to parent

        this.addEvents();
        this.refresh();
        this.fx(true);
        
        this.when('loaded', true);
        this.trigger('load');
        this.mount();

        this.element.attr('id', this.id);

        // check the queue list if something is waiting for this compoment
        this.$static.check();
    };

    this.addEvents = function (){
        this.on(Browser, 'resize', browser_onResize);
        this.onScroll && this.on(Browser, 'scroll', browser_onScroll);
    };

    this.removeEvents = function (){

    };

    this.cache = function (){
        
    };

    this.uncache = function (){

    };

    this.render = function (){
        this.renderBindings();
        this.trigger('render');
    };

    this.unrender = function (){
        this.trigger('unrender');
    };

    this.mount = function (){
        // this.when('mount', true);
        this.trigger('mount');
        this.isMounted = true;
    };

    this.destroy = function (){
        console.log('destroy component');
    };

    this.refresh = function (type){
        this.element.attrs({
            'enable' : this.props.enable,
        });

       if (this.props.enable){
            if (type === REFRESH_TYPES.CHILDREN){
                this.children(function (item){ 
                    item.refresh(); 
                });
            }else{
                this.cache();
                this.render();
            }

			//if (this._refreshChildren){
				//this.refreshChildren();
			//}
		}else{
			this.uncache();
			this.unrender();
		}
    };

    // events ------------------------------------------------------------------
    this.onStateChange = function (e){
        this.$super();
        // var classnames = this.stateClassnames(this.$static.statePrefix);
        // this.element.classnames(classnames);
        this.trigger('state-' + e.name + '-change', e);
    };
    
    this.onPropsInvalidate = function (p){
        this.refresh();
    };

    function browser_onResize (e){
        if (this.resizeRefresh && e.isChange){
            this.refresh();
        }

        this.apply(this.onResize, [e]);
    }

    function browser_onScroll (e){
        this.apply(this.onScroll, [e]);
    }

    // methods:items -----------------------------------------------------------
    this.parent = function (){
        // @todo
    };

    this.children = function (search, args){
        if (utils.is.fn(search)){
            args   = {'callback':search};
            search = null;
        }

        search          = search || {};
        search.parent   = this;
        items           = this.$static.get(search, args);

        return items;
    };

	this.contains = function (child, match){
        match = match || true;

        // check if the element contains the child element
        if (!utils.dom.contains(this, child)){
			return false;
		}

        if (match === true){
            return true;
        }

        if (utils.is.string(match) && (child instanceof Component)){
            match = utils.string.decodeSelector(match);

            if (
                (match.type && !child.isType(match.type)) ||
                (match.id && child.id !== match.id)
            ) return false;
            
            // @todo other match to validate
        }

        // find a match with the help of a function
        if (utils.is.fn(match)){
            return utils.match(child, match, {'context':this});
        }

		return true;
	};

    // special states ----------------------------------------------------------
    this.fx = function (v){
        if (utils.is.bool(v)){
            this.element.classnames({
                'no-animation' : !v
            });
            this.apply(this.onFxChange, [v]);
        }
        return this.when('fx', v);
    };

    this.isAnimating = function (v){ 
        if (utils.is.bool(v)){
            this.element.classnames({
                'is-animating' : v
            });
            this.apply(this.onAnimateChange, [v]);
        }
        return this.when('isAnimating', v);
    };

    this.isLoading = function (value, target, key){
        if (utils.is.bool(value)){
            this.trigger('loading', {
                'value' : value,
            });
        }
        return this.$super(value, target, key);
    };

    this.isEnabled = function (v){
        if (utils.is.bool(v)){
            this.props.enable = v;
            this.refresh();
            return this;
        }
        return this.props.enable;
    };

    // methods -----------------------------------------------------------------
    this.__ = function (id, callback){
        var item = (id ? __(id) : null);
        item && this.apply(callback, [item]);
        return this;
    };
    
    this.apply = function (id, callback, params, returnResponse){
        if (utils.is.fn(id)){
            returnResponse = params;
            params         = callback;
            callback       = id;
            id             = null;
        }

        returnResponse = returnResponse === undefined ? true : returnResponse;

        var item = (id ? __(id) : this) || this;
        var ctx  = item;

        if (item && utils.is.str(callback)){
            callback = item[callback];
            ctx      = item;
        }

        var response = utils.apply(callback, params, ctx);

        return returnResponse ? response : this;
    };

    this.http = function (url, data, args, callback){
        url = this.applyFilters('http-url', url, data, args);
        return this.$super(url, data, args, callback);
    };
});

// Trigger the AUTO component parsing
utils.dom.ready(function (){
    Component.start();
}, 10);